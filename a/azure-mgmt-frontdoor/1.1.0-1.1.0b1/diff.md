# Comparing `tmp/azure-mgmt-frontdoor-1.1.0.zip` & `tmp/azure-mgmt-frontdoor-1.1.0b1.zip`

## zipinfo {}

```diff
@@ -1,71 +1,71 @@
-Zip file size: 159463 bytes, number of entries: 69
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/
--rw-rw-r--  2.0 unx     2154 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/README.md
--rw-rw-r--  2.0 unx     8732 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/PKG-INFO
--rw-rw-r--  2.0 unx     2830 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/setup.py
--rw-rw-r--  2.0 unx      215 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/MANIFEST.in
--rw-rw-r--  2.0 unx     5689 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/CHANGELOG.md
--rw-rw-r--  2.0 unx      626 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/_meta.json
--rw-rw-r--  2.0 unx     1074 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/LICENSE
--rw-rw-r--  2.0 unx       38 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/setup.cfg
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx     8732 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx     2833 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/top_level.txt
--rw-rw-r--  2.0 unx      124 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/requires.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/dependency_links.txt
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/
--rw-rw-r--  2.0 unx      486 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_version.py
--rw-rw-r--  2.0 unx     1530 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_patch.py
--rw-rw-r--  2.0 unx    78836 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_serialization.py
--rw-rw-r--  2.0 unx     7775 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_front_door_management_client.py
--rw-rw-r--  2.0 unx     3330 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_configuration.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_vendor.py
--rw-rw-r--  2.0 unx       26 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/py.typed
--rw-rw-r--  2.0 unx      916 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:04 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/
--rw-rw-r--  2.0 unx     1530 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_patch.py
--rw-rw-r--  2.0 unx     7955 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_front_door_management_client.py
--rw-rw-r--  2.0 unx     3378 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_configuration.py
--rw-rw-r--  2.0 unx      863 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    11008 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_reports_operations.py
--rw-rw-r--  2.0 unx    26839 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py
--rw-rw-r--  2.0 unx    39829 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_policies_operations.py
--rw-rw-r--  2.0 unx    27402 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py
--rw-rw-r--  2.0 unx     1998 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    35450 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py
--rw-rw-r--  2.0 unx     5925 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py
--rw-rw-r--  2.0 unx     7603 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py
--rw-rw-r--  2.0 unx    13294 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     7460 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py
--rw-rw-r--  2.0 unx     5376 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py
--rw-rw-r--  2.0 unx    38050 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py
--rw-rw-r--  2.0 unx    39304 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_patch.py
--rw-rw-r--  2.0 unx    15955 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_reports_operations.py
--rw-rw-r--  2.0 unx    34224 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py
--rw-rw-r--  2.0 unx    47840 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_policies_operations.py
--rw-rw-r--  2.0 unx    34670 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_rules_engines_operations.py
--rw-rw-r--  2.0 unx     1998 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/__init__.py
--rw-rw-r--  2.0 unx    44263 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_doors_operations.py
--rw-rw-r--  2.0 unx     7427 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py
--rw-rw-r--  2.0 unx     8853 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py
--rw-rw-r--  2.0 unx    15012 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     8401 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py
--rw-rw-r--  2.0 unx     6420 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py
--rw-rw-r--  2.0 unx    46284 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_experiments_operations.py
--rw-rw-r--  2.0 unx    47540 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py
--rw-rw-r--  2.0 unx   210279 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_patch.py
--rw-rw-r--  2.0 unx    12393 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/__init__.py
--rw-rw-r--  2.0 unx    14514 b- defN 23-May-22 09:03 azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py
-69 files, 958745 bytes uncompressed, 144507 bytes compressed:  84.9%
+Zip file size: 159479 bytes, number of entries: 69
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/
+-rw-rw-r--  2.0 unx      215 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx     1074 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/LICENSE
+-rw-rw-r--  2.0 unx     1360 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/README.md
+-rw-rw-r--  2.0 unx     5403 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx      626 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/_meta.json
+-rw-rw-r--  2.0 unx     2822 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/setup.py
+-rw-rw-r--  2.0 unx       38 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/setup.cfg
+-rw-rw-r--  2.0 unx     7654 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/PKG-INFO
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/
+-rw-rw-r--  2.0 unx     7751 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_front_door_management_client.py
+-rw-rw-r--  2.0 unx     1169 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_vendor.py
+-rw-rw-r--  2.0 unx     3330 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_configuration.py
+-rw-rw-r--  2.0 unx      488 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_version.py
+-rw-rw-r--  2.0 unx    77872 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_serialization.py
+-rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_patch.py
+-rw-rw-r--  2.0 unx       26 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/py.typed
+-rw-rw-r--  2.0 unx      916 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/
+-rw-rw-r--  2.0 unx     7926 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_front_door_management_client.py
+-rw-rw-r--  2.0 unx     3378 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_configuration.py
+-rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_patch.py
+-rw-rw-r--  2.0 unx      863 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/__init__.py
+-rw-rw-r--  2.0 unx     7661 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py
+-rw-rw-r--  2.0 unx    27626 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py
+-rw-rw-r--  2.0 unx    38260 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py
+-rw-rw-r--  2.0 unx     5594 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py
+-rw-rw-r--  2.0 unx    11222 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_reports_operations.py
+-rw-rw-r--  2.0 unx    36673 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_policies_operations.py
+-rw-rw-r--  2.0 unx    39508 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py
+-rw-rw-r--  2.0 unx    27050 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py
+-rw-rw-r--  2.0 unx     7804 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     6143 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py
+-rw-rw-r--  2.0 unx    35636 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py
+-rw-rw-r--  2.0 unx    13524 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx     1998 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     8620 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py
+-rw-rw-r--  2.0 unx    34966 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_rules_engines_operations.py
+-rw-rw-r--  2.0 unx    46584 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_experiments_operations.py
+-rw-rw-r--  2.0 unx     6656 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py
+-rw-rw-r--  2.0 unx    16205 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_reports_operations.py
+-rw-rw-r--  2.0 unx    43767 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_policies_operations.py
+-rw-rw-r--  2.0 unx    47852 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py
+-rw-rw-r--  2.0 unx    34507 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py
+-rw-rw-r--  2.0 unx     9072 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_patch.py
+-rw-rw-r--  2.0 unx     7663 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py
+-rw-rw-r--  2.0 unx    44557 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_doors_operations.py
+-rw-rw-r--  2.0 unx    15260 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx     1998 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/__init__.py
+-rw-rw-r--  2.0 unx   207511 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_patch.py
+-rw-rw-r--  2.0 unx    14444 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py
+-rw-rw-r--  2.0 unx    12235 b- defN 22-Nov-23 02:09 azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/__init__.py
+-rw-rw-r--  2.0 unx        6 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx        1 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx      116 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/requires.txt
+-rw-rw-r--  2.0 unx     2833 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx     7654 b- defN 22-Nov-23 02:10 azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/PKG-INFO
+69 files, 949330 bytes uncompressed, 144247 bytes compressed:  84.8%
```

## zipnote {}

```diff
@@ -1,208 +1,208 @@
-Filename: azure-mgmt-frontdoor-1.1.0/
+Filename: azure-mgmt-frontdoor-1.1.0b1/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/README.md
+Filename: azure-mgmt-frontdoor-1.1.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/PKG-INFO
+Filename: azure-mgmt-frontdoor-1.1.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/setup.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/MANIFEST.in
+Filename: azure-mgmt-frontdoor-1.1.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/CHANGELOG.md
+Filename: azure-mgmt-frontdoor-1.1.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/_meta.json
+Filename: azure-mgmt-frontdoor-1.1.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/LICENSE
+Filename: azure-mgmt-frontdoor-1.1.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/setup.cfg
+Filename: azure-mgmt-frontdoor-1.1.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/not-zip-safe
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/PKG-INFO
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/SOURCES.txt
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/top_level.txt
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/requires.txt
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/dependency_links.txt
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_front_door_management_client.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_version.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_patch.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_version.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/py.typed
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_patch.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_serialization.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_front_door_management_client.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_front_door_management_client.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_configuration.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_vendor.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/py.typed
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_patch.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_front_door_management_client.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_configuration.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_reports_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_patch.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_reports_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_policies_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_rules_engines_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_experiments_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_reports_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_patch.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_reports_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_policies_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_rules_engines_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_doors_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_doors_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_endpoints_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_experiments_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_models_py3.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_patch.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/__init__.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py
+Filename: azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/PKG-INFO
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-frontdoor-1.1.0/PKG-INFO` & `azure-mgmt-frontdoor-1.1.0b1/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-frontdoor
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure Front Door Service Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,81 +27,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [Front Door Service](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-frontdoor
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.frontdoor import FrontDoorManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = FrontDoorManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search Front Door Service](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-frontdoor%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-05-19)
-
-### Features Added
-
-  - Added operation PoliciesOperations.begin_update
-  - Added operation PoliciesOperations.list_by_subscription
-  - Model FrontDoor has a new parameter extended_properties
-  - Model FrontDoorProperties has a new parameter extended_properties
-
 ## 1.1.0b1 (2022-11-22)
 
 ### Features Added
 
   - Added operation PoliciesOperations.begin_update
   - Model FrontDoor has a new parameter extended_properties
   - Model FrontDoorProperties has a new parameter extended_properties
```

## Comparing `azure-mgmt-frontdoor-1.1.0/setup.py` & `azure-mgmt-frontdoor-1.1.0b1/setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -66,14 +66,14 @@
         'azure.mgmt',
     ]),
     include_package_data=True,
     package_data={
         'pytyped': ['py.typed'],
     },
     install_requires=[
-        "isodate<1.0.0,>=0.6.1",
+        "msrest>=0.7.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
     python_requires=">=3.7"
 )
```

## Comparing `azure-mgmt-frontdoor-1.1.0/CHANGELOG.md` & `azure-mgmt-frontdoor-1.1.0b1/CHANGELOG.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,9 @@
 # Release History
 
-## 1.1.0 (2023-05-19)
-
-### Features Added
-
-  - Added operation PoliciesOperations.begin_update
-  - Added operation PoliciesOperations.list_by_subscription
-  - Model FrontDoor has a new parameter extended_properties
-  - Model FrontDoorProperties has a new parameter extended_properties
-
 ## 1.1.0b1 (2022-11-22)
 
 ### Features Added
 
   - Added operation PoliciesOperations.begin_update
   - Model FrontDoor has a new parameter extended_properties
   - Model FrontDoorProperties has a new parameter extended_properties
```

## Comparing `azure-mgmt-frontdoor-1.1.0/_meta.json` & `azure-mgmt-frontdoor-1.1.0b1/_meta.json`

 * *Files 9% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/frontdoor/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'fc0c0316bf5187af413a256c484c1e2a259e18b8'",*

 * * "'use'": "{inser […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/frontdoor/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.8 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "7a65f22cf67826187f75981e914c7e679039257b",
+    "autorest_command": "autorest specification/frontdoor/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "fc0c0316bf5187af413a256c484c1e2a259e18b8",
     "readme": "specification/frontdoor/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.8",
+        "@autorest/python@6.2.7",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-frontdoor-1.1.0/LICENSE` & `azure-mgmt-frontdoor-1.1.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/PKG-INFO` & `azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-frontdoor
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure Front Door Service Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,81 +27,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [Front Door Service](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-frontdoor
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.frontdoor import FrontDoorManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = FrontDoorManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search Front Door Service](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-frontdoor%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-05-19)
-
-### Features Added
-
-  - Added operation PoliciesOperations.begin_update
-  - Added operation PoliciesOperations.list_by_subscription
-  - Model FrontDoor has a new parameter extended_properties
-  - Model FrontDoorProperties has a new parameter extended_properties
-
 ## 1.1.0b1 (2022-11-22)
 
 ### Features Added
 
   - Added operation PoliciesOperations.begin_update
   - Model FrontDoor has a new parameter extended_properties
   - Model FrontDoorProperties has a new parameter extended_properties
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure_mgmt_frontdoor.egg-info/SOURCES.txt` & `azure-mgmt-frontdoor-1.1.0b1/azure_mgmt_frontdoor.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_patch.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_serialization.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,47 +34,30 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import (
-    Dict,
-    Any,
-    cast,
-    Optional,
-    Union,
-    AnyStr,
-    IO,
-    Mapping,
-    Callable,
-    TypeVar,
-    MutableMapping,
-    Type,
-    List,
-    Mapping,
-)
+from typing import Optional, Union, AnyStr, IO, Mapping
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
+from typing import Dict, Any, cast
+
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
-from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
-ModelType = TypeVar("ModelType", bound="Model")
-JSON = MutableMapping[str, Any]
-
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -290,43 +273,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Dict[str, Any] = {}
+    def __init__(self, **kwargs):
+        self.additional_properties = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other: Any) -> bool:
+    def __eq__(self, other):
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other: Any) -> bool:
+    def __ne__(self, other):
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self) -> str:
+    def __str__(self):
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls) -> None:
+    def enable_additional_properties_sending(cls):
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls) -> bool:
+    def is_xml_model(cls):
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -335,35 +318,30 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
+    def serialize(self, keep_readonly=False, **kwargs):
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(
-        self,
-        keep_readonly: bool = True,
-        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
-        **kwargs: Any
-    ) -> JSON:
-        """Return a dict that can be serialized using json.dump.
+    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
+        """Return a dict that can be JSONify using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -402,46 +380,41 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
+    def deserialize(cls, data, content_type=None):
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(
-        cls: Type[ModelType],
-        data: Any,
-        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
-        content_type: Optional[str] = None,
-    ) -> ModelType:
+    def from_dict(cls, data, key_extractors=None, content_type=None):
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (  # type: ignore
-            [  # type: ignore
+        deserializer.key_extractors = (
+            [
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -541,15 +514,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -557,15 +530,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -625,15 +598,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+                                xml_name = "{}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -649,15 +622,16 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            new_attr = {k: new_attr}
+                            unflattened = {k: new_attr}
+                            new_attr = unflattened
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -678,16 +652,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type_str = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type_str, None)
+        internal_data_type = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -799,16 +773,14 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is AzureCoreNull:
-                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1185,16 +1157,15 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        # Need the cast, as for some reasons "split" is typed as list[str | Any]
-        dict_keys = cast(List[str], _FLATTEN.split(key))
+        dict_keys = _FLATTEN.split(key)
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1267,15 +1238,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1291,15 +1262,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1357,15 +1328,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1377,15 +1348,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1496,40 +1467,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__  # type: ignore
+        return target, target.__class__.__name__
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_front_door_management_client.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_front_door_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -84,15 +84,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = FrontDoorManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.policies = PoliciesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.managed_rule_sets = ManagedRuleSetsOperations(
@@ -144,9 +144,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "FrontDoorManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details: Any) -> None:
+    def __exit__(self, *exc_details) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_configuration.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/_vendor.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from typing import List, cast
-
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -20,11 +18,10 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            # Need the cast, as for some reasons "split" is typed as list[str | Any]
-            formatted_components = cast(List[str], template.split("/"))
+            formatted_components = template.split("/")
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/__init__.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_patch.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_front_door_management_client.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_front_door_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -84,15 +84,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = FrontDoorManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.policies = PoliciesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.managed_rule_sets = ManagedRuleSetsOperations(
@@ -144,9 +144,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "FrontDoorManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details: Any) -> None:
+    async def __aexit__(self, *exc_details) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/_configuration.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/__init__.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_patch.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_reports_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_reports_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import datetime
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._reports_operations import build_get_latency_scorecards_request, build_get_timeseries_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ReportsOperations:
     """
     .. warning::
@@ -94,15 +99,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.LatencyScorecard] = kwargs.pop("cls", None)
 
         request = build_get_latency_scorecards_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -113,17 +118,16 @@
             template_url=self.get_latency_scorecards.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -191,15 +195,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Timeseries] = kwargs.pop("cls", None)
 
         request = build_get_timeseries_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -213,17 +217,16 @@
             template_url=self.get_timeseries.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_frontend_endpoints_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -32,14 +33,18 @@
 from ...operations._frontend_endpoints_operations import (
     build_disable_https_request,
     build_enable_https_request,
     build_get_request,
     build_list_by_front_door_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class FrontendEndpointsOperations:
     """
     .. warning::
@@ -73,15 +78,15 @@
         :return: An iterator like instance of either FrontendEndpoint or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.FrontendEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontendEndpointsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -116,17 +121,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -164,15 +168,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontendEndpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             frontend_endpoint_name=frontend_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -180,17 +184,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -222,15 +225,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(custom_https_configuration, (IO, bytes)):
@@ -250,17 +253,16 @@
             template_url=self._enable_https_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -364,15 +366,15 @@
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param frontend_endpoint_name: Name of the Frontend endpoint which is unique within the Front
          Door. Required.
         :type frontend_endpoint_name: str
         :param custom_https_configuration: The configuration specifying how to enable HTTPS. Is either
-         a CustomHttpsConfiguration type or a IO type. Required.
+         a model type or a IO type. Required.
         :type custom_https_configuration: ~azure.mgmt.frontdoor.models.CustomHttpsConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -384,15 +386,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._enable_https_initial(  # type: ignore
@@ -445,15 +447,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_https_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             frontend_endpoint_name=frontend_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -461,17 +463,16 @@
             template_url=self._disable_https_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -508,15 +509,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._disable_https_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_policies_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_policies_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -29,19 +30,22 @@
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._policies_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
-    build_list_by_subscription_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PoliciesOperations:
     """
     .. warning::
@@ -73,15 +77,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.WebApplicationFirewallPolicyList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -115,17 +119,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -134,88 +137,14 @@
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies"
     }
 
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.WebApplicationFirewallPolicy"]:
-        """Lists all of the protection policies within a subscription.
-
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either WebApplicationFirewallPolicy or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
-        cls: ClsType[_models.WebApplicationFirewallPolicyList] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                request = HttpRequest("GET", next_link)
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("WebApplicationFirewallPolicyList", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.DefaultErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies"
-    }
-
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, policy_name: str, **kwargs: Any
     ) -> _models.WebApplicationFirewallPolicy:
         """Retrieve protection policy with specified name within a resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
@@ -234,32 +163,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -290,15 +218,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -317,17 +245,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -433,16 +360,15 @@
     ) -> AsyncLROPoller[_models.WebApplicationFirewallPolicy]:
         """Create or update policy with specified rule set name within a resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param policy_name: The name of the Web Application Firewall Policy. Required.
         :type policy_name: str
-        :param parameters: Policy to be created. Is either a WebApplicationFirewallPolicy type or a IO
-         type. Required.
+        :param parameters: Policy to be created. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -456,15 +382,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -515,15 +441,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -542,17 +468,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -651,15 +576,15 @@
         subscription and resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param policy_name: The name of the Web Application Firewall Policy. Required.
         :type policy_name: str
         :param parameters: FrontdoorWebApplicationFirewallPolicy parameters to be patched. Is either a
-         TagsObject type or a IO type. Required.
+         model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.TagsObject or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -673,15 +598,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -732,32 +657,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -788,15 +712,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_rules_engines_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -32,14 +33,18 @@
 from ...operations._rules_engines_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_front_door_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RulesEnginesOperations:
     """
     .. warning::
@@ -73,15 +78,15 @@
         :return: An iterator like instance of either RulesEngine or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.RulesEngine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.RulesEngineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -116,17 +121,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -164,15 +168,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             rules_engine_name=rules_engine_name,
             subscription_id=self._config.subscription_id,
@@ -180,17 +184,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -222,15 +225,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(rules_engine_parameters, (IO, bytes)):
@@ -250,17 +253,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -382,15 +384,15 @@
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param rules_engine_name: Name of the Rules Engine which is unique within the Front Door.
          Required.
         :type rules_engine_name: str
         :param rules_engine_parameters: Rules Engine Configuration properties needed to create a new
-         Rules Engine Configuration. Is either a RulesEngine type or a IO type. Required.
+         Rules Engine Configuration. Is either a model type or a IO type. Required.
         :type rules_engine_parameters: ~azure.mgmt.frontdoor.models.RulesEngine or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -403,15 +405,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.RulesEngine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -466,15 +468,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             rules_engine_name=rules_engine_name,
             subscription_id=self._config.subscription_id,
@@ -482,17 +484,16 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -529,15 +530,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/__init__.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_doors_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -34,14 +35,18 @@
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_request,
     build_validate_custom_domain_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class FrontDoorsOperations:
     """
     .. warning::
@@ -69,15 +74,15 @@
         :return: An iterator like instance of either FrontDoor or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -110,17 +115,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -141,15 +145,15 @@
         :return: An iterator like instance of either FrontDoor or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -183,17 +187,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -227,32 +230,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -283,15 +285,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(front_door_parameters, (IO, bytes)):
@@ -310,17 +312,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -430,15 +431,15 @@
         group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param front_door_parameters: Front Door properties needed to create a new Front Door. Is
-         either a FrontDoor type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type front_door_parameters: ~azure.mgmt.frontdoor.models.FrontDoor or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -451,15 +452,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -513,32 +514,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -570,15 +570,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -684,16 +684,16 @@
         """Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in
         DNS.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
-        :param custom_domain_properties: Custom domain to be validated. Is either a
-         ValidateCustomDomainInput type or a IO type. Required.
+        :param custom_domain_properties: Custom domain to be validated. Is either a model type or a IO
+         type. Required.
         :type custom_domain_properties: ~azure.mgmt.frontdoor.models.ValidateCustomDomainInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateCustomDomainOutput or the result of cls(response)
         :rtype: ~azure.mgmt.frontdoor.models.ValidateCustomDomainOutput
@@ -706,15 +706,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidateCustomDomainOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(custom_domain_properties, (IO, bytes)):
@@ -733,17 +733,16 @@
             template_url=self.validate_custom_domain.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_preconfigured_endpoints_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -24,14 +25,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._preconfigured_endpoints_operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PreconfiguredEndpointsOperations:
     """
     .. warning::
@@ -69,15 +74,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.PreconfiguredEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.PreconfiguredEndpointList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,17 +117,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -21,28 +22,32 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._front_door_name_availability_with_subscription_operations import build_check_request
+from ...operations._front_door_name_availability_operations import build_check_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class FrontDoorNameAvailabilityWithSubscriptionOperations:
+class FrontDoorNameAvailabilityOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.frontdoor.aio.FrontDoorManagementClient`'s
-        :attr:`front_door_name_availability_with_subscription` attribute.
+        :attr:`front_door_name_availability` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -54,15 +59,15 @@
     async def check(
         self,
         check_front_door_name_availability_input: _models.CheckNameAvailabilityInput,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door subdomain.
+        """Check the availability of a Front Door resource name.
 
         :param check_front_door_name_availability_input: Input to check. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -72,15 +77,15 @@
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def check(
         self, check_front_door_name_availability_input: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door subdomain.
+        """Check the availability of a Front Door resource name.
 
         :param check_front_door_name_availability_input: Input to check. Required.
         :type check_front_door_name_availability_input: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -89,18 +94,18 @@
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def check(
         self, check_front_door_name_availability_input: Union[_models.CheckNameAvailabilityInput, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door subdomain.
+        """Check the availability of a Front Door resource name.
 
-        :param check_front_door_name_availability_input: Input to check. Is either a
-         CheckNameAvailabilityInput type or a IO type. Required.
+        :param check_front_door_name_availability_input: Input to check. Is either a model type or a IO
+         type. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityOutput or the result of cls(response)
@@ -114,42 +119,40 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameAvailabilityOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(check_front_door_name_availability_input, (IO, bytes)):
             _content = check_front_door_name_availability_input
         else:
             _json = self._serialize.body(check_front_door_name_availability_input, "CheckNameAvailabilityInput")
 
         request = build_check_request(
-            subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -158,10 +161,8 @@
         deserialized = self._deserialize("CheckNameAvailabilityOutput", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkFrontDoorNameAvailability"
-    }
+    check.metadata = {"url": "/providers/Microsoft.Network/checkFrontDoorNameAvailability"}
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_endpoints_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,14 +26,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._endpoints_operations import build_purge_content_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class EndpointsOperations:
     """
     .. warning::
@@ -66,15 +71,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(content_file_paths, (IO, bytes)):
@@ -93,17 +98,16 @@
             template_url=self._purge_content_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -200,16 +204,16 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param content_file_paths: The path to the content to be purged. Path can be a full URL, e.g.
          '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g.
-         '/pictures/*' which removes all folders and files in the directory. Is either a PurgeParameters
-         type or a IO type. Required.
+         '/pictures/*' which removes all folders and files in the directory. Is either a model type or a
+         IO type. Required.
         :type content_file_paths: ~azure.mgmt.frontdoor.models.PurgeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -221,15 +225,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._purge_content_initial(  # type: ignore
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_front_door_name_availability_with_subscription_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -21,28 +22,32 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._front_door_name_availability_operations import build_check_request
+from ...operations._front_door_name_availability_with_subscription_operations import build_check_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class FrontDoorNameAvailabilityOperations:
+class FrontDoorNameAvailabilityWithSubscriptionOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.frontdoor.aio.FrontDoorManagementClient`'s
-        :attr:`front_door_name_availability` attribute.
+        :attr:`front_door_name_availability_with_subscription` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -54,15 +59,15 @@
     async def check(
         self,
         check_front_door_name_availability_input: _models.CheckNameAvailabilityInput,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door resource name.
+        """Check the availability of a Front Door subdomain.
 
         :param check_front_door_name_availability_input: Input to check. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
@@ -72,15 +77,15 @@
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def check(
         self, check_front_door_name_availability_input: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door resource name.
+        """Check the availability of a Front Door subdomain.
 
         :param check_front_door_name_availability_input: Input to check. Required.
         :type check_front_door_name_availability_input: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -89,18 +94,18 @@
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def check(
         self, check_front_door_name_availability_input: Union[_models.CheckNameAvailabilityInput, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
-        """Check the availability of a Front Door resource name.
+        """Check the availability of a Front Door subdomain.
 
-        :param check_front_door_name_availability_input: Input to check. Is either a
-         CheckNameAvailabilityInput type or a IO type. Required.
+        :param check_front_door_name_availability_input: Input to check. Is either a model type or a IO
+         type. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityOutput or the result of cls(response)
@@ -114,41 +119,41 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameAvailabilityOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(check_front_door_name_availability_input, (IO, bytes)):
             _content = check_front_door_name_availability_input
         else:
             _json = self._serialize.body(check_front_door_name_availability_input, "CheckNameAvailabilityInput")
 
         request = build_check_request(
+            subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -157,8 +162,10 @@
         deserialized = self._deserialize("CheckNameAvailabilityOutput", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    check.metadata = {"url": "/providers/Microsoft.Network/checkFrontDoorNameAvailability"}
+    check.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkFrontDoorNameAvailability"
+    }
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_managed_rule_sets_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -24,14 +25,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._managed_rule_sets_operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ManagedRuleSetsOperations:
     """
     .. warning::
@@ -61,15 +66,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.ManagedRuleSetDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.ManagedRuleSetDefinitionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -102,17 +107,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_experiments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -33,14 +34,18 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_profile_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ExperimentsOperations:
     """
     .. warning::
@@ -76,15 +81,15 @@
         :return: An iterator like instance of either Experiment or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ExperimentList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -119,17 +124,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -168,15 +172,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -184,17 +188,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -226,15 +229,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -254,17 +257,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -383,15 +385,15 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param experiment_name: The Experiment identifier associated with the Experiment. Required.
         :type experiment_name: str
-        :param parameters: The Experiment resource. Is either a Experiment type or a IO type. Required.
+        :param parameters: The Experiment resource. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.Experiment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -404,15 +406,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -469,15 +471,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -497,17 +499,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -623,16 +624,15 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param experiment_name: The Experiment identifier associated with the Experiment. Required.
         :type experiment_name: str
-        :param parameters: The Experiment Update Model. Is either a ExperimentUpdateModel type or a IO
-         type. Required.
+        :param parameters: The Experiment Update Model. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.ExperimentUpdateModel or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -645,15 +645,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -705,15 +705,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -721,17 +721,16 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -769,15 +768,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/aio/operations/_network_experiment_profiles_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -34,14 +35,18 @@
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class NetworkExperimentProfilesOperations:
     """
     .. warning::
@@ -71,15 +76,15 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ProfileList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -112,17 +117,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -145,15 +149,15 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ProfileList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -187,17 +191,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -232,32 +235,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -284,15 +286,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -311,17 +313,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -427,15 +428,15 @@
 
         Creates an NetworkExperiment Profile.
 
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
-        :param parameters: An Network Experiment Profile. Is either a Profile type or a IO type.
+        :param parameters: An Network Experiment Profile. Is either a model type or a IO type.
          Required.
         :type parameters: ~azure.mgmt.frontdoor.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -449,15 +450,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -512,15 +513,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -539,17 +540,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -656,16 +656,15 @@
 
         Updates an NetworkExperimentProfiles.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
-        :param parameters: The Profile Update Model. Is either a ProfileUpdateModel type or a IO type.
-         Required.
+        :param parameters: The Profile Update Model. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.ProfileUpdateModel or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -678,15 +677,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -737,32 +736,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -796,15 +794,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_patch.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_reports_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_reports_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import datetime
+import sys
 from typing import Any, Callable, Dict, Optional, TypeVar, Union
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,14 +25,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -45,15 +50,15 @@
     end_date_time_utc: Optional[str] = None,
     country: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}/LatencyScorecard",
     )  # pylint: disable=line-too-long
@@ -102,15 +107,15 @@
     endpoint: Optional[str] = None,
     country: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}/Timeseries",
     )  # pylint: disable=line-too-long
@@ -211,15 +216,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.LatencyScorecard] = kwargs.pop("cls", None)
 
         request = build_get_latency_scorecards_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -230,17 +235,16 @@
             template_url=self.get_latency_scorecards.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -308,15 +312,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Timeseries] = kwargs.pop("cls", None)
 
         request = build_get_timeseries_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -330,17 +334,16 @@
             template_url=self.get_timeseries.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_frontend_endpoints_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,28 +27,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_front_door_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints",
     )  # pylint: disable=line-too-long
@@ -84,15 +89,15 @@
 
 def build_get_request(
     resource_group_name: str, front_door_name: str, frontend_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}",
     )  # pylint: disable=line-too-long
@@ -137,15 +142,15 @@
 
 def build_enable_https_request(
     resource_group_name: str, front_door_name: str, frontend_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}/enableHttps",
@@ -193,15 +198,15 @@
 
 def build_disable_https_request(
     resource_group_name: str, front_door_name: str, frontend_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/frontendEndpoints/{frontendEndpointName}/disableHttps",
     )  # pylint: disable=line-too-long
@@ -277,15 +282,15 @@
         :return: An iterator like instance of either FrontendEndpoint or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.FrontendEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontendEndpointsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -320,17 +325,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -368,15 +372,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontendEndpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             frontend_endpoint_name=frontend_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -384,17 +388,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -426,15 +429,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(custom_https_configuration, (IO, bytes)):
@@ -454,17 +457,16 @@
             template_url=self._enable_https_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -568,15 +570,15 @@
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param frontend_endpoint_name: Name of the Frontend endpoint which is unique within the Front
          Door. Required.
         :type frontend_endpoint_name: str
         :param custom_https_configuration: The configuration specifying how to enable HTTPS. Is either
-         a CustomHttpsConfiguration type or a IO type. Required.
+         a model type or a IO type. Required.
         :type custom_https_configuration: ~azure.mgmt.frontdoor.models.CustomHttpsConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -588,15 +590,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._enable_https_initial(  # type: ignore
@@ -648,15 +650,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_https_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             frontend_endpoint_name=frontend_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -664,17 +666,16 @@
             template_url=self._disable_https_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -711,15 +712,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._disable_https_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_policies_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_policies_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,26 +27,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies",
     )  # pylint: disable=line-too-long
@@ -68,46 +73,19 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
 def build_get_request(resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
     )  # pylint: disable=line-too-long
@@ -137,15 +115,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
@@ -178,15 +156,15 @@
 
 def build_update_request(
     resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
@@ -218,15 +196,15 @@
 
 
 def build_delete_request(
     resource_group_name: str, policy_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallPolicies/{policyName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url(
@@ -279,15 +257,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.WebApplicationFirewallPolicyList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -321,17 +299,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -341,87 +318,14 @@
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.WebApplicationFirewallPolicy"]:
-        """Lists all of the protection policies within a subscription.
-
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either WebApplicationFirewallPolicy or the result of
-         cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
-        cls: ClsType[_models.WebApplicationFirewallPolicyList] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                request = HttpRequest("GET", next_link)
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("WebApplicationFirewallPolicyList", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.DefaultErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return ItemPaged(get_next, extract_data)
-
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoorWebApplicationFirewallPolicies"
-    }
-
-    @distributed_trace
     def get(self, resource_group_name: str, policy_name: str, **kwargs: Any) -> _models.WebApplicationFirewallPolicy:
         """Retrieve protection policy with specified name within a resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param policy_name: The name of the Web Application Firewall Policy. Required.
         :type policy_name: str
@@ -437,32 +341,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -493,15 +396,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -520,17 +423,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -636,16 +538,15 @@
     ) -> LROPoller[_models.WebApplicationFirewallPolicy]:
         """Create or update policy with specified rule set name within a resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param policy_name: The name of the Web Application Firewall Policy. Required.
         :type policy_name: str
-        :param parameters: Policy to be created. Is either a WebApplicationFirewallPolicy type or a IO
-         type. Required.
+        :param parameters: Policy to be created. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -659,15 +560,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -718,15 +619,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -745,17 +646,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -854,15 +754,15 @@
         subscription and resource group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param policy_name: The name of the Web Application Firewall Policy. Required.
         :type policy_name: str
         :param parameters: FrontdoorWebApplicationFirewallPolicy parameters to be patched. Is either a
-         TagsObject type or a IO type. Required.
+         model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.TagsObject or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -876,15 +776,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.WebApplicationFirewallPolicy] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -935,32 +835,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             policy_name=policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -991,15 +890,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_rules_engines_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_rules_engines_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,28 +27,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_front_door_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines",
     )  # pylint: disable=line-too-long
@@ -84,15 +89,15 @@
 
 def build_get_request(
     resource_group_name: str, front_door_name: str, rules_engine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
     )  # pylint: disable=line-too-long
@@ -137,15 +142,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, front_door_name: str, rules_engine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
@@ -193,15 +198,15 @@
 
 def build_delete_request(
     resource_group_name: str, front_door_name: str, rules_engine_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/rulesEngines/{rulesEngineName}",
     )  # pylint: disable=line-too-long
@@ -277,15 +282,15 @@
         :return: An iterator like instance of either RulesEngine or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.RulesEngine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.RulesEngineListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -320,17 +325,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -368,15 +372,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             rules_engine_name=rules_engine_name,
             subscription_id=self._config.subscription_id,
@@ -384,17 +388,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -426,15 +429,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(rules_engine_parameters, (IO, bytes)):
@@ -454,17 +457,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -586,15 +588,15 @@
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param rules_engine_name: Name of the Rules Engine which is unique within the Front Door.
          Required.
         :type rules_engine_name: str
         :param rules_engine_parameters: Rules Engine Configuration properties needed to create a new
-         Rules Engine Configuration. Is either a RulesEngine type or a IO type. Required.
+         Rules Engine Configuration. Is either a model type or a IO type. Required.
         :type rules_engine_parameters: ~azure.mgmt.frontdoor.models.RulesEngine or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -607,15 +609,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.RulesEngine]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RulesEngine] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -669,15 +671,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             rules_engine_name=rules_engine_name,
             subscription_id=self._config.subscription_id,
@@ -685,17 +687,16 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -732,15 +733,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/__init__.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_doors_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_doors_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,26 +27,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Network/frontDoors")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -61,15 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
     )  # pylint: disable=line-too-long
@@ -143,15 +148,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
@@ -191,15 +196,15 @@
 
 def build_delete_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}",
     )  # pylint: disable=line-too-long
@@ -236,15 +241,15 @@
 
 def build_validate_custom_domain_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/validateCustomDomain",
@@ -309,15 +314,15 @@
         :return: An iterator like instance of either FrontDoor or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -350,17 +355,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -381,15 +385,15 @@
         :return: An iterator like instance of either FrontDoor or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -423,17 +427,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -467,32 +470,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -523,15 +525,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(front_door_parameters, (IO, bytes)):
@@ -550,17 +552,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -668,15 +669,15 @@
         group.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param front_door_parameters: Front Door properties needed to create a new Front Door. Is
-         either a FrontDoor type or a IO type. Required.
+         either a model type or a IO type. Required.
         :type front_door_parameters: ~azure.mgmt.frontdoor.models.FrontDoor or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -688,15 +689,15 @@
         :return: An instance of LROPoller that returns either FrontDoor or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.FrontDoor]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.FrontDoor] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -749,32 +750,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             front_door_name=front_door_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -806,15 +806,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -919,16 +919,16 @@
         """Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in
         DNS.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
-        :param custom_domain_properties: Custom domain to be validated. Is either a
-         ValidateCustomDomainInput type or a IO type. Required.
+        :param custom_domain_properties: Custom domain to be validated. Is either a model type or a IO
+         type. Required.
         :type custom_domain_properties: ~azure.mgmt.frontdoor.models.ValidateCustomDomainInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ValidateCustomDomainOutput or the result of cls(response)
         :rtype: ~azure.mgmt.frontdoor.models.ValidateCustomDomainOutput
@@ -941,15 +941,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidateCustomDomainOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(custom_domain_properties, (IO, bytes)):
@@ -968,17 +968,16 @@
             template_url=self.validate_custom_domain.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_preconfigured_endpoints_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,26 +25,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/PreconfiguredEndpoints",
     )  # pylint: disable=line-too-long
@@ -107,15 +112,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.PreconfiguredEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.PreconfiguredEndpointList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -150,17 +155,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_with_subscription_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Network/checkFrontDoorNameAvailability"
     )  # pylint: disable=line-too-long
@@ -123,16 +128,16 @@
 
     @distributed_trace
     def check(
         self, check_front_door_name_availability_input: Union[_models.CheckNameAvailabilityInput, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
         """Check the availability of a Front Door subdomain.
 
-        :param check_front_door_name_availability_input: Input to check. Is either a
-         CheckNameAvailabilityInput type or a IO type. Required.
+        :param check_front_door_name_availability_input: Input to check. Is either a model type or a IO
+         type. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityOutput or the result of cls(response)
@@ -146,15 +151,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameAvailabilityOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(check_front_door_name_availability_input, (IO, bytes)):
@@ -171,17 +176,16 @@
             template_url=self.check.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_endpoints_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_endpoints_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,28 +26,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_purge_content_request(
     resource_group_name: str, front_door_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/frontDoors/{frontDoorName}/purge",
@@ -117,15 +122,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(content_file_paths, (IO, bytes)):
@@ -144,17 +149,16 @@
             template_url=self._purge_content_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -251,16 +255,16 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param front_door_name: Name of the Front Door which is globally unique. Required.
         :type front_door_name: str
         :param content_file_paths: The path to the content to be purged. Path can be a full URL, e.g.
          '/pictures/city.png' which removes a single file, or a directory with a wildcard, e.g.
-         '/pictures/*' which removes all folders and files in the directory. Is either a PurgeParameters
-         type or a IO type. Required.
+         '/pictures/*' which removes all folders and files in the directory. Is either a model type or a
+         IO type. Required.
         :type content_file_paths: ~azure.mgmt.frontdoor.models.PurgeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -272,15 +276,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._purge_content_initial(  # type: ignore
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_front_door_name_availability_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,26 +24,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Network/checkFrontDoorNameAvailability")
 
     # Construct parameters
@@ -116,16 +121,16 @@
 
     @distributed_trace
     def check(
         self, check_front_door_name_availability_input: Union[_models.CheckNameAvailabilityInput, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityOutput:
         """Check the availability of a Front Door resource name.
 
-        :param check_front_door_name_availability_input: Input to check. Is either a
-         CheckNameAvailabilityInput type or a IO type. Required.
+        :param check_front_door_name_availability_input: Input to check. Is either a model type or a IO
+         type. Required.
         :type check_front_door_name_availability_input:
          ~azure.mgmt.frontdoor.models.CheckNameAvailabilityInput or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityOutput or the result of cls(response)
@@ -139,15 +144,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameAvailabilityOutput] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(check_front_door_name_availability_input, (IO, bytes)):
@@ -163,17 +168,16 @@
             template_url=self.check.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_managed_rule_sets_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,26 +25,30 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+    api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Network/FrontDoorWebApplicationFirewallManagedRuleSets",
     )  # pylint: disable=line-too-long
@@ -90,15 +95,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.ManagedRuleSetDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
+        api_version: Literal["2022-05-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01"))
         cls: ClsType[_models.ManagedRuleSetDefinitionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -131,17 +136,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_experiments_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_experiments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,28 +27,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_profile_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments",
     )  # pylint: disable=line-too-long
@@ -77,15 +82,15 @@
 
 def build_get_request(
     resource_group_name: str, profile_name: str, experiment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
     )  # pylint: disable=line-too-long
@@ -118,15 +123,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, profile_name: str, experiment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
@@ -162,15 +167,15 @@
 
 def build_update_request(
     resource_group_name: str, profile_name: str, experiment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
@@ -206,15 +211,15 @@
 
 def build_delete_request(
     resource_group_name: str, profile_name: str, experiment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}/Experiments/{experimentName}",
     )  # pylint: disable=line-too-long
@@ -280,15 +285,15 @@
         :return: An iterator like instance of either Experiment or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ExperimentList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -323,17 +328,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -372,15 +376,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -388,17 +392,16 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -430,15 +433,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -458,17 +461,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -585,15 +587,15 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param experiment_name: The Experiment identifier associated with the Experiment. Required.
         :type experiment_name: str
-        :param parameters: The Experiment resource. Is either a Experiment type or a IO type. Required.
+        :param parameters: The Experiment resource. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.Experiment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -605,15 +607,15 @@
         :return: An instance of LROPoller that returns either Experiment or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -670,15 +672,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -698,17 +700,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -822,16 +823,15 @@
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param experiment_name: The Experiment identifier associated with the Experiment. Required.
         :type experiment_name: str
-        :param parameters: The Experiment Update Model. Is either a ExperimentUpdateModel type or a IO
-         type. Required.
+        :param parameters: The Experiment Update Model. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.ExperimentUpdateModel or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -843,15 +843,15 @@
         :return: An instance of LROPoller that returns either Experiment or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.Experiment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Experiment] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -903,15 +903,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             experiment_name=experiment_name,
             subscription_id=self._config.subscription_id,
@@ -919,17 +919,16 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -967,15 +966,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/operations/_network_experiment_profiles_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,26 +27,30 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Network/NetworkExperimentProfiles"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -63,15 +68,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles",
     )  # pylint: disable=line-too-long
@@ -98,15 +103,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
     )  # pylint: disable=line-too-long
@@ -136,15 +141,15 @@
 
 def build_create_or_update_request(
     profile_name: str, resource_group_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
@@ -177,15 +182,15 @@
 
 def build_update_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
@@ -218,15 +223,15 @@
 
 def build_delete_request(
     resource_group_name: str, profile_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+    api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/NetworkExperimentProfiles/{profileName}",
     )  # pylint: disable=line-too-long
@@ -283,15 +288,15 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ProfileList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -324,17 +329,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -357,15 +361,15 @@
         :return: An iterator like instance of either Profile or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.ProfileList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -399,17 +403,16 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -444,32 +447,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -496,15 +498,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -523,17 +525,16 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -637,15 +638,15 @@
 
         Creates an NetworkExperiment Profile.
 
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
-        :param parameters: An Network Experiment Profile. Is either a Profile type or a IO type.
+        :param parameters: An Network Experiment Profile. Is either a model type or a IO type.
          Required.
         :type parameters: ~azure.mgmt.frontdoor.models.Profile or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -658,15 +659,15 @@
         :return: An instance of LROPoller that returns either Profile or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -721,15 +722,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
@@ -748,17 +749,16 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -863,16 +863,15 @@
 
         Updates an NetworkExperimentProfiles.
 
         :param resource_group_name: Name of the Resource group within the Azure subscription. Required.
         :type resource_group_name: str
         :param profile_name: The Profile identifier associated with the Tenant and Partner. Required.
         :type profile_name: str
-        :param parameters: The Profile Update Model. Is either a ProfileUpdateModel type or a IO type.
-         Required.
+        :param parameters: The Profile Update Model. Is either a model type or a IO type. Required.
         :type parameters: ~azure.mgmt.frontdoor.models.ProfileUpdateModel or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -884,15 +883,15 @@
         :return: An instance of LROPoller that returns either Profile or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.frontdoor.models.Profile]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Profile] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -943,32 +942,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             profile_name=profile_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1002,15 +1000,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
+        api_version: Literal["2019-11-01"] = kwargs.pop("api_version", _params.pop("api-version", "2019-11-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_models_py3.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_models_py3.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,30 +4,25 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
-from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
+from typing import Dict, List, Optional, TYPE_CHECKING, Union
 
 from .. import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
 
 class AzureAsyncOperationResult(_serialization.Model):
-    """The response body contains the status of the specified asynchronous operation, indicating
-    whether it has succeeded, is in progress, or has failed. Note that this status is distinct from
-    the HTTP status code returned for the Get Operation Status operation itself. If the
-    asynchronous operation succeeded, the response body includes the HTTP status code for the
-    successful request. If the asynchronous operation failed, the response body includes the HTTP
-    status code for the failed request and error information regarding the failure.
+    """The response body contains the status of the specified asynchronous operation, indicating whether it has succeeded, is in progress, or has failed. Note that this status is distinct from the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous operation succeeded, the response body includes the HTTP status code for the successful request. If the asynchronous operation failed, the response body includes the HTTP status code for the failed request and error information regarding the failure.
 
     :ivar status: Status of the Azure async operation. Known values are: "InProgress", "Succeeded",
      and "Failed".
     :vartype status: str or ~azure.mgmt.frontdoor.models.NetworkOperationStatus
     :ivar error:
     :vartype error: ~azure.mgmt.frontdoor.models.Error
     """
@@ -38,16 +33,16 @@
     }
 
     def __init__(
         self,
         *,
         status: Optional[Union[str, "_models.NetworkOperationStatus"]] = None,
         error: Optional["_models.Error"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword status: Status of the Azure async operation. Known values are: "InProgress",
          "Succeeded", and "Failed".
         :paramtype status: str or ~azure.mgmt.frontdoor.models.NetworkOperationStatus
         :keyword error:
         :paramtype error: ~azure.mgmt.frontdoor.models.Error
         """
@@ -128,16 +123,16 @@
         private_link_approval_message: Optional[str] = None,
         http_port: Optional[int] = None,
         https_port: Optional[int] = None,
         enabled_state: Optional[Union[str, "_models.BackendEnabledState"]] = None,
         priority: Optional[int] = None,
         weight: Optional[int] = None,
         backend_host_header: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword address: Location of the backend (IP address or FQDN).
         :paramtype address: str
         :keyword private_link_alias: The Alias of the Private Link resource. Populating this optional
          field indicates that this backend is 'Private'.
         :paramtype private_link_alias: str
         :keyword private_link_resource_id: The Resource Id of the Private Link resource. Populating
@@ -187,15 +182,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -241,16 +236,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         backends: Optional[List["_models.Backend"]] = None,
         load_balancing_settings: Optional["_models.SubResource"] = None,
         health_probe_settings: Optional["_models.SubResource"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Resource ID.
         :paramtype id: str
         :keyword name: Resource name.
         :paramtype name: str
         :keyword backends: The set of backends for this pool.
         :paramtype backends: list[~azure.mgmt.frontdoor.models.Backend]
@@ -265,16 +260,15 @@
         self.backends = backends
         self.load_balancing_settings = load_balancing_settings
         self.health_probe_settings = health_probe_settings
         self.resource_state = None
 
 
 class BackendPoolListResult(_serialization.Model):
-    """Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a
-    URL link to get the next set of results.
+    """Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Backend Pools within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.BackendPool]
     :ivar next_link: URL to get the next set of BackendPool objects if there are any.
     :vartype next_link: str
@@ -285,15 +279,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[BackendPool]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of BackendPool objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -318,16 +312,16 @@
 
     def __init__(
         self,
         *,
         backends: Optional[List["_models.Backend"]] = None,
         load_balancing_settings: Optional["_models.SubResource"] = None,
         health_probe_settings: Optional["_models.SubResource"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword backends: The set of backends for this pool.
         :paramtype backends: list[~azure.mgmt.frontdoor.models.Backend]
         :keyword load_balancing_settings: Load balancing settings for a backend pool.
         :paramtype load_balancing_settings: ~azure.mgmt.frontdoor.models.SubResource
         :keyword health_probe_settings: L7 health probe settings for a backend pool.
         :paramtype health_probe_settings: ~azure.mgmt.frontdoor.models.SubResource
@@ -367,16 +361,16 @@
 
     def __init__(
         self,
         *,
         backends: Optional[List["_models.Backend"]] = None,
         load_balancing_settings: Optional["_models.SubResource"] = None,
         health_probe_settings: Optional["_models.SubResource"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword backends: The set of backends for this pool.
         :paramtype backends: list[~azure.mgmt.frontdoor.models.Backend]
         :keyword load_balancing_settings: Load balancing settings for a backend pool.
         :paramtype load_balancing_settings: ~azure.mgmt.frontdoor.models.SubResource
         :keyword health_probe_settings: L7 health probe settings for a backend pool.
         :paramtype health_probe_settings: ~azure.mgmt.frontdoor.models.SubResource
@@ -413,16 +407,16 @@
     }
 
     def __init__(
         self,
         *,
         enforce_certificate_name_check: Union[str, "_models.EnforceCertificateNameCheckEnabledState"] = "Enabled",
         send_recv_timeout_seconds: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword enforce_certificate_name_check: Whether to enforce certificate name check on HTTPS
          requests to all backend pools. No effect on non-HTTPS requests. Known values are: "Enabled" and
          "Disabled".
         :paramtype enforce_certificate_name_check: str or
          ~azure.mgmt.frontdoor.models.EnforceCertificateNameCheckEnabledState
         :keyword send_recv_timeout_seconds: Send and receive timeout on forwarding request to the
@@ -431,16 +425,15 @@
         """
         super().__init__(**kwargs)
         self.enforce_certificate_name_check = enforce_certificate_name_check
         self.send_recv_timeout_seconds = send_recv_timeout_seconds
 
 
 class CacheConfiguration(_serialization.Model):
-    """Caching settings for a caching-type route. To disable caching, do not provide a
-    cacheConfiguration object.
+    """Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
 
     :ivar query_parameter_strip_directive: Treatment of URL query terms when forming the cache key.
      Known values are: "StripNone", "StripAll", "StripOnly", and "StripAllExcept".
     :vartype query_parameter_strip_directive: str or ~azure.mgmt.frontdoor.models.FrontDoorQuery
     :ivar query_parameters: query parameters to include or exclude (comma separated).
     :vartype query_parameters: str
     :ivar dynamic_compression: Whether to use dynamic compression for cached content. Known values
@@ -462,16 +455,16 @@
     def __init__(
         self,
         *,
         query_parameter_strip_directive: Optional[Union[str, "_models.FrontDoorQuery"]] = None,
         query_parameters: Optional[str] = None,
         dynamic_compression: Optional[Union[str, "_models.DynamicCompressionEnabled"]] = None,
         cache_duration: Optional[datetime.timedelta] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword query_parameter_strip_directive: Treatment of URL query terms when forming the cache
          key. Known values are: "StripNone", "StripAll", "StripOnly", and "StripAllExcept".
         :paramtype query_parameter_strip_directive: str or ~azure.mgmt.frontdoor.models.FrontDoorQuery
         :keyword query_parameters: query parameters to include or exclude (comma separated).
         :paramtype query_parameters: str
         :keyword dynamic_compression: Whether to use dynamic compression for cached content. Known
@@ -507,15 +500,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: str, type: Union[str, "_models.ResourceType"], **kwargs: Any) -> None:
+    def __init__(self, *, name: str, type: Union[str, "_models.ResourceType"], **kwargs):
         """
         :keyword name: The resource name to validate. Required.
         :paramtype name: str
         :keyword type: The type of the resource whose name is to be validated. Required. Known values
          are: "Microsoft.Network/frontDoors" and "Microsoft.Network/frontDoors/frontendEndpoints".
         :paramtype type: str or ~azure.mgmt.frontdoor.models.ResourceType
         """
@@ -546,15 +539,15 @@
 
     _attribute_map = {
         "name_availability": {"key": "nameAvailability", "type": "str"},
         "reason": {"key": "reason", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.name_availability = None
         self.reason = None
         self.message = None
 
 
@@ -609,16 +602,16 @@
         certificate_source: Union[str, "_models.FrontDoorCertificateSource"],
         protocol_type: Union[str, "_models.FrontDoorTlsProtocolType"],
         minimum_tls_version: Union[str, "_models.MinimumTLSVersion"],
         certificate_type: Optional[Union[str, "_models.FrontDoorCertificateType"]] = None,
         vault: Optional["_models.KeyVaultCertificateSourceParametersVault"] = None,
         secret_name: Optional[str] = None,
         secret_version: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword certificate_source: Defines the source of the SSL certificate. Required. Known values
          are: "AzureKeyVault" and "FrontDoor".
         :paramtype certificate_source: str or ~azure.mgmt.frontdoor.models.FrontDoorCertificateSource
         :keyword protocol_type: Defines the TLS extension protocol that is used for secure delivery.
          Required. "ServerNameIndication"
         :paramtype protocol_type: str or ~azure.mgmt.frontdoor.models.FrontDoorTlsProtocolType
@@ -666,15 +659,15 @@
      is 1 minute.
     :vartype rate_limit_duration_in_minutes: int
     :ivar rate_limit_threshold: Number of allowed requests per client within the time window.
     :vartype rate_limit_threshold: int
     :ivar match_conditions: List of match conditions. Required.
     :vartype match_conditions: list[~azure.mgmt.frontdoor.models.MatchCondition]
     :ivar action: Describes what action to be applied when rule matches. Required. Known values
-     are: "Allow", "Block", "Log", "Redirect", and "AnomalyScoring".
+     are: "Allow", "Block", "Log", and "Redirect".
     :vartype action: str or ~azure.mgmt.frontdoor.models.ActionType
     """
 
     _validation = {
         "name": {"max_length": 128},
         "priority": {"required": True},
         "rule_type": {"required": True},
@@ -702,16 +695,16 @@
         rule_type: Union[str, "_models.RuleType"],
         match_conditions: List["_models.MatchCondition"],
         action: Union[str, "_models.ActionType"],
         name: Optional[str] = None,
         enabled_state: Optional[Union[str, "_models.CustomRuleEnabledState"]] = None,
         rate_limit_duration_in_minutes: Optional[int] = None,
         rate_limit_threshold: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword name: Describes the name of the rule.
         :paramtype name: str
         :keyword priority: Describes priority of the rule. Rules with a lower value will be evaluated
          before rules with a higher value. Required.
         :paramtype priority: int
         :keyword enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults
@@ -724,15 +717,15 @@
          Default is 1 minute.
         :paramtype rate_limit_duration_in_minutes: int
         :keyword rate_limit_threshold: Number of allowed requests per client within the time window.
         :paramtype rate_limit_threshold: int
         :keyword match_conditions: List of match conditions. Required.
         :paramtype match_conditions: list[~azure.mgmt.frontdoor.models.MatchCondition]
         :keyword action: Describes what action to be applied when rule matches. Required. Known values
-         are: "Allow", "Block", "Log", "Redirect", and "AnomalyScoring".
+         are: "Allow", "Block", "Log", and "Redirect".
         :paramtype action: str or ~azure.mgmt.frontdoor.models.ActionType
         """
         super().__init__(**kwargs)
         self.name = name
         self.priority = priority
         self.enabled_state = enabled_state
         self.rule_type = rule_type
@@ -749,87 +742,38 @@
     :vartype rules: list[~azure.mgmt.frontdoor.models.CustomRule]
     """
 
     _attribute_map = {
         "rules": {"key": "rules", "type": "[CustomRule]"},
     }
 
-    def __init__(self, *, rules: Optional[List["_models.CustomRule"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, rules: Optional[List["_models.CustomRule"]] = None, **kwargs):
         """
         :keyword rules: List of rules.
         :paramtype rules: list[~azure.mgmt.frontdoor.models.CustomRule]
         """
         super().__init__(**kwargs)
         self.rules = rules
 
 
-class DefaultErrorResponse(_serialization.Model):
-    """Error response indicates Front Door service is not able to process the incoming request. The
-    reason is provided in the error message.
-
-    :ivar error: Error model.
-    :vartype error: ~azure.mgmt.frontdoor.models.DefaultErrorResponseError
-    """
-
-    _attribute_map = {
-        "error": {"key": "error", "type": "DefaultErrorResponseError"},
-    }
-
-    def __init__(self, *, error: Optional["_models.DefaultErrorResponseError"] = None, **kwargs: Any) -> None:
-        """
-        :keyword error: Error model.
-        :paramtype error: ~azure.mgmt.frontdoor.models.DefaultErrorResponseError
-        """
-        super().__init__(**kwargs)
-        self.error = error
-
-
-class DefaultErrorResponseError(_serialization.Model):
-    """Error model.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar code: Error code.
-    :vartype code: str
-    :ivar message: Error message indicating why the operation failed.
-    :vartype message: str
-    """
-
-    _validation = {
-        "code": {"readonly": True},
-        "message": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "code": {"key": "code", "type": "str"},
-        "message": {"key": "message", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.code = None
-        self.message = None
-
-
 class Endpoint(_serialization.Model):
     """Defines the endpoint properties.
 
     :ivar name: The name of the endpoint.
     :vartype name: str
     :ivar endpoint: The endpoint URL.
     :vartype endpoint: str
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "endpoint": {"key": "endpoint", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, endpoint: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, name: Optional[str] = None, endpoint: Optional[str] = None, **kwargs):
         """
         :keyword name: The name of the endpoint.
         :paramtype name: str
         :keyword endpoint: The endpoint URL.
         :paramtype endpoint: str
         """
         super().__init__(**kwargs)
@@ -864,16 +808,16 @@
         self,
         *,
         code: Optional[str] = None,
         message: Optional[str] = None,
         target: Optional[str] = None,
         details: Optional[List["_models.ErrorDetails"]] = None,
         inner_error: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword code:
         :paramtype code: str
         :keyword message:
         :paramtype message: str
         :keyword target:
         :paramtype target: str
@@ -904,16 +848,16 @@
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "target": {"key": "target", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
     def __init__(
-        self, *, code: Optional[str] = None, target: Optional[str] = None, message: Optional[str] = None, **kwargs: Any
-    ) -> None:
+        self, *, code: Optional[str] = None, target: Optional[str] = None, message: Optional[str] = None, **kwargs
+    ):
         """
         :keyword code:
         :paramtype code: str
         :keyword target:
         :paramtype target: str
         :keyword message:
         :paramtype message: str
@@ -921,16 +865,15 @@
         super().__init__(**kwargs)
         self.code = code
         self.target = target
         self.message = message
 
 
 class ErrorResponse(_serialization.Model):
-    """Error response indicates Front Door service is not able to process the incoming request. The
-    reason is provided in the error message.
+    """Error response indicates Front Door service is not able to process the incoming request. The reason is provided in the error message.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar code: Error code.
     :vartype code: str
     :ivar message: Error message indicating why the operation failed.
     :vartype message: str
@@ -942,15 +885,15 @@
     }
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
 
 
 class Resource(_serialization.Model):
@@ -980,15 +923,15 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, location: Optional[str] = None, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, location: Optional[str] = None, tags: Optional[Dict[str, str]] = None, **kwargs):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
@@ -1060,16 +1003,16 @@
         *,
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         endpoint_a: Optional["_models.Endpoint"] = None,
         endpoint_b: Optional["_models.Endpoint"] = None,
         enabled_state: Optional[Union[str, "_models.State"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword description: The description of the details or intents of the Experiment.
         :paramtype description: str
@@ -1088,16 +1031,15 @@
         self.enabled_state = enabled_state
         self.resource_state = None
         self.status = None
         self.script_file_uri = None
 
 
 class ExperimentList(_serialization.Model):
-    """Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get
-    the next set of results.
+    """Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Experiments within a resource group.
     :vartype value: list[~azure.mgmt.frontdoor.models.Experiment]
     :ivar next_link: URL to get the next set of Experiment objects if there are any.
     :vartype next_link: str
@@ -1108,15 +1050,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Experiment]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of Experiment objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -1141,16 +1083,16 @@
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         enabled_state: Optional[Union[str, "_models.State"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword description: The description of the intent or details of the Experiment.
         :paramtype description: str
         :keyword enabled_state: The state of the Experiment. Known values are: "Enabled" and
          "Disabled".
@@ -1185,15 +1127,15 @@
     _subtype_map = {
         "odata_type": {
             "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration": "ForwardingConfiguration",
             "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration": "RedirectConfiguration",
         }
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.odata_type: Optional[str] = None
 
 
 class ForwardingConfiguration(RouteConfiguration):
     """Describes Forwarding Route.
@@ -1229,16 +1171,16 @@
     def __init__(
         self,
         *,
         custom_forwarding_path: Optional[str] = None,
         forwarding_protocol: Optional[Union[str, "_models.FrontDoorForwardingProtocol"]] = None,
         cache_configuration: Optional["_models.CacheConfiguration"] = None,
         backend_pool: Optional["_models.SubResource"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword custom_forwarding_path: A custom path used to rewrite resource paths matched by this
          rule. Leave empty to use incoming path.
         :paramtype custom_forwarding_path: str
         :keyword forwarding_protocol: Protocol this rule will use when forwarding traffic to backends.
          Known values are: "HttpOnly", "HttpsOnly", and "MatchRequest".
         :paramtype forwarding_protocol: str or ~azure.mgmt.frontdoor.models.FrontDoorForwardingProtocol
@@ -1252,16 +1194,15 @@
         self.custom_forwarding_path = custom_forwarding_path
         self.forwarding_protocol = forwarding_protocol
         self.cache_configuration = cache_configuration
         self.backend_pool = backend_pool
 
 
 class FrontDoor(Resource):  # pylint: disable=too-many-instance-attributes
-    """Front Door represents a collection of backend endpoints to route traffic to along with rules
-    that specify how traffic is sent there.
+    """Front Door represents a collection of backend endpoints to route traffic to along with rules that specify how traffic is sent there.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Resource ID.
     :vartype id: str
     :ivar name: Resource name.
     :vartype name: str
@@ -1347,16 +1288,16 @@
         routing_rules: Optional[List["_models.RoutingRule"]] = None,
         load_balancing_settings: Optional[List["_models.LoadBalancingSettingsModel"]] = None,
         health_probe_settings: Optional[List["_models.HealthProbeSettingsModel"]] = None,
         backend_pools: Optional[List["_models.BackendPool"]] = None,
         frontend_endpoints: Optional[List["_models.FrontendEndpoint"]] = None,
         backend_pools_settings: Optional["_models.BackendPoolsSettings"] = None,
         enabled_state: Optional[Union[str, "_models.FrontDoorEnabledState"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword friendly_name: A friendly name for the frontDoor.
         :paramtype friendly_name: str
@@ -1392,16 +1333,15 @@
         self.cname = None
         self.frontdoor_id = None
         self.rules_engines = None
         self.extended_properties = None
 
 
 class FrontDoorListResult(_serialization.Model):
-    """Result of the request to list Front Doors. It contains a list of Front Door objects and a URL
-    link to get the next set of results.
+    """Result of the request to list Front Doors. It contains a list of Front Door objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Front Doors within a resource group.
     :vartype value: list[~azure.mgmt.frontdoor.models.FrontDoor]
     :ivar next_link: URL to get the next set of Front Door objects if there are any.
     :vartype next_link: str
@@ -1412,15 +1352,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[FrontDoor]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of Front Door objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -1467,16 +1407,16 @@
         routing_rules: Optional[List["_models.RoutingRule"]] = None,
         load_balancing_settings: Optional[List["_models.LoadBalancingSettingsModel"]] = None,
         health_probe_settings: Optional[List["_models.HealthProbeSettingsModel"]] = None,
         backend_pools: Optional[List["_models.BackendPool"]] = None,
         frontend_endpoints: Optional[List["_models.FrontendEndpoint"]] = None,
         backend_pools_settings: Optional["_models.BackendPoolsSettings"] = None,
         enabled_state: Optional[Union[str, "_models.FrontDoorEnabledState"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword friendly_name: A friendly name for the frontDoor.
         :paramtype friendly_name: str
         :keyword routing_rules: Routing rules associated with this Front Door.
         :paramtype routing_rules: list[~azure.mgmt.frontdoor.models.RoutingRule]
         :keyword load_balancing_settings: Load balancing settings associated with this Front Door
          instance.
@@ -1576,16 +1516,16 @@
         routing_rules: Optional[List["_models.RoutingRule"]] = None,
         load_balancing_settings: Optional[List["_models.LoadBalancingSettingsModel"]] = None,
         health_probe_settings: Optional[List["_models.HealthProbeSettingsModel"]] = None,
         backend_pools: Optional[List["_models.BackendPool"]] = None,
         frontend_endpoints: Optional[List["_models.FrontendEndpoint"]] = None,
         backend_pools_settings: Optional["_models.BackendPoolsSettings"] = None,
         enabled_state: Optional[Union[str, "_models.FrontDoorEnabledState"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword friendly_name: A friendly name for the frontDoor.
         :paramtype friendly_name: str
         :keyword routing_rules: Routing rules associated with this Front Door.
         :paramtype routing_rules: list[~azure.mgmt.frontdoor.models.RoutingRule]
         :keyword load_balancing_settings: Load balancing settings associated with this Front Door
          instance.
@@ -1701,16 +1641,16 @@
         name: Optional[str] = None,
         host_name: Optional[str] = None,
         session_affinity_enabled_state: Optional[Union[str, "_models.SessionAffinityEnabledState"]] = None,
         session_affinity_ttl_seconds: Optional[int] = None,
         web_application_firewall_policy_link: Optional[
             "_models.FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Resource ID.
         :paramtype id: str
         :keyword name: Resource name.
         :paramtype name: str
         :keyword host_name: The host name of the frontendEndpoint. Must be a domain name.
         :paramtype host_name: str
@@ -1746,15 +1686,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -1792,16 +1732,16 @@
         *,
         host_name: Optional[str] = None,
         session_affinity_enabled_state: Optional[Union[str, "_models.SessionAffinityEnabledState"]] = None,
         session_affinity_ttl_seconds: Optional[int] = None,
         web_application_firewall_policy_link: Optional[
             "_models.FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword host_name: The host name of the frontendEndpoint. Must be a domain name.
         :paramtype host_name: str
         :keyword session_affinity_enabled_state: Whether to allow session affinity on this host. Valid
          options are 'Enabled' or 'Disabled'. Known values are: "Enabled" and "Disabled".
         :paramtype session_affinity_enabled_state: str or
          ~azure.mgmt.frontdoor.models.SessionAffinityEnabledState
@@ -1884,16 +1824,16 @@
         *,
         host_name: Optional[str] = None,
         session_affinity_enabled_state: Optional[Union[str, "_models.SessionAffinityEnabledState"]] = None,
         session_affinity_ttl_seconds: Optional[int] = None,
         web_application_firewall_policy_link: Optional[
             "_models.FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword host_name: The host name of the frontendEndpoint. Must be a domain name.
         :paramtype host_name: str
         :keyword session_affinity_enabled_state: Whether to allow session affinity on this host. Valid
          options are 'Enabled' or 'Disabled'. Known values are: "Enabled" and "Disabled".
         :paramtype session_affinity_enabled_state: str or
          ~azure.mgmt.frontdoor.models.SessionAffinityEnabledState
@@ -1915,16 +1855,15 @@
         self.resource_state = None
         self.custom_https_provisioning_state = None
         self.custom_https_provisioning_substate = None
         self.custom_https_configuration = None
 
 
 class FrontendEndpointsListResult(_serialization.Model):
-    """Result of the request to list frontend endpoints. It contains a list of Frontend endpoint
-    objects and a URL link to get the next set of results.
+    """Result of the request to list frontend endpoints. It contains a list of Frontend endpoint objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Frontend endpoints within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.FrontendEndpoint]
     :ivar next_link: URL to get the next set of frontend endpoints if there are any.
     :vartype next_link: str
@@ -1935,15 +1874,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[FrontendEndpoint]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of frontend endpoints if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -1956,15 +1895,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -1997,16 +1936,16 @@
 
     def __init__(
         self,
         *,
         header_action_type: Union[str, "_models.HeaderActionType"],
         header_name: str,
         value: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword header_action_type: Which type of manipulation to apply to the header. Required. Known
          values are: "Append", "Delete", and "Overwrite".
         :paramtype header_action_type: str or ~azure.mgmt.frontdoor.models.HeaderActionType
         :keyword header_name: The name of the header this action will apply to. Required.
         :paramtype header_name: str
         :keyword value: The value to update the given header name with. This value is not used if the
@@ -2016,16 +1955,15 @@
         super().__init__(**kwargs)
         self.header_action_type = header_action_type
         self.header_name = header_name
         self.value = value
 
 
 class HealthProbeSettingsListResult(_serialization.Model):
-    """Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings
-    objects and a URL link to get the next set of results.
+    """Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of HealthProbeSettings within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.HealthProbeSettingsModel]
     :ivar next_link: URL to get the next set of HealthProbeSettings objects if there are any.
     :vartype next_link: str
@@ -2036,15 +1974,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[HealthProbeSettingsModel]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of HealthProbeSettings objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -2102,16 +2040,16 @@
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         path: Optional[str] = None,
         protocol: Optional[Union[str, "_models.FrontDoorProtocol"]] = None,
         interval_in_seconds: Optional[int] = None,
         health_probe_method: Union[str, "_models.FrontDoorHealthProbeMethod"] = "HEAD",
         enabled_state: Optional[Union[str, "_models.HealthProbeEnabled"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Resource ID.
         :paramtype id: str
         :keyword name: Resource name.
         :paramtype name: str
         :keyword path: The path to use for the health probe. Default is /.
         :paramtype path: str
@@ -2168,16 +2106,16 @@
         self,
         *,
         path: Optional[str] = None,
         protocol: Optional[Union[str, "_models.FrontDoorProtocol"]] = None,
         interval_in_seconds: Optional[int] = None,
         health_probe_method: Union[str, "_models.FrontDoorHealthProbeMethod"] = "HEAD",
         enabled_state: Optional[Union[str, "_models.HealthProbeEnabled"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword path: The path to use for the health probe. Default is /.
         :paramtype path: str
         :keyword protocol: Protocol scheme to use for this probe. Known values are: "Http" and "Https".
         :paramtype protocol: str or ~azure.mgmt.frontdoor.models.FrontDoorProtocol
         :keyword interval_in_seconds: The number of seconds between health probes.
         :paramtype interval_in_seconds: int
@@ -2237,16 +2175,16 @@
         self,
         *,
         path: Optional[str] = None,
         protocol: Optional[Union[str, "_models.FrontDoorProtocol"]] = None,
         interval_in_seconds: Optional[int] = None,
         health_probe_method: Union[str, "_models.FrontDoorHealthProbeMethod"] = "HEAD",
         enabled_state: Optional[Union[str, "_models.HealthProbeEnabled"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword path: The path to use for the health probe. Default is /.
         :paramtype path: str
         :keyword protocol: Protocol scheme to use for this probe. Known values are: "Http" and "Https".
         :paramtype protocol: str or ~azure.mgmt.frontdoor.models.FrontDoorProtocol
         :keyword interval_in_seconds: The number of seconds between health probes.
         :paramtype interval_in_seconds: int
@@ -2276,15 +2214,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -2338,15 +2276,15 @@
         "delta_percent": {"key": "deltaPercent", "type": "float"},
         "a_c_lower95_ci": {"key": "aCLower95CI", "type": "float"},
         "a_h_upper95_ci": {"key": "aHUpper95CI", "type": "float"},
         "b_c_lower95_ci": {"key": "bCLower95CI", "type": "float"},
         "b_upper95_ci": {"key": "bUpper95CI", "type": "float"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.name = None
         self.end_date_time_utc = None
         self.a_value = None
         self.b_value = None
         self.delta = None
@@ -2426,16 +2364,16 @@
 
     def __init__(
         self,
         *,
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         latency_metrics: Optional[List["_models.LatencyMetric"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword latency_metrics: The latency metrics of the Latency Scorecard.
         :paramtype latency_metrics: list[~azure.mgmt.frontdoor.models.LatencyMetric]
@@ -2449,16 +2387,15 @@
         self.start_date_time_utc = None
         self.end_date_time_utc = None
         self.country = None
         self.latency_metrics = latency_metrics
 
 
 class LoadBalancingSettingsListResult(_serialization.Model):
-    """Result of the request to list load balancing settings. It contains a list of load balancing
-    settings objects and a URL link to get the next set of results.
+    """Result of the request to list load balancing settings. It contains a list of load balancing settings objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Backend Pools within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.LoadBalancingSettingsModel]
     :ivar next_link: URL to get the next set of LoadBalancingSettings objects if there are any.
     :vartype next_link: str
@@ -2469,15 +2406,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[LoadBalancingSettingsModel]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of LoadBalancingSettings objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -2526,16 +2463,16 @@
         self,
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         sample_size: Optional[int] = None,
         successful_samples_required: Optional[int] = None,
         additional_latency_milliseconds: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Resource ID.
         :paramtype id: str
         :keyword name: Resource name.
         :paramtype name: str
         :keyword sample_size: The number of samples to consider for load balancing decisions.
         :paramtype sample_size: int
@@ -2576,16 +2513,16 @@
 
     def __init__(
         self,
         *,
         sample_size: Optional[int] = None,
         successful_samples_required: Optional[int] = None,
         additional_latency_milliseconds: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword sample_size: The number of samples to consider for load balancing decisions.
         :paramtype sample_size: int
         :keyword successful_samples_required: The number of samples within the sample period that must
          succeed.
         :paramtype successful_samples_required: int
         :keyword additional_latency_milliseconds: The additional latency in milliseconds for probes to
@@ -2629,16 +2566,16 @@
 
     def __init__(
         self,
         *,
         sample_size: Optional[int] = None,
         successful_samples_required: Optional[int] = None,
         additional_latency_milliseconds: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword sample_size: The number of samples to consider for load balancing decisions.
         :paramtype sample_size: int
         :keyword successful_samples_required: The number of samples within the sample period that must
          succeed.
         :paramtype successful_samples_required: int
         :keyword additional_latency_milliseconds: The additional latency in milliseconds for probes to
@@ -2661,15 +2598,15 @@
 
     :ivar rule_id: Identifier for the managed rule.
     :vartype rule_id: str
     :ivar default_state: Describes the default state for the managed rule. Known values are:
      "Disabled" and "Enabled".
     :vartype default_state: str or ~azure.mgmt.frontdoor.models.ManagedRuleEnabledState
     :ivar default_action: Describes the default action to be applied when the managed rule matches.
-     Known values are: "Allow", "Block", "Log", "Redirect", and "AnomalyScoring".
+     Known values are: "Allow", "Block", "Log", and "Redirect".
     :vartype default_action: str or ~azure.mgmt.frontdoor.models.ActionType
     :ivar description: Describes the functionality of the managed rule.
     :vartype description: str
     """
 
     _validation = {
         "rule_id": {"readonly": True},
@@ -2681,15 +2618,15 @@
     _attribute_map = {
         "rule_id": {"key": "ruleId", "type": "str"},
         "default_state": {"key": "defaultState", "type": "str"},
         "default_action": {"key": "defaultAction", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.rule_id = None
         self.default_state = None
         self.default_action = None
         self.description = None
 
@@ -2727,16 +2664,16 @@
 
     def __init__(
         self,
         *,
         match_variable: Union[str, "_models.ManagedRuleExclusionMatchVariable"],
         selector_match_operator: Union[str, "_models.ManagedRuleExclusionSelectorMatchOperator"],
         selector: str,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword match_variable: The variable type to be excluded. Required. Known values are:
          "RequestHeaderNames", "RequestCookieNames", "QueryStringArgNames", "RequestBodyPostArgNames",
          and "RequestBodyJsonArgNames".
         :paramtype match_variable: str or
          ~azure.mgmt.frontdoor.models.ManagedRuleExclusionMatchVariable
         :keyword selector_match_operator: Comparison operator to apply to the selector when specifying
@@ -2775,15 +2712,15 @@
 
     _attribute_map = {
         "rule_group_name": {"key": "ruleGroupName", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "rules": {"key": "rules", "type": "[ManagedRuleDefinition]"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.rule_group_name = None
         self.description = None
         self.rules = None
 
 
@@ -2813,16 +2750,16 @@
 
     def __init__(
         self,
         *,
         rule_group_name: str,
         exclusions: Optional[List["_models.ManagedRuleExclusion"]] = None,
         rules: Optional[List["_models.ManagedRuleOverride"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword rule_group_name: Describes the managed rule group to override. Required.
         :paramtype rule_group_name: str
         :keyword exclusions: Describes the exclusions that are applied to all rules in the group.
         :paramtype exclusions: list[~azure.mgmt.frontdoor.models.ManagedRuleExclusion]
         :keyword rules: List of rules that will be disabled. If none specified, all rules in the group
          will be disabled.
@@ -2841,15 +2778,15 @@
 
     :ivar rule_id: Identifier for the managed rule. Required.
     :vartype rule_id: str
     :ivar enabled_state: Describes if the managed rule is in enabled or disabled state. Defaults to
      Disabled if not specified. Known values are: "Disabled" and "Enabled".
     :vartype enabled_state: str or ~azure.mgmt.frontdoor.models.ManagedRuleEnabledState
     :ivar action: Describes the override action to be applied when rule matches. Known values are:
-     "Allow", "Block", "Log", "Redirect", and "AnomalyScoring".
+     "Allow", "Block", "Log", and "Redirect".
     :vartype action: str or ~azure.mgmt.frontdoor.models.ActionType
     :ivar exclusions: Describes the exclusions that are applied to this specific rule.
     :vartype exclusions: list[~azure.mgmt.frontdoor.models.ManagedRuleExclusion]
     """
 
     _validation = {
         "rule_id": {"required": True},
@@ -2865,24 +2802,24 @@
     def __init__(
         self,
         *,
         rule_id: str,
         enabled_state: Optional[Union[str, "_models.ManagedRuleEnabledState"]] = None,
         action: Optional[Union[str, "_models.ActionType"]] = None,
         exclusions: Optional[List["_models.ManagedRuleExclusion"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword rule_id: Identifier for the managed rule. Required.
         :paramtype rule_id: str
         :keyword enabled_state: Describes if the managed rule is in enabled or disabled state. Defaults
          to Disabled if not specified. Known values are: "Disabled" and "Enabled".
         :paramtype enabled_state: str or ~azure.mgmt.frontdoor.models.ManagedRuleEnabledState
         :keyword action: Describes the override action to be applied when rule matches. Known values
-         are: "Allow", "Block", "Log", "Redirect", and "AnomalyScoring".
+         are: "Allow", "Block", "Log", and "Redirect".
         :paramtype action: str or ~azure.mgmt.frontdoor.models.ActionType
         :keyword exclusions: Describes the exclusions that are applied to this specific rule.
         :paramtype exclusions: list[~azure.mgmt.frontdoor.models.ManagedRuleExclusion]
         """
         super().__init__(**kwargs)
         self.rule_id = rule_id
         self.enabled_state = enabled_state
@@ -2925,16 +2862,16 @@
         self,
         *,
         rule_set_type: str,
         rule_set_version: str,
         rule_set_action: Optional[Union[str, "_models.ManagedRuleSetActionType"]] = None,
         exclusions: Optional[List["_models.ManagedRuleExclusion"]] = None,
         rule_group_overrides: Optional[List["_models.ManagedRuleGroupOverride"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword rule_set_type: Defines the rule set type to use. Required.
         :paramtype rule_set_type: str
         :keyword rule_set_version: Defines the version of the rule set to use. Required.
         :paramtype rule_set_version: str
         :keyword rule_set_action: Defines the rule set action. Known values are: "Block", "Log", and
          "Redirect".
@@ -2999,15 +2936,15 @@
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "rule_set_id": {"key": "properties.ruleSetId", "type": "str"},
         "rule_set_type": {"key": "properties.ruleSetType", "type": "str"},
         "rule_set_version": {"key": "properties.ruleSetVersion", "type": "str"},
         "rule_groups": {"key": "properties.ruleGroups", "type": "[ManagedRuleGroupDefinition]"},
     }
 
-    def __init__(self, *, location: Optional[str] = None, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, location: Optional[str] = None, tags: Optional[Dict[str, str]] = None, **kwargs):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(location=location, tags=tags, **kwargs)
@@ -3034,15 +2971,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ManagedRuleSetDefinition]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to retrieve next set of managed rule set definitions.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -3055,15 +2992,15 @@
     :vartype managed_rule_sets: list[~azure.mgmt.frontdoor.models.ManagedRuleSet]
     """
 
     _attribute_map = {
         "managed_rule_sets": {"key": "managedRuleSets", "type": "[ManagedRuleSet]"},
     }
 
-    def __init__(self, *, managed_rule_sets: Optional[List["_models.ManagedRuleSet"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, managed_rule_sets: Optional[List["_models.ManagedRuleSet"]] = None, **kwargs):
         """
         :keyword managed_rule_sets: List of rule sets.
         :paramtype managed_rule_sets: list[~azure.mgmt.frontdoor.models.ManagedRuleSet]
         """
         super().__init__(**kwargs)
         self.managed_rule_sets = managed_rule_sets
 
@@ -3112,16 +3049,16 @@
         *,
         match_variable: Union[str, "_models.MatchVariable"],
         operator: Union[str, "_models.Operator"],
         match_value: List[str],
         selector: Optional[str] = None,
         negate_condition: Optional[bool] = None,
         transforms: Optional[List[Union[str, "_models.TransformType"]]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword match_variable: Request variable to compare with. Required. Known values are:
          "RemoteAddr", "RequestMethod", "QueryString", "PostArgs", "RequestUri", "RequestHeader",
          "RequestBody", "Cookies", and "SocketAddr".
         :paramtype match_variable: str or ~azure.mgmt.frontdoor.models.MatchVariable
         :keyword selector: Match against a specific key from the QueryString, PostArgs, RequestHeader
          or Cookies variables. Default is null.
@@ -3189,16 +3126,16 @@
         *,
         enabled_state: Optional[Union[str, "_models.PolicyEnabledState"]] = None,
         mode: Optional[Union[str, "_models.PolicyMode"]] = None,
         redirect_url: Optional[str] = None,
         custom_block_response_status_code: Optional[int] = None,
         custom_block_response_body: Optional[str] = None,
         request_body_check: Optional[Union[str, "_models.PolicyRequestBodyCheck"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword enabled_state: Describes if the policy is in enabled or disabled state. Defaults to
          Enabled if not specified. Known values are: "Disabled" and "Enabled".
         :paramtype enabled_state: str or ~azure.mgmt.frontdoor.models.PolicyEnabledState
         :keyword mode: Describes if it is in detection mode or prevention mode at policy level. Known
          values are: "Prevention" and "Detection".
         :paramtype mode: str or ~azure.mgmt.frontdoor.models.PolicyMode
@@ -3273,16 +3210,16 @@
         *,
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         description: Optional[str] = None,
         endpoint: Optional[str] = None,
         endpoint_type: Optional[Union[str, "_models.EndpointType"]] = None,
         backend: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword description: The description of the endpoint.
         :paramtype description: str
@@ -3317,15 +3254,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PreconfiguredEndpoint]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of PreconfiguredEndpoints if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -3376,16 +3313,16 @@
     def __init__(
         self,
         *,
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         etag: Optional[str] = None,
         enabled_state: Optional[Union[str, "_models.State"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword etag: Gets a unique read-only string that changes whenever the resource is updated.
         :paramtype etag: str
@@ -3396,16 +3333,15 @@
         super().__init__(location=location, tags=tags, **kwargs)
         self.etag = etag
         self.resource_state = None
         self.enabled_state = enabled_state
 
 
 class ProfileList(_serialization.Model):
-    """Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the
-    next set of results.
+    """Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Profiles within a resource group.
     :vartype value: list[~azure.mgmt.frontdoor.models.Profile]
     :ivar next_link: URL to get the next set of Profile objects if there are any.
     :vartype next_link: str
@@ -3416,15 +3352,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Profile]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of Profile objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -3446,16 +3382,16 @@
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         enabled_state: Optional[Union[str, "_models.State"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword enabled_state: The enabled state of the Profile. Known values are: "Enabled" and
          "Disabled".
         :paramtype enabled_state: str or ~azure.mgmt.frontdoor.models.State
         """
@@ -3478,15 +3414,15 @@
         "content_paths": {"required": True},
     }
 
     _attribute_map = {
         "content_paths": {"key": "contentPaths", "type": "[str]"},
     }
 
-    def __init__(self, *, content_paths: List[str], **kwargs: Any) -> None:
+    def __init__(self, *, content_paths: List[str], **kwargs):
         """
         :keyword content_paths: The path to the content to be purged. Can describe a file path or a
          wild card directory. Required.
         :paramtype content_paths: list[str]
         """
         super().__init__(**kwargs)
         self.content_paths = content_paths
@@ -3541,16 +3477,16 @@
         *,
         redirect_type: Optional[Union[str, "_models.FrontDoorRedirectType"]] = None,
         redirect_protocol: Optional[Union[str, "_models.FrontDoorRedirectProtocol"]] = None,
         custom_host: Optional[str] = None,
         custom_path: Optional[str] = None,
         custom_fragment: Optional[str] = None,
         custom_query_string: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword redirect_type: The redirect type the rule will use when redirecting traffic. Known
          values are: "Moved", "Found", "TemporaryRedirect", and "PermanentRedirect".
         :paramtype redirect_type: str or ~azure.mgmt.frontdoor.models.FrontDoorRedirectType
         :keyword redirect_protocol: The protocol of the destination to where the traffic is redirected.
          Known values are: "HttpOnly", "HttpsOnly", and "MatchRequest".
         :paramtype redirect_protocol: str or ~azure.mgmt.frontdoor.models.FrontDoorRedirectProtocol
@@ -3577,16 +3513,15 @@
         self.custom_host = custom_host
         self.custom_path = custom_path
         self.custom_fragment = custom_fragment
         self.custom_query_string = custom_query_string
 
 
 class RoutingRule(SubResource):  # pylint: disable=too-many-instance-attributes
-    """A routing rule represents a specification for traffic to treat and where to send it, along with
-    health probe information.
+    """A routing rule represents a specification for traffic to treat and where to send it, along with health probe information.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Resource ID.
     :vartype id: str
     :ivar name: Resource name.
     :vartype name: str
@@ -3647,16 +3582,16 @@
         patterns_to_match: Optional[List[str]] = None,
         enabled_state: Optional[Union[str, "_models.RoutingRuleEnabledState"]] = None,
         route_configuration: Optional["_models.RouteConfiguration"] = None,
         rules_engine: Optional["_models.SubResource"] = None,
         web_application_firewall_policy_link: Optional[
             "_models.RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword id: Resource ID.
         :paramtype id: str
         :keyword name: Resource name.
         :paramtype name: str
         :keyword frontend_endpoints: Frontend endpoints associated with this rule.
         :paramtype frontend_endpoints: list[~azure.mgmt.frontdoor.models.SubResource]
@@ -3697,26 +3632,25 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
 
 class RoutingRuleListResult(_serialization.Model):
-    """Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a
-    URL link to get the next set of results.
+    """Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of Routing Rules within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.RoutingRule]
     :ivar next_link: URL to get the next set of RoutingRule objects if there are any.
     :vartype next_link: str
@@ -3727,15 +3661,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RoutingRule]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of RoutingRule objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -3785,16 +3719,16 @@
         patterns_to_match: Optional[List[str]] = None,
         enabled_state: Optional[Union[str, "_models.RoutingRuleEnabledState"]] = None,
         route_configuration: Optional["_models.RouteConfiguration"] = None,
         rules_engine: Optional["_models.SubResource"] = None,
         web_application_firewall_policy_link: Optional[
             "_models.RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword frontend_endpoints: Frontend endpoints associated with this rule.
         :paramtype frontend_endpoints: list[~azure.mgmt.frontdoor.models.SubResource]
         :keyword accepted_protocols: Protocol schemes to match for this rule.
         :paramtype accepted_protocols: list[str or ~azure.mgmt.frontdoor.models.FrontDoorProtocol]
         :keyword patterns_to_match: The route patterns of the rule.
         :paramtype patterns_to_match: list[str]
@@ -3875,16 +3809,16 @@
         patterns_to_match: Optional[List[str]] = None,
         enabled_state: Optional[Union[str, "_models.RoutingRuleEnabledState"]] = None,
         route_configuration: Optional["_models.RouteConfiguration"] = None,
         rules_engine: Optional["_models.SubResource"] = None,
         web_application_firewall_policy_link: Optional[
             "_models.RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink"
         ] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword frontend_endpoints: Frontend endpoints associated with this rule.
         :paramtype frontend_endpoints: list[~azure.mgmt.frontdoor.models.SubResource]
         :keyword accepted_protocols: Protocol schemes to match for this rule.
         :paramtype accepted_protocols: list[str or ~azure.mgmt.frontdoor.models.FrontDoorProtocol]
         :keyword patterns_to_match: The route patterns of the rule.
         :paramtype patterns_to_match: list[str]
@@ -3921,26 +3855,25 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
 
 class RulesEngine(_serialization.Model):
-    """A rules engine configuration containing a list of rules that will run to modify the runtime
-    behavior of the request and response.
+    """A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and response.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar name: Resource name.
     :vartype name: str
     :ivar type: Resource type.
     :vartype type: str
@@ -3964,15 +3897,15 @@
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "id": {"key": "id", "type": "str"},
         "rules": {"key": "properties.rules", "type": "[RulesEngineRule]"},
         "resource_state": {"key": "properties.resourceState", "type": "str"},
     }
 
-    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs):
         """
         :keyword rules: A list of rules that define a particular Rules Engine Configuration.
         :paramtype rules: list[~azure.mgmt.frontdoor.models.RulesEngineRule]
         """
         super().__init__(**kwargs)
         self.name = None
         self.type = None
@@ -4002,16 +3935,16 @@
 
     def __init__(
         self,
         *,
         request_header_actions: Optional[List["_models.HeaderAction"]] = None,
         response_header_actions: Optional[List["_models.HeaderAction"]] = None,
         route_configuration_override: Optional["_models.RouteConfiguration"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword request_header_actions: A list of header actions to apply from the request from AFD to
          the origin.
         :paramtype request_header_actions: list[~azure.mgmt.frontdoor.models.HeaderAction]
         :keyword response_header_actions: A list of header actions to apply from the response from AFD
          to the client.
         :paramtype response_header_actions: list[~azure.mgmt.frontdoor.models.HeaderAction]
@@ -4021,16 +3954,15 @@
         super().__init__(**kwargs)
         self.request_header_actions = request_header_actions
         self.response_header_actions = response_header_actions
         self.route_configuration_override = route_configuration_override
 
 
 class RulesEngineListResult(_serialization.Model):
-    """Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine
-    objects and a URL link to get the next set of results.
+    """Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of rulesEngines within a Front Door.
     :vartype value: list[~azure.mgmt.frontdoor.models.RulesEngine]
     :ivar next_link: URL to get the next set of RulesEngine objects if there are any.
     :vartype next_link: str
@@ -4041,15 +3973,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RulesEngine]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of RulesEngine objects if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = next_link
@@ -4102,16 +4034,16 @@
         *,
         rules_engine_match_variable: Union[str, "_models.RulesEngineMatchVariable"],
         rules_engine_operator: Union[str, "_models.RulesEngineOperator"],
         rules_engine_match_value: List[str],
         selector: Optional[str] = None,
         negate_condition: Optional[bool] = None,
         transforms: Optional[List[Union[str, "_models.Transform"]]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword rules_engine_match_variable: Match Variable. Required. Known values are: "IsMobile",
          "RemoteAddr", "RequestMethod", "QueryString", "PostArgs", "RequestUri", "RequestPath",
          "RequestFilename", "RequestFilenameExtension", "RequestHeader", "RequestBody", and
          "RequestScheme".
         :paramtype rules_engine_match_variable: str or
          ~azure.mgmt.frontdoor.models.RulesEngineMatchVariable
@@ -4146,15 +4078,15 @@
     :vartype rules: list[~azure.mgmt.frontdoor.models.RulesEngineRule]
     """
 
     _attribute_map = {
         "rules": {"key": "rules", "type": "[RulesEngineRule]"},
     }
 
-    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs):
         """
         :keyword rules: A list of rules that define a particular Rules Engine Configuration.
         :paramtype rules: list[~azure.mgmt.frontdoor.models.RulesEngineRule]
         """
         super().__init__(**kwargs)
         self.rules = rules
 
@@ -4176,27 +4108,25 @@
     }
 
     _attribute_map = {
         "rules": {"key": "rules", "type": "[RulesEngineRule]"},
         "resource_state": {"key": "resourceState", "type": "str"},
     }
 
-    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, rules: Optional[List["_models.RulesEngineRule"]] = None, **kwargs):
         """
         :keyword rules: A list of rules that define a particular Rules Engine Configuration.
         :paramtype rules: list[~azure.mgmt.frontdoor.models.RulesEngineRule]
         """
         super().__init__(rules=rules, **kwargs)
         self.resource_state = None
 
 
 class RulesEngineRule(_serialization.Model):
-    """Contains a list of match conditions, and an action on how to modify the request/response. If
-    multiple rules match, the actions from one rule that conflict with a previous rule overwrite
-    for a singular action, or append in the case of headers manipulation.
+    """Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from one rule that conflict with a previous rule overwrite for a singular action, or append in the case of headers manipulation.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: A name to refer to this specific rule. Required.
     :vartype name: str
     :ivar priority: A priority assigned to this rule. Required.
     :vartype priority: int
@@ -4204,15 +4134,15 @@
      met. Required.
     :vartype action: ~azure.mgmt.frontdoor.models.RulesEngineAction
     :ivar match_conditions: A list of match conditions that must meet in order for the actions of
      this rule to run. Having no match conditions means the actions will always run.
     :vartype match_conditions: list[~azure.mgmt.frontdoor.models.RulesEngineMatchCondition]
     :ivar match_processing_behavior: If this rule is a match should the rules engine continue
      running the remaining rules or stop. If not present, defaults to Continue. Known values are:
-     "Continue", "Stop", and "Continue".
+     "Continue" and "Stop".
     :vartype match_processing_behavior: str or ~azure.mgmt.frontdoor.models.MatchProcessingBehavior
     """
 
     _validation = {
         "name": {"required": True},
         "priority": {"required": True},
         "action": {"required": True},
@@ -4230,30 +4160,30 @@
         self,
         *,
         name: str,
         priority: int,
         action: "_models.RulesEngineAction",
         match_conditions: Optional[List["_models.RulesEngineMatchCondition"]] = None,
         match_processing_behavior: Optional[Union[str, "_models.MatchProcessingBehavior"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword name: A name to refer to this specific rule. Required.
         :paramtype name: str
         :keyword priority: A priority assigned to this rule. Required.
         :paramtype priority: int
         :keyword action: Actions to perform on the request and response if all of the match conditions
          are met. Required.
         :paramtype action: ~azure.mgmt.frontdoor.models.RulesEngineAction
         :keyword match_conditions: A list of match conditions that must meet in order for the actions
          of this rule to run. Having no match conditions means the actions will always run.
         :paramtype match_conditions: list[~azure.mgmt.frontdoor.models.RulesEngineMatchCondition]
         :keyword match_processing_behavior: If this rule is a match should the rules engine continue
          running the remaining rules or stop. If not present, defaults to Continue. Known values are:
-         "Continue", "Stop", and "Continue".
+         "Continue" and "Stop".
         :paramtype match_processing_behavior: str or
          ~azure.mgmt.frontdoor.models.MatchProcessingBehavior
         """
         super().__init__(**kwargs)
         self.name = name
         self.priority = priority
         self.action = action
@@ -4268,15 +4198,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -4289,15 +4219,15 @@
     :vartype name: str or ~azure.mgmt.frontdoor.models.SkuName
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[Union[str, "_models.SkuName"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, name: Optional[Union[str, "_models.SkuName"]] = None, **kwargs):
         """
         :keyword name: Name of the pricing tier. Known values are: "Classic_AzureFrontDoor",
          "Standard_AzureFrontDoor", and "Premium_AzureFrontDoor".
         :paramtype name: str or ~azure.mgmt.frontdoor.models.SkuName
         """
         super().__init__(**kwargs)
         self.name = name
@@ -4310,15 +4240,15 @@
     :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.tags = tags
 
@@ -4386,16 +4316,16 @@
         endpoint: Optional[str] = None,
         start_date_time_utc: Optional[str] = None,
         end_date_time_utc: Optional[str] = None,
         aggregation_interval: Optional[Union[str, "_models.AggregationInterval"]] = None,
         timeseries_type: Optional[Union[str, "_models.TimeseriesType"]] = None,
         country: Optional[str] = None,
         timeseries_data: Optional[List["_models.TimeseriesDataPoint"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword endpoint: The endpoint associated with the Timeseries data point.
         :paramtype endpoint: str
@@ -4435,15 +4365,15 @@
     """
 
     _attribute_map = {
         "date_time_utc": {"key": "dateTimeUTC", "type": "str"},
         "value": {"key": "value", "type": "float"},
     }
 
-    def __init__(self, *, date_time_utc: Optional[str] = None, value: Optional[float] = None, **kwargs: Any) -> None:
+    def __init__(self, *, date_time_utc: Optional[str] = None, value: Optional[float] = None, **kwargs):
         """
         :keyword date_time_utc: The DateTime of the Timeseries data point in UTC.
         :paramtype date_time_utc: str
         :keyword value: The Value of the Timeseries data point.
         :paramtype value: float
         """
         super().__init__(**kwargs)
@@ -4464,15 +4394,15 @@
         "host_name": {"required": True},
     }
 
     _attribute_map = {
         "host_name": {"key": "hostName", "type": "str"},
     }
 
-    def __init__(self, *, host_name: str, **kwargs: Any) -> None:
+    def __init__(self, *, host_name: str, **kwargs):
         """
         :keyword host_name: The host name of the custom domain. Must be a domain name. Required.
         :paramtype host_name: str
         """
         super().__init__(**kwargs)
         self.host_name = host_name
 
@@ -4498,15 +4428,15 @@
 
     _attribute_map = {
         "custom_domain_validated": {"key": "customDomainValidated", "type": "bool"},
         "reason": {"key": "reason", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.custom_domain_validated = None
         self.reason = None
         self.message = None
 
 
@@ -4587,16 +4517,16 @@
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         etag: Optional[str] = None,
         sku: Optional["_models.Sku"] = None,
         policy_settings: Optional["_models.PolicySettings"] = None,
         custom_rules: Optional["_models.CustomRuleList"] = None,
         managed_rules: Optional["_models.ManagedRuleSetList"] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword etag: Gets a unique read-only string that changes whenever the resource is updated.
         :paramtype etag: str
@@ -4620,16 +4550,15 @@
         self.routing_rule_links = None
         self.security_policy_links = None
         self.provisioning_state = None
         self.resource_state = None
 
 
 class WebApplicationFirewallPolicyList(_serialization.Model):
-    """Defines a list of WebApplicationFirewallPolicies. It contains a list of
-    WebApplicationFirewallPolicy objects and a URL link to get the next set of results.
+    """Defines a list of WebApplicationFirewallPolicies. It contains a list of WebApplicationFirewallPolicy objects and a URL link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of WebApplicationFirewallPolicies within a resource group.
     :vartype value: list[~azure.mgmt.frontdoor.models.WebApplicationFirewallPolicy]
     :ivar next_link: URL to get the next set of WebApplicationFirewallPolicy objects if there are
      any.
@@ -4641,15 +4570,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[WebApplicationFirewallPolicy]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, next_link: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, next_link: Optional[str] = None, **kwargs):
         """
         :keyword next_link: URL to get the next set of WebApplicationFirewallPolicy objects if there
          are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = None
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_patch.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/__init__.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,16 +15,14 @@
 from ._models_py3 import BackendPoolsSettings
 from ._models_py3 import CacheConfiguration
 from ._models_py3 import CheckNameAvailabilityInput
 from ._models_py3 import CheckNameAvailabilityOutput
 from ._models_py3 import CustomHttpsConfiguration
 from ._models_py3 import CustomRule
 from ._models_py3 import CustomRuleList
-from ._models_py3 import DefaultErrorResponse
-from ._models_py3 import DefaultErrorResponseError
 from ._models_py3 import Endpoint
 from ._models_py3 import Error
 from ._models_py3 import ErrorDetails
 from ._models_py3 import ErrorResponse
 from ._models_py3 import Experiment
 from ._models_py3 import ExperimentList
 from ._models_py3 import ExperimentUpdateModel
@@ -160,16 +158,14 @@
     "BackendPoolsSettings",
     "CacheConfiguration",
     "CheckNameAvailabilityInput",
     "CheckNameAvailabilityOutput",
     "CustomHttpsConfiguration",
     "CustomRule",
     "CustomRuleList",
-    "DefaultErrorResponse",
-    "DefaultErrorResponseError",
     "Endpoint",
     "Error",
     "ErrorDetails",
     "ErrorResponse",
     "Experiment",
     "ExperimentList",
     "ExperimentUpdateModel",
```

## Comparing `azure-mgmt-frontdoor-1.1.0/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py` & `azure-mgmt-frontdoor-1.1.0b1/azure/mgmt/frontdoor/models/_front_door_management_client_enums.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Defines the action to take on rule match."""
 
     ALLOW = "Allow"
     BLOCK = "Block"
     LOG = "Log"
     REDIRECT = "Redirect"
-    ANOMALY_SCORING = "AnomalyScoring"
 
 
 class AggregationInterval(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The aggregation interval of the Timeseries."""
 
     HOURLY = "Hourly"
     DAILY = "Daily"
@@ -257,15 +256,14 @@
 class MatchProcessingBehavior(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """If this rule is a match should the rules engine continue running the remaining rules or stop.
     If not present, defaults to Continue.
     """
 
     CONTINUE = "Continue"
     STOP = "Stop"
-    CONTINUE_ENUM = "Continue"
 
 
 class MatchVariable(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Request variable to compare with."""
 
     REMOTE_ADDR = "RemoteAddr"
     REQUEST_METHOD = "RequestMethod"
```

