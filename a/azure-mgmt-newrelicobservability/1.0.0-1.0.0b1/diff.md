# Comparing `tmp/azure-mgmt-newrelicobservability-1.0.0.zip` & `tmp/azure-mgmt-newrelicobservability-1.0.0b1.zip`

## zipinfo {}

```diff
@@ -1,59 +1,59 @@
-Zip file size: 98410 bytes, number of entries: 57
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/
--rw-rw-r--  2.0 unx      624 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/_meta.json
--rw-rw-r--  2.0 unx     1074 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/LICENSE
--rw-rw-r--  2.0 unx       38 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/setup.cfg
--rw-rw-r--  2.0 unx      118 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/CHANGELOG.md
--rw-rw-r--  2.0 unx     3263 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/PKG-INFO
--rw-rw-r--  2.0 unx      227 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/MANIFEST.in
--rw-rw-r--  2.0 unx     2856 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/setup.py
--rw-rw-r--  2.0 unx     2230 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/README.md
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_patch.py
--rw-rw-r--  2.0 unx     5431 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_vendor.py
--rw-rw-r--  2.0 unx      935 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/__init__.py
--rw-rw-r--  2.0 unx    78836 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_serialization.py
--rw-rw-r--  2.0 unx       26 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/py.typed
--rw-rw-r--  2.0 unx      486 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_version.py
--rw-rw-r--  2.0 unx     3527 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_configuration.py
--rw-rw-r--  2.0 unx    97214 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_monitors_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_patch.py
--rw-rw-r--  2.0 unx     7439 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_organizations_operations.py
--rw-rw-r--  2.0 unx     1163 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/__init__.py
--rw-rw-r--  2.0 unx     7371 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_accounts_operations.py
--rw-rw-r--  2.0 unx    40716 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py
--rw-rw-r--  2.0 unx     6499 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_operations.py
--rw-rw-r--  2.0 unx     7592 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_plans_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_patch.py
--rw-rw-r--  2.0 unx     5587 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py
--rw-rw-r--  2.0 unx      882 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/__init__.py
--rw-rw-r--  2.0 unx     3575 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_configuration.py
--rw-rw-r--  2.0 unx    78967 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     6266 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py
--rw-rw-r--  2.0 unx     1163 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6207 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py
--rw-rw-r--  2.0 unx    33370 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py
--rw-rw-r--  2.0 unx     5804 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     6286 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py
--rw-rw-r--  2.0 unx     5857 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py
--rw-rw-r--  2.0 unx    89567 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_patch.py
--rw-rw-r--  2.0 unx     6308 b- defN 23-May-22 08:58 azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/__init__.py
--rw-rw-r--  2.0 unx     3263 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx      124 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/requires.txt
--rw-rw-r--  2.0 unx     2358 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-May-22 08:59 azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/top_level.txt
-57 files, 528059 bytes uncompressed, 84428 bytes compressed:  84.0%
+Zip file size: 99960 bytes, number of entries: 57
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/
+-rw-rw-r--  2.0 unx     3209 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx      624 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/_meta.json
+-rw-rw-r--  2.0 unx     2856 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/setup.py
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/LICENSE
+-rw-rw-r--  2.0 unx      227 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx       38 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/setup.cfg
+-rw-rw-r--  2.0 unx     2230 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/README.md
+-rw-rw-r--  2.0 unx       62 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     3209 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        1 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx      124 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx     2358 b- defN 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/
+-rw-rw-r--  2.0 unx      488 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/py.typed
+-rw-rw-r--  2.0 unx     3800 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_patch.py
+-rw-rw-r--  2.0 unx      935 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/__init__.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_vendor.py
+-rw-rw-r--  2.0 unx    78824 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_serialization.py
+-rw-rw-r--  2.0 unx     5439 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py
+-rw-rw-r--  2.0 unx    89567 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_patch.py
+-rw-rw-r--  2.0 unx     6308 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/__init__.py
+-rw-rw-r--  2.0 unx     5857 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Mar-28 03:45 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/
+-rw-rw-r--  2.0 unx     3848 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_patch.py
+-rw-rw-r--  2.0 unx      882 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/__init__.py
+-rw-rw-r--  2.0 unx     5595 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     1163 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     6544 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py
+-rw-rw-r--  2.0 unx    79234 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py
+-rw-rw-r--  2.0 unx    33936 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py
+-rw-rw-r--  2.0 unx     6082 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     6564 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py
+-rw-rw-r--  2.0 unx     6485 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_patch.py
+-rw-rw-r--  2.0 unx     1163 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/__init__.py
+-rw-rw-r--  2.0 unx     7765 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_organizations_operations.py
+-rw-rw-r--  2.0 unx    98105 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_monitors_operations.py
+-rw-rw-r--  2.0 unx    41489 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py
+-rw-rw-r--  2.0 unx     6825 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_operations.py
+-rw-rw-r--  2.0 unx     7918 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_plans_operations.py
+-rw-rw-r--  2.0 unx     7697 b- defN 23-Mar-28 03:44 azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_accounts_operations.py
+57 files, 533360 bytes uncompressed, 85750 bytes compressed:  83.9%
```

## zipnote {}

```diff
@@ -1,172 +1,172 @@
-Filename: azure-mgmt-newrelicobservability-1.0.0/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/_meta.json
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/LICENSE
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/setup.cfg
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/CHANGELOG.md
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/PKG-INFO
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/MANIFEST.in
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/setup.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/README.md
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_patch.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_vendor.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_serialization.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/py.typed
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_version.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_version.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_configuration.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/py.typed
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_monitors_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_patch.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_patch.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_organizations_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_accounts_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_plans_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_patch.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_configuration.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_patch.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_models_py3.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_patch.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/__init__.py
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/PKG-INFO
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_organizations_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/not-zip-safe
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_monitors_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/requires.txt
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/dependency_links.txt
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_plans_operations.py
 Comment: 
 
-Filename: azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/top_level.txt
+Filename: azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_accounts_operations.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/_meta.json` & `azure-mgmt-newrelicobservability-1.0.0b1/_meta.json`

 * *Files 8% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/newrelic/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.4.3 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'e58e0182fe8a91a069a95043b0812b53be3d916e'",*

 * * "'use'": "{insert […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/newrelic/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.8 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "e60df62e9e0d88462e6abba81a76d94eab000f0d",
+    "autorest_command": "autorest specification/newrelic/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.3 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "e58e0182fe8a91a069a95043b0812b53be3d916e",
     "readme": "specification/newrelic/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.8",
+        "@autorest/python@6.4.3",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/LICENSE` & `azure-mgmt-newrelicobservability-1.0.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/PKG-INFO` & `azure-mgmt-newrelicobservability-1.0.0b1/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-newrelicobservability
-Version: 1.0.0
+Version: 1.0.0b1
 Summary: Microsoft Azure Newrelicobservability Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -85,16 +85,10 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-newrelicobservability%2FREADME.png)
 
 
 # Release History
 
-## 1.0.0 (2023-05-20)
-
-### Other Changes
-
-  - First GA
-
 ## 1.0.0b1 (2023-03-24)
 
 * Initial Release
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/setup.py` & `azure-mgmt-newrelicobservability-1.0.0b1/setup.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/README.md` & `azure-mgmt-newrelicobservability-1.0.0b1/README.md`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_patch.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_new_relic_observability_mgmt_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -46,16 +46,16 @@
     :vartype tag_rules: azure.mgmt.newrelicobservability.operations.TagRulesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-07-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_vendor.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/__init__.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_serialization.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -625,15 +625,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+                                xml_name = "{}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -1267,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1291,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/_configuration.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class NewRelicObservabilityMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for NewRelicObservabilityMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-07-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(NewRelicObservabilityMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-07-01")
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop("api_version", "2022-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_monitors_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_monitors_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,26 +28,32 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/monitors")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -62,15 +69,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors",
     )  # pylint: disable=line-too-long
@@ -92,15 +101,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}",
     )  # pylint: disable=line-too-long
@@ -125,15 +136,17 @@
 
 def build_create_or_update_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}",
@@ -161,15 +174,17 @@
 
 def build_update_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}",
@@ -197,15 +212,17 @@
 
 def build_delete_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, *, user_email: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}",
     )  # pylint: disable=line-too-long
@@ -231,15 +248,17 @@
 
 def build_get_metric_rules_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricRules",
@@ -267,15 +286,17 @@
 
 def build_get_metric_status_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/getMetricStatus",
@@ -303,15 +324,17 @@
 
 def build_list_app_services_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listAppServices",
@@ -339,15 +362,17 @@
 
 def build_switch_billing_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/switchBilling",
@@ -375,15 +400,17 @@
 
 def build_list_hosts_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listHosts",
@@ -411,15 +438,17 @@
 
 def build_list_monitored_resources_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/monitoredResources",
     )  # pylint: disable=line-too-long
@@ -444,15 +473,17 @@
 
 def build_vm_host_payload_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/vmHostPayloads",
     )  # pylint: disable=line-too-long
@@ -504,15 +535,17 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -592,15 +625,17 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -689,15 +724,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -745,15 +782,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(resource, (IO, bytes)):
@@ -914,15 +953,17 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -1054,15 +1095,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(properties, (IO, bytes)):
@@ -1118,15 +1161,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             user_email=user_email,
@@ -1185,15 +1230,17 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1317,15 +1364,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.MetricRules] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
@@ -1460,15 +1509,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.MetricsStatusResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
@@ -1595,15 +1646,17 @@
         :return: An iterator like instance of either AppServiceInfo or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.AppServiceInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AppServicesListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1680,109 +1733,111 @@
         return ItemPaged(get_next, extract_data)
 
     list_app_services.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listAppServices"
     }
 
     @overload
-    def switch_billing(
+    def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: _models.SwitchBillingRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Required.
         :type request: ~azure.mgmt.newrelicobservability.models.SwitchBillingRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def switch_billing(
+    def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Required.
         :type request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def switch_billing(
+    def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: Union[_models.SwitchBillingRequest, IO],
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Is either a SwitchBillingRequest
          type or a IO type. Required.
         :type request: ~azure.mgmt.newrelicobservability.models.SwitchBillingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NewRelicMonitorResource]] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
             _content = request
         else:
@@ -1806,31 +1861,21 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("NewRelicMonitorResource", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
-
-        return deserialized
+            return cls(pipeline_response, None, {})
 
     switch_billing.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/switchBilling"
     }
 
     @overload
     def list_hosts(
@@ -1909,15 +1954,17 @@
         :return: An iterator like instance of either VMInfo or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.VMInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.VMHostsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -2013,15 +2060,17 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.MonitoredResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.MonitoredResourceListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2112,15 +2161,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.VMExtensionPayload] = kwargs.pop("cls", None)
 
         request = build_vm_host_payload_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_patch.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_organizations_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_organizations_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, user_email: str, location: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/organizations")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -95,15 +102,17 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.OrganizationResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.OrganizationsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/__init__.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_accounts_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_accounts_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,26 +26,32 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, user_email: str, location: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/accounts")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -93,15 +100,17 @@
         :return: An iterator like instance of either AccountResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.AccountResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.AccountsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_tag_rules_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,28 +28,34 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_by_new_relic_monitor_resource_request(  # pylint: disable=name-too-long
+def build_list_by_new_relic_monitor_resource_request(
     resource_group_name: str, monitor_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/tagRules",
     )  # pylint: disable=line-too-long
@@ -73,15 +80,17 @@
 
 def build_get_request(
     resource_group_name: str, monitor_name: str, rule_set_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/tagRules/{ruleSetName}",
     )  # pylint: disable=line-too-long
@@ -107,15 +116,17 @@
 
 def build_create_or_update_request(
     resource_group_name: str, monitor_name: str, rule_set_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/tagRules/{ruleSetName}",
@@ -144,15 +155,17 @@
 
 def build_delete_request(
     resource_group_name: str, monitor_name: str, rule_set_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/tagRules/{ruleSetName}",
     )  # pylint: disable=line-too-long
@@ -178,15 +191,17 @@
 
 def build_update_request(
     resource_group_name: str, monitor_name: str, rule_set_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/tagRules/{ruleSetName}",
@@ -247,15 +262,17 @@
         :return: An iterator like instance of either TagRule or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.TagRule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TagRuleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -347,15 +364,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             rule_set_name=rule_set_name,
             subscription_id=self._config.subscription_id,
@@ -405,15 +424,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(resource, (IO, bytes)):
@@ -577,15 +598,17 @@
         :return: An instance of LROPoller that returns either TagRule or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.newrelicobservability.models.TagRule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -639,15 +662,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             rule_set_name=rule_set_name,
             subscription_id=self._config.subscription_id,
@@ -706,15 +731,17 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -851,15 +878,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(properties, (IO, bytes)):
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,95 +2,81 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import sys
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
-
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._operations import build_list_request
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_request(**kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/providers/NewRelic.Observability/operations")
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.newrelicobservability.NewRelicObservabilityMgmtClient`'s
+        :class:`~azure.mgmt.newrelicobservability.aio.NewRelicObservabilityMgmtClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """List the operations for the provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.Operation]
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -123,33 +109,33 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/NewRelic.Observability/operations"}
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/operations/_plans_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_plans_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,28 +26,34 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     subscription_id: str, *, account_id: Optional[str] = None, organization_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-07-01"))
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/plans")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -99,15 +106,17 @@
         :return: An iterator like instance of either PlanDataResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.PlanDataResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.PlanDataListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_patch.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/_new_relic_observability_mgmt_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -46,16 +46,16 @@
     :vartype tag_rules: azure.mgmt.newrelicobservability.aio.operations.TagRulesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-07-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/__init__.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/_configuration.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/_configuration.py`

 * *Files 24% similar despite different names*

```diff
@@ -2,45 +2,51 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
+from ._version import VERSION
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class NewRelicObservabilityMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for NewRelicObservabilityMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-07-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(NewRelicObservabilityMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2022-07-01")
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop("api_version", "2022-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +58,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_monitors_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -42,14 +43,18 @@
     build_list_hosts_request,
     build_list_monitored_resources_request,
     build_switch_billing_request,
     build_update_request,
     build_vm_host_payload_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class MonitorsOperations:
     """
     .. warning::
@@ -79,15 +84,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -167,15 +174,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -264,15 +273,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -320,15 +331,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(resource, (IO, bytes)):
@@ -489,15 +502,17 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -630,15 +645,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NewRelicMonitorResource] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(properties, (IO, bytes)):
@@ -694,15 +711,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             user_email=user_email,
@@ -761,15 +780,17 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -894,15 +915,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.MetricRules] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
@@ -1037,15 +1060,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.MetricsStatusResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
@@ -1175,15 +1200,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.AppServiceInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AppServicesListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1260,109 +1287,111 @@
         return AsyncItemPaged(get_next, extract_data)
 
     list_app_services.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/listAppServices"
     }
 
     @overload
-    async def switch_billing(
+    async def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: _models.SwitchBillingRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Required.
         :type request: ~azure.mgmt.newrelicobservability.models.SwitchBillingRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def switch_billing(
+    async def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Required.
         :type request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def switch_billing(
+    async def switch_billing(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         monitor_name: str,
         request: Union[_models.SwitchBillingRequest, IO],
         **kwargs: Any
-    ) -> Optional[_models.NewRelicMonitorResource]:
+    ) -> None:
         """Switches the billing for NewRelic monitor resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param monitor_name: Name of the Monitors resource. Required.
         :type monitor_name: str
         :param request: The details of the switch billing request. Is either a SwitchBillingRequest
          type or a IO type. Required.
         :type request: ~azure.mgmt.newrelicobservability.models.SwitchBillingRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NewRelicMonitorResource or None or the result of cls(response)
-        :rtype: ~azure.mgmt.newrelicobservability.models.NewRelicMonitorResource or None
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NewRelicMonitorResource]] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(request, (IO, bytes)):
             _content = request
         else:
@@ -1386,31 +1415,21 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202, 204]:
+        if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("NewRelicMonitorResource", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
-
-        return deserialized
+            return cls(pipeline_response, None, {})
 
     switch_billing.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/NewRelic.Observability/monitors/{monitorName}/switchBilling"
     }
 
     @overload
     def list_hosts(
@@ -1492,15 +1511,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.VMInfo]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.VMHostsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1596,15 +1617,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.MonitoredResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.MonitoredResourceListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1697,15 +1720,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.VMExtensionPayload] = kwargs.pop("cls", None)
 
         request = build_vm_host_payload_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_patch.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_organizations_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,14 +26,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._organizations_operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class OrganizationsOperations:
     """
     .. warning::
@@ -66,15 +71,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.OrganizationResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.OrganizationsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/__init__.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_accounts_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,14 +26,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._accounts_operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccountsOperations:
     """
     .. warning::
@@ -65,15 +70,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.AccountResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.AccountsListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_tag_rules_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_new_relic_monitor_resource_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class TagRulesOperations:
     """
     .. warning::
@@ -77,15 +82,17 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.TagRule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TagRuleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -179,15 +186,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             rule_set_name=rule_set_name,
             subscription_id=self._config.subscription_id,
@@ -237,15 +246,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(resource, (IO, bytes)):
@@ -412,15 +423,17 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.newrelicobservability.models.TagRule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -475,15 +488,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             monitor_name=monitor_name,
             rule_set_name=rule_set_name,
             subscription_id=self._config.subscription_id,
@@ -542,15 +557,17 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -688,15 +705,17 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.TagRule] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(properties, (IO, bytes)):
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py`

 * *Files 21% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -23,67 +24,82 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._operations import build_list_request
+from ...operations._plans_operations import build_list_request
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class Operations:
+class PlansOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.newrelicobservability.aio.NewRelicObservabilityMgmtClient`'s
-        :attr:`operations` attribute.
+        :attr:`plans` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
-        """List the operations for the provider.
-
+    def list(
+        self, account_id: Optional[str] = None, organization_id: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.PlanDataResource"]:
+        """List plans data.
+
+        :param account_id: Account Id. Default value is None.
+        :type account_id: str
+        :param organization_id: Organization Id. Default value is None.
+        :type organization_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either Operation or the result of cls(response)
+        :return: An iterator like instance of either PlanDataResource or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.PlanDataResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        cls: ClsType[_models.PlanDataListResponse] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
+                    subscription_id=self._config.subscription_id,
+                    account_id=account_id,
+                    organization_id=organization_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -103,15 +119,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("OperationListResult", pipeline_response)
+            deserialized = self._deserialize("PlanDataListResponse", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -127,8 +143,8 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/NewRelic.Observability/operations"}
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/plans"}
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/aio/operations/_plans_operations.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_operations.py`

 * *Files 19% similar despite different names*

```diff
@@ -2,97 +2,118 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import sys
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._plans_operations import build_list_request
-
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
+
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(**kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2022-07-01-preview")
+    )
+    accept = _headers.pop("Accept", "application/json")
 
+    # Construct URL
+    _url = kwargs.pop("template_url", "/providers/NewRelic.Observability/operations")
 
-class PlansOperations:
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.newrelicobservability.aio.NewRelicObservabilityMgmtClient`'s
-        :attr:`plans` attribute.
+        :class:`~azure.mgmt.newrelicobservability.NewRelicObservabilityMgmtClient`'s
+        :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(
-        self, account_id: Optional[str] = None, organization_id: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.PlanDataResource"]:
-        """List plans data.
-
-        :param account_id: Account Id. Default value is None.
-        :type account_id: str
-        :param organization_id: Organization Id. Default value is None.
-        :type organization_id: str
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+        """List the operations for the provider.
+
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either PlanDataResource or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.newrelicobservability.models.PlanDataResource]
+        :return: An iterator like instance of either Operation or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.newrelicobservability.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PlanDataListResponse] = kwargs.pop("cls", None)
+        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    subscription_id=self._config.subscription_id,
-                    account_id=account_id,
-                    organization_id=organization_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -111,33 +132,33 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("PlanDataListResponse", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/NewRelic.Observability/plans"}
+    list.metadata = {"url": "/providers/NewRelic.Observability/operations"}
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_new_relic_observability_mgmt_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_models_py3.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/_patch.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure/mgmt/newrelicobservability/models/__init__.py` & `azure-mgmt-newrelicobservability-1.0.0b1/azure/mgmt/newrelicobservability/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/PKG-INFO` & `azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-newrelicobservability
-Version: 1.0.0
+Version: 1.0.0b1
 Summary: Microsoft Azure Newrelicobservability Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -85,16 +85,10 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-newrelicobservability%2FREADME.png)
 
 
 # Release History
 
-## 1.0.0 (2023-05-20)
-
-### Other Changes
-
-  - First GA
-
 ## 1.0.0b1 (2023-03-24)
 
 * Initial Release
```

## Comparing `azure-mgmt-newrelicobservability-1.0.0/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt` & `azure-mgmt-newrelicobservability-1.0.0b1/azure_mgmt_newrelicobservability.egg-info/SOURCES.txt`

 * *Files identical despite different names*

