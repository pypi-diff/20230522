# Comparing `tmp/azure-mgmt-privatedns-1.1.0.zip` & `tmp/azure-mgmt-privatedns-1.1.0b1.zip`

## zipinfo {}

```diff
@@ -1,53 +1,53 @@
-Zip file size: 79988 bytes, number of entries: 51
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/
--rw-rw-r--  2.0 unx     1074 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/LICENSE
--rw-rw-r--  2.0 unx     2830 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/setup.py
--rw-rw-r--  2.0 unx     2655 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/CHANGELOG.md
--rw-rw-r--  2.0 unx     2157 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/README.md
--rw-rw-r--  2.0 unx      216 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/MANIFEST.in
--rw-rw-r--  2.0 unx       38 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/setup.cfg
--rw-rw-r--  2.0 unx     5701 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/PKG-INFO
--rw-rw-r--  2.0 unx      628 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/_meta.json
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/
--rw-rw-r--  2.0 unx       65 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/
--rw-rw-r--  2.0 unx      919 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/__init__.py
--rw-rw-r--  2.0 unx      486 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_version.py
--rw-rw-r--  2.0 unx       26 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/py.typed
--rw-rw-r--  2.0 unx     4844 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_private_dns_management_client.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_vendor.py
--rw-rw-r--  2.0 unx     3621 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_patch.py
--rw-rw-r--  2.0 unx    78836 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_serialization.py
--rw-rw-r--  2.0 unx     2108 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/__init__.py
--rw-rw-r--  2.0 unx     1472 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py
--rw-rw-r--  2.0 unx    33859 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/
--rw-rw-r--  2.0 unx      866 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/__init__.py
--rw-rw-r--  2.0 unx     4993 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_private_dns_management_client.py
--rw-rw-r--  2.0 unx     3669 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_configuration.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_patch.py
--rw-rw-r--  2.0 unx      999 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    37920 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py
--rw-rw-r--  2.0 unx    44018 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    43227 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py
--rw-rw-r--  2.0 unx      999 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/__init__.py
--rw-rw-r--  2.0 unx    48997 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_record_sets_operations.py
--rw-rw-r--  2.0 unx    52282 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_private_zones_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_patch.py
--rw-rw-r--  2.0 unx    51366 b- defN 23-May-22 09:00 azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx     1622 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx      124 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/requires.txt
--rw-rw-r--  2.0 unx     5701 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        6 b- defN 23-May-22 09:01 azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/top_level.txt
-51 files, 443063 bytes uncompressed, 69644 bytes compressed:  84.3%
+Zip file size: 79475 bytes, number of entries: 51
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/
+-rw-rw-r--  2.0 unx      216 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx     2772 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/setup.py
+-rw-rw-r--  2.0 unx     2557 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx       38 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/setup.cfg
+-rw-rw-r--  2.0 unx     1359 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/README.md
+-rw-rw-r--  2.0 unx      628 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/_meta.json
+-rw-rw-r--  2.0 unx     1074 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/LICENSE
+-rw-rw-r--  2.0 unx     4756 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/PKG-INFO
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/
+-rw-rw-r--  2.0 unx       65 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/
+-rw-rw-r--  2.0 unx       26 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/py.typed
+-rw-rw-r--  2.0 unx      488 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_version.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_patch.py
+-rw-rw-r--  2.0 unx     3922 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_configuration.py
+-rw-rw-r--  2.0 unx     4866 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_private_dns_management_client.py
+-rw-rw-r--  2.0 unx      934 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/__init__.py
+-rw-rw-r--  2.0 unx     1169 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_vendor.py
+-rw-rw-r--  2.0 unx    77450 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_serialization.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_patch.py
+-rw-rw-r--  2.0 unx    52094 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py
+-rw-rw-r--  2.0 unx    53084 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_private_zones_operations.py
+-rw-rw-r--  2.0 unx     1014 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/__init__.py
+-rw-rw-r--  2.0 unx    49511 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_record_sets_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_patch.py
+-rw-rw-r--  2.0 unx     3926 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4952 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_private_dns_management_client.py
+-rw-rw-r--  2.0 unx      881 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    43914 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py
+-rw-rw-r--  2.0 unx    44774 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py
+-rw-rw-r--  2.0 unx     1014 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    38388 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py
+-rw-rw-r--  2.0 unx     1472 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py
+-rw-rw-r--  2.0 unx      674 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_patch.py
+-rw-rw-r--  2.0 unx    33603 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_models_py3.py
+-rw-rw-r--  2.0 unx     2123 b- defN 22-Oct-31 03:19 azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/__init__.py
+-rw-rw-r--  2.0 unx        1 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx        1 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx        6 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx     1622 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx      116 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/requires.txt
+-rw-rw-r--  2.0 unx     4756 b- defN 22-Oct-31 03:20 azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/PKG-INFO
+51 files, 443007 bytes uncompressed, 68927 bytes compressed:  84.4%
```

## zipnote {}

```diff
@@ -1,154 +1,154 @@
-Filename: azure-mgmt-privatedns-1.1.0/
+Filename: azure-mgmt-privatedns-1.1.0b1/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/LICENSE
+Filename: azure-mgmt-privatedns-1.1.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/setup.py
+Filename: azure-mgmt-privatedns-1.1.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/CHANGELOG.md
+Filename: azure-mgmt-privatedns-1.1.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/README.md
+Filename: azure-mgmt-privatedns-1.1.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/MANIFEST.in
+Filename: azure-mgmt-privatedns-1.1.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/setup.cfg
+Filename: azure-mgmt-privatedns-1.1.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/PKG-INFO
+Filename: azure-mgmt-privatedns-1.1.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/_meta.json
+Filename: azure-mgmt-privatedns-1.1.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/py.typed
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_version.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_version.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/py.typed
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_patch.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_private_dns_management_client.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_vendor.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_private_dns_management_client.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_configuration.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_patch.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_serialization.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_models_py3.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_private_zones_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_patch.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_record_sets_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_private_dns_management_client.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_configuration.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_patch.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_private_dns_management_client.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_patch.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/__init__.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_record_sets_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_private_zones_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_patch.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py
+Filename: azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/not-zip-safe
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/SOURCES.txt
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/requires.txt
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/PKG-INFO
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/dependency_links.txt
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/top_level.txt
+Filename: azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/PKG-INFO
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-privatedns-1.1.0/LICENSE` & `azure-mgmt-privatedns-1.1.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/setup.py` & `azure-mgmt-privatedns-1.1.0b1/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -51,29 +51,28 @@
         'Programming Language :: Python',
         'Programming Language :: Python :: 3 :: Only',
         'Programming Language :: Python :: 3',
         'Programming Language :: Python :: 3.7',
         'Programming Language :: Python :: 3.8',
         'Programming Language :: Python :: 3.9',
         'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
         'License :: OSI Approved :: MIT License',
     ],
     zip_safe=False,
     packages=find_packages(exclude=[
         'tests',
         # Exclude packages that will be covered by PEP420 or nspkg
         'azure',
         'azure.mgmt',
     ]),
     include_package_data=True,
     package_data={
         'pytyped': ['py.typed'],
     },
     install_requires=[
-        "isodate<1.0.0,>=0.6.1",
+        "msrest>=0.7.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
     python_requires=">=3.7"
 )
```

## Comparing `azure-mgmt-privatedns-1.1.0/CHANGELOG.md` & `azure-mgmt-privatedns-1.1.0b1/CHANGELOG.md`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,9 @@
 # Release History
 
-## 1.1.0 (2023-05-20)
-
-### Features Added
-
-  - Model PrivateZone has a new parameter internal_id
-
 ## 1.1.0b1 (2022-10-28)
 
 ### Features Added
 
   - Model PrivateZone has a new parameter internal_id
 
 ## 1.0.0 (2021-03-25)
```

## Comparing `azure-mgmt-privatedns-1.1.0/PKG-INFO` & `azure-mgmt-privatedns-1.1.0b1/PKG-INFO`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-privatedns
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure DNS Private Zones Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Microsoft Azure SDK for Python
 
@@ -27,78 +26,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [DNS Private Zones](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-privatedns
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.privatedns import PrivateDnsManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = PrivateDnsManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search DNS Private Zones](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-privatedns%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-05-20)
-
-### Features Added
-
-  - Model PrivateZone has a new parameter internal_id
-
 ## 1.1.0b1 (2022-10-28)
 
 ### Features Added
 
   - Model PrivateZone has a new parameter internal_id
 
 ## 1.0.0 (2021-03-25)
```

## Comparing `azure-mgmt-privatedns-1.1.0/_meta.json` & `azure-mgmt-privatedns-1.1.0b1/_meta.json`

 * *Files 9% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/privatedns/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.2.1 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'e82a24def11ffc98cc263884f9f1742c99f2df5e'",*

 * * "'use'": "{inse […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/privatedns/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.8 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "e716082ac474f182e2220e4f38f1d6191e7636cf",
+    "autorest_command": "autorest specification/privatedns/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.1 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "e82a24def11ffc98cc263884f9f1742c99f2df5e",
     "readme": "specification/privatedns/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.8",
+        "@autorest/python@6.2.1",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/__init__.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from ._private_dns_management_client import PrivateDnsManagementClient
 from ._version import VERSION
 
 __version__ = VERSION
 
 try:
     from ._patch import __all__ as _patch_all
-    from ._patch import *  # pylint: disable=unused-wildcard-import
+    from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 except ImportError:
     _patch_all = []
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "PrivateDnsManagementClient",
 ]
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_private_dns_management_client.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_private_dns_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, TYPE_CHECKING
 
 from azure.core.rest import HttpRequest, HttpResponse
 from azure.mgmt.core import ARMPipelineClient
 
-from . import models as _models
+from . import models
 from ._configuration import PrivateDnsManagementClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import PrivateZonesOperations, RecordSetsOperations, VirtualNetworkLinksOperations
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
@@ -51,17 +51,17 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = PrivateDnsManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.private_zones = PrivateZonesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.virtual_network_links = VirtualNetworkLinksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -85,16 +85,19 @@
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self) -> None:
+    def close(self):
+        # type: () -> None
         self._client.close()
 
-    def __enter__(self) -> "PrivateDnsManagementClient":
+    def __enter__(self):
+        # type: () -> PrivateDnsManagementClient
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details: Any) -> None:
+    def __exit__(self, *exc_details):
+        # type: (Any) -> None
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_vendor.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from typing import List, cast
-
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -20,11 +18,10 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            # Need the cast, as for some reasons "split" is typed as list[str | Any]
-            formatted_components = cast(List[str], template.split("/"))
+            formatted_components = template.split("/")
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_configuration.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_configuration.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class PrivateDnsManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for PrivateDnsManagementClient.
@@ -33,29 +39,32 @@
     :keyword api_version: Api Version. Default value is "2020-06-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(PrivateDnsManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-06-01")
+        api_version = kwargs.pop("api_version", "2020-06-01")  # type: Literal["2020-06-01"]
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-privatedns/{}".format(VERSION))
         self._configure(**kwargs)
 
-    def _configure(self, **kwargs: Any) -> None:
+    def _configure(
+        self, **kwargs  # type: Any
+    ):
+        # type: (...) -> None
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
         self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_patch.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/_serialization.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/_serialization.py`

 * *Files 3% similar despite different names*

```diff
@@ -21,71 +21,56 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 #
 # --------------------------------------------------------------------------
 
 # pylint: skip-file
-# pyright: reportUnnecessaryTypeIgnoreComment=false
 
 from base64 import b64decode, b64encode
 import calendar
 import datetime
 import decimal
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import (
-    Dict,
-    Any,
-    cast,
-    Optional,
-    Union,
-    AnyStr,
-    IO,
-    Mapping,
-    Callable,
-    TypeVar,
-    MutableMapping,
-    Type,
-    List,
-    Mapping,
-)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
-    from urllib.parse import quote
+    from urllib.parse import quote  # type: ignore
 import xml.etree.ElementTree as ET
 
-import isodate  # type: ignore
+import isodate
+
+from typing import Dict, Any, cast, TYPE_CHECKING
 
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
-from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
-ModelType = TypeVar("ModelType", bound="Model")
-JSON = MutableMapping[str, Any]
+if TYPE_CHECKING:
+    from typing import Optional, Union, AnyStr, IO, Mapping
 
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
     CONTEXT_NAME = "deserialized_data"
 
     @classmethod
-    def deserialize_from_text(cls, data: Optional[Union[AnyStr, IO]], content_type: Optional[str] = None) -> Any:
+    def deserialize_from_text(cls, data, content_type=None):
+        # type: (Optional[Union[AnyStr, IO]], Optional[str]) -> Any
         """Decode data according to content-type.
 
         Accept a stream of data as well, but will be load at once in memory for now.
 
         If no content-type, will return the string version (not bytes, not stream)
 
         :param data: Input, could be bytes or stream (will be decoded with UTF8) or text
@@ -143,15 +128,16 @@
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
                 raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
-    def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
+    def deserialize_from_http_generics(cls, body_bytes, headers):
+        # type: (Optional[Union[AnyStr, IO]], Mapping) -> Any
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
         specific implementation.
         Headers will tested for "content-type"
         """
         # Try to use content-type from headers if available
@@ -170,16 +156,16 @@
         return None
 
 
 try:
     basestring  # type: ignore
     unicode_str = unicode  # type: ignore
 except NameError:
-    basestring = str
-    unicode_str = str
+    basestring = str  # type: ignore
+    unicode_str = str  # type: ignore
 
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
@@ -198,15 +184,15 @@
 
     def dst(self, dt):
         """No daylight saving for UTC."""
         return datetime.timedelta(hours=1)
 
 
 try:
-    from datetime import timezone as _FixedOffset  # type: ignore
+    from datetime import timezone as _FixedOffset
 except ImportError:  # Python 2.7
 
     class _FixedOffset(datetime.tzinfo):  # type: ignore
         """Fixed offset in minutes east from UTC.
         Copy/pasted from Python doc
         :param datetime.timedelta offset: offset in timedelta format
         """
@@ -229,15 +215,15 @@
         def __getinitargs__(self):
             return (self.__offset,)
 
 
 try:
     from datetime import timezone
 
-    TZ_UTC = timezone.utc
+    TZ_UTC = timezone.utc  # type: ignore
 except ImportError:
     TZ_UTC = UTC()  # type: ignore
 
 _FLATTEN = re.compile(r"(?<!\\)\.")
 
 
 def attribute_transformer(key, attr_desc, value):
@@ -286,84 +272,79 @@
 
 
 class Model(object):
     """Mixin for all client request body/response body models to support
     serialization and deserialization.
     """
 
-    _subtype_map: Dict[str, Dict[str, Any]] = {}
-    _attribute_map: Dict[str, Dict[str, Any]] = {}
-    _validation: Dict[str, Dict[str, Any]] = {}
+    _subtype_map = {}  # type: Dict[str, Dict[str, Any]]
+    _attribute_map = {}  # type: Dict[str, Dict[str, Any]]
+    _validation = {}  # type: Dict[str, Dict[str, Any]]
 
-    def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Dict[str, Any] = {}
+    def __init__(self, **kwargs):
+        self.additional_properties = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other: Any) -> bool:
+    def __eq__(self, other):
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other: Any) -> bool:
+    def __ne__(self, other):
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self) -> str:
+    def __str__(self):
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls) -> None:
+    def enable_additional_properties_sending(cls):
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls) -> bool:
+    def is_xml_model(cls):
         try:
-            cls._xml_map  # type: ignore
+            cls._xml_map
         except AttributeError:
             return False
         return True
 
     @classmethod
     def _create_xml_node(cls):
         """Create XML node."""
         try:
-            xml_map = cls._xml_map  # type: ignore
+            xml_map = cls._xml_map
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
+    def serialize(self, keep_readonly=False, **kwargs):
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(
-        self,
-        keep_readonly: bool = True,
-        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
-        **kwargs: Any
-    ) -> JSON:
-        """Return a dict that can be serialized using json.dump.
+    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
+        """Return a dict that can be JSONify using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -402,46 +383,41 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
+    def deserialize(cls, data, content_type=None):
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(
-        cls: Type[ModelType],
-        data: Any,
-        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
-        content_type: Optional[str] = None,
-    ) -> ModelType:
+    def from_dict(cls, data, key_extractors=None, content_type=None):
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (  # type: ignore
-            [  # type: ignore
+        deserializer.key_extractors = (
+            [
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -473,15 +449,15 @@
             if subtype_value:
                 # Try to match base class. Can be class name only
                 # (bug to fix in Autorest to support x-ms-discriminator-name)
                 if cls.__name__ == subtype_value:
                     return cls
                 flatten_mapping_type = cls._flatten_subtype(subtype_key, objects)
                 try:
-                    return objects[flatten_mapping_type[subtype_value]]  # type: ignore
+                    return objects[flatten_mapping_type[subtype_value]]
                 except KeyError:
                     _LOGGER.warning(
                         "Subtype value %s has no mapping, use base class %s.",
                         subtype_value,
                         cls.__name__,
                     )
                     break
@@ -541,15 +517,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -557,15 +533,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -625,46 +601,47 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
-                            serialized.set(xml_name, new_attr)  # type: ignore
+                                xml_name = "{}{}".format(xml_ns, xml_name)
+                            serialized.set(xml_name, new_attr)
                             continue
                         if xml_desc.get("text", False):
-                            serialized.text = new_attr  # type: ignore
+                            serialized.text = new_attr
                             continue
                         if isinstance(new_attr, list):
-                            serialized.extend(new_attr)  # type: ignore
+                            serialized.extend(new_attr)
                         elif isinstance(new_attr, ET.Element):
                             # If the down XML has no XML/Name, we MUST replace the tag with the local tag. But keeping the namespaces.
                             if "name" not in getattr(orig_attr, "_xml_map", {}):
                                 splitted_tag = new_attr.tag.split("}")
                                 if len(splitted_tag) == 2:  # Namespace
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
-                            serialized.append(new_attr)  # type: ignore
+                            serialized.append(new_attr)
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
-                            serialized.append(local_node)  # type: ignore
+                            serialized.append(local_node)
                     else:  # JSON
-                        for k in reversed(keys):  # type: ignore
-                            new_attr = {k: new_attr}
+                        for k in reversed(keys):
+                            unflattened = {k: new_attr}
+                            new_attr = unflattened
 
                         _new_attr = new_attr
                         _serialized = serialized
-                        for k in keys:  # type: ignore
+                        for k in keys:
                             if k not in _serialized:
-                                _serialized.update(_new_attr)  # type: ignore
-                            _new_attr = _new_attr[k]  # type: ignore
+                                _serialized.update(_new_attr)
+                            _new_attr = _new_attr[k]
                             _serialized = _serialized[k]
                 except ValueError:
                     continue
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
             raise_with_traceback(SerializationError, msg, err)
@@ -678,31 +655,31 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type_str = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type_str, None)
+        internal_data_type = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
         if internal_data_type and not isinstance(internal_data_type, Enum):
             try:
                 deserializer = Deserializer(self.dependencies)
                 # Since it's on serialization, it's almost sure that format is not JSON REST
                 # We're not able to deal with additional properties for now.
                 deserializer.additional_properties_detection = False
                 if is_xml_model_serialization:
-                    deserializer.key_extractors = [  # type: ignore
+                    deserializer.key_extractors = [
                         attribute_key_case_insensitive_extractor,
                     ]
                 else:
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
@@ -799,16 +776,14 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is AzureCoreNull:
-                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -864,15 +839,15 @@
         """
         try:  # If I received an enum, return its value
             return data.value
         except AttributeError:
             pass
 
         try:
-            if isinstance(data, unicode):  # type: ignore
+            if isinstance(data, unicode):
                 # Don't change it, JSON and XML ElementTree are totally able
                 # to serialize correctly u'' strings
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
@@ -1022,18 +997,18 @@
     @staticmethod
     def serialize_enum(attr, enum_obj=None):
         try:
             result = attr.value
         except AttributeError:
             result = attr
         try:
-            enum_obj(result)  # type: ignore
+            enum_obj(result)
             return result
         except ValueError:
-            for enum_value in enum_obj:  # type: ignore
+            for enum_value in enum_obj:
                 if enum_value.value.lower() == str(attr).lower():
                     return enum_value.value
             error = "{!r} is not valid value for enum {!r}"
             raise SerializationError(error.format(attr, enum_obj))
 
     @staticmethod
     def serialize_bytearray(attr, **kwargs):
@@ -1185,16 +1160,15 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        # Need the cast, as for some reasons "split" is typed as list[str | Any]
-        dict_keys = cast(List[str], _FLATTEN.split(key))
+        dict_keys = _FLATTEN.split(key)
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1267,15 +1241,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1291,15 +1265,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
+        xml_name = "{}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1357,15 +1331,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
+    def __init__(self, classes=None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1377,15 +1351,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
+        self.dependencies = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1438,15 +1412,15 @@
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
-            attributes = response._attribute_map  # type: ignore
+            attributes = response._attribute_map
             d_attrs = {}
             for attr, attr_desc in attributes.items():
                 # Check empty string. If it's not empty, someone has a real "additionalProperties"...
                 if attr == "additional_properties" and attr_desc["key"] == "":
                     continue
                 raw_value = None
                 # Enhance attr_desc with some dynamic data
@@ -1466,15 +1440,15 @@
                             _LOGGER.warning(msg, found_value, key_extractor, attr)
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
-            msg = "Unable to deserialize to object: " + class_name  # type: ignore
+            msg = "Unable to deserialize to object: " + class_name
             raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
@@ -1496,40 +1470,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__  # type: ignore
+        return target, target.__class__.__name__
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deserialize.
+        :param str/dict data: The response data to deseralize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
@@ -1565,15 +1539,15 @@
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
         if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
-            return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
+            return RawDeserializer.deserialize_from_text(raw_data, content_type)
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
         :param d_attrs: The deserialized response attributes.
@@ -1587,15 +1561,15 @@
                 response_obj = response(**kwargs)
                 for attr in readonly:
                     setattr(response_obj, attr, attrs.get(attr))
                 if additional_properties:
                     response_obj.additional_properties = additional_properties
                 return response_obj
             except TypeError as err:
-                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)  # type: ignore
+                msg = "Unable to deserialize {} into model {}. ".format(kwargs, response)
                 raise DeserializationError(msg + str(err))
         else:
             try:
                 for attr, value in attrs.items():
                     setattr(response, attr, value)
                 return response
             except Exception as exp:
@@ -1769,15 +1743,15 @@
         # We might be here because we have an enum modeled as string,
         # and we try to deserialize a partial dict with enum inside
         if isinstance(data, Enum):
             return data
 
         # Consider this is real string
         try:
-            if isinstance(data, unicode):  # type: ignore
+            if isinstance(data, unicode):
                 return data
         except NameError:
             return str(data)
         else:
             return str(data)
 
     @staticmethod
@@ -1820,58 +1794,58 @@
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return bytearray(b64decode(attr))  # type: ignore
+        return bytearray(b64decode(attr))
 
     @staticmethod
     def deserialize_base64(attr):
         """Deserialize base64 encoded string into string.
 
         :param str attr: response string to be deserialized.
         :rtype: bytearray
         :raises: TypeError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        padding = "=" * (3 - (len(attr) + 3) % 4)  # type: ignore
-        attr = attr + padding  # type: ignore
+        padding = "=" * (3 - (len(attr) + 3) % 4)
+        attr = attr + padding
         encoded = attr.replace("-", "+").replace("_", "/")
         return b64decode(encoded)
 
     @staticmethod
     def deserialize_decimal(attr):
         """Deserialize string into Decimal object.
 
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(attr)  # type: ignore
+            return decimal.Decimal(attr)
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
             raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
         :raises: ValueError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        return _long_type(attr)  # type: ignore
+        return _long_type(attr)
 
     @staticmethod
     def deserialize_duration(attr):
         """Deserialize ISO-8601 formatted string into TimeDelta object.
 
         :param str attr: response string to be deserialized.
         :rtype: TimeDelta
@@ -1893,45 +1867,45 @@
 
         :param str attr: response string to be deserialized.
         :rtype: Date
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
         return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
-        if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
+        if re.search(r"[^\W\d_]", attr, re.I + re.U):
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         return isodate.parse_time(attr)
 
     @staticmethod
     def deserialize_rfc(attr):
         """Deserialize RFC-1123 formatted string into Datetime object.
 
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            parsed_date = email.utils.parsedate_tz(attr)  # type: ignore
+            parsed_date = email.utils.parsedate_tz(attr)
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
@@ -1946,15 +1920,15 @@
         :param str attr: response string to be deserialized.
         :rtype: Datetime
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            attr = attr.upper()  # type: ignore
+            attr = attr.upper()
             match = Deserializer.valid_date.match(attr)
             if not match:
                 raise ValueError("Invalid datetime string: " + attr)
 
             check_decimal = attr.split(".")
             if len(check_decimal) > 1:
                 decimal_str = ""
@@ -1982,15 +1956,15 @@
         This is represented as seconds.
 
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
-            attr = int(attr.text)  # type: ignore
+            attr = int(attr.text)
         try:
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
             raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/__init__.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -26,15 +26,15 @@
 from ._models_py3 import VirtualNetworkLink
 from ._models_py3 import VirtualNetworkLinkListResult
 
 from ._private_dns_management_client_enums import ProvisioningState
 from ._private_dns_management_client_enums import RecordType
 from ._private_dns_management_client_enums import VirtualNetworkLinkState
 from ._patch import __all__ as _patch_all
-from ._patch import *  # pylint: disable=unused-wildcard-import
+from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "ARecord",
     "AaaaRecord",
     "CloudErrorBody",
     "CnameRecord",
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_private_dns_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_models_py3.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_models_py3.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from typing import Any, Dict, List, Optional, TYPE_CHECKING
+from typing import Dict, List, Optional, TYPE_CHECKING
 
 from .. import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -23,15 +23,15 @@
     :vartype ipv6_address: str
     """
 
     _attribute_map = {
         "ipv6_address": {"key": "ipv6Address", "type": "str"},
     }
 
-    def __init__(self, *, ipv6_address: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, ipv6_address: Optional[str] = None, **kwargs):
         """
         :keyword ipv6_address: The IPv6 address of this AAAA record.
         :paramtype ipv6_address: str
         """
         super().__init__(**kwargs)
         self.ipv6_address = ipv6_address
 
@@ -43,15 +43,15 @@
     :vartype ipv4_address: str
     """
 
     _attribute_map = {
         "ipv4_address": {"key": "ipv4Address", "type": "str"},
     }
 
-    def __init__(self, *, ipv4_address: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, ipv4_address: Optional[str] = None, **kwargs):
         """
         :keyword ipv4_address: The IPv4 address of this A record.
         :paramtype ipv4_address: str
         """
         super().__init__(**kwargs)
         self.ipv4_address = ipv4_address
 
@@ -82,16 +82,16 @@
     def __init__(
         self,
         *,
         code: Optional[str] = None,
         message: Optional[str] = None,
         target: Optional[str] = None,
         details: Optional[List["_models.CloudErrorBody"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword code: An identifier for the error. Codes are invariant and are intended to be consumed
          programmatically.
         :paramtype code: str
         :keyword message: A message describing the error, intended to be suitable for display in a user
          interface.
         :paramtype message: str
@@ -115,15 +115,15 @@
     :vartype cname: str
     """
 
     _attribute_map = {
         "cname": {"key": "cname", "type": "str"},
     }
 
-    def __init__(self, *, cname: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, cname: Optional[str] = None, **kwargs):
         """
         :keyword cname: The canonical name for this CNAME record.
         :paramtype cname: str
         """
         super().__init__(**kwargs)
         self.cname = cname
 
@@ -138,15 +138,15 @@
     """
 
     _attribute_map = {
         "preference": {"key": "preference", "type": "int"},
         "exchange": {"key": "exchange", "type": "str"},
     }
 
-    def __init__(self, *, preference: Optional[int] = None, exchange: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, preference: Optional[int] = None, exchange: Optional[str] = None, **kwargs):
         """
         :keyword preference: The preference value for this MX record.
         :paramtype preference: int
         :keyword exchange: The domain name of the mail host for this MX record.
         :paramtype exchange: str
         """
         super().__init__(**kwargs)
@@ -176,15 +176,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
@@ -216,15 +216,15 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
     }
 
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, location: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, location: Optional[str] = None, **kwargs):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The Azure Region where the resource lives.
         :paramtype location: str
         """
         super().__init__(**kwargs)
@@ -320,16 +320,16 @@
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
         etag: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The Azure Region where the resource lives.
         :paramtype location: str
         :keyword etag: The ETag of the zone.
         :paramtype etag: str
@@ -362,15 +362,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateZone]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateZone"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, value: Optional[List["_models.PrivateZone"]] = None, **kwargs):
         """
         :keyword value: Information about the Private DNS zones.
         :paramtype value: list[~azure.mgmt.privatedns.models.PrivateZone]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -398,15 +398,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs: Any) -> None:
+    def __init__(self, **kwargs):
         """ """
         super().__init__(**kwargs)
 
 
 class PtrRecord(_serialization.Model):
     """A PTR record.
 
@@ -414,26 +414,25 @@
     :vartype ptrdname: str
     """
 
     _attribute_map = {
         "ptrdname": {"key": "ptrdname", "type": "str"},
     }
 
-    def __init__(self, *, ptrdname: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, ptrdname: Optional[str] = None, **kwargs):
         """
         :keyword ptrdname: The PTR target domain name for this PTR record.
         :paramtype ptrdname: str
         """
         super().__init__(**kwargs)
         self.ptrdname = ptrdname
 
 
 class RecordSet(ProxyResource):  # pylint: disable=too-many-instance-attributes
-    """Describes a DNS record set (a collection of DNS records with the same name and type) in a
-    Private DNS zone.
+    """Describes a DNS record set (a collection of DNS records with the same name and type) in a Private DNS zone.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource Id for the resource. Example -
      '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateDnsZoneName}'.
     :vartype id: str
     :ivar name: The name of the resource.
@@ -506,16 +505,16 @@
         aaaa_records: Optional[List["_models.AaaaRecord"]] = None,
         cname_record: Optional["_models.CnameRecord"] = None,
         mx_records: Optional[List["_models.MxRecord"]] = None,
         ptr_records: Optional[List["_models.PtrRecord"]] = None,
         soa_record: Optional["_models.SoaRecord"] = None,
         srv_records: Optional[List["_models.SrvRecord"]] = None,
         txt_records: Optional[List["_models.TxtRecord"]] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword etag: The ETag of the record set.
         :paramtype etag: str
         :keyword metadata: The metadata attached to the record set.
         :paramtype metadata: dict[str, str]
         :keyword ttl: The TTL (time-to-live) of the records in the record set.
         :paramtype ttl: int
@@ -568,15 +567,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RecordSet]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.RecordSet"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, value: Optional[List["_models.RecordSet"]] = None, **kwargs):
         """
         :keyword value: Information about the record sets in the response.
         :paramtype value: list[~azure.mgmt.privatedns.models.RecordSet]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -618,16 +617,16 @@
         host: Optional[str] = None,
         email: Optional[str] = None,
         serial_number: Optional[int] = None,
         refresh_time: Optional[int] = None,
         retry_time: Optional[int] = None,
         expire_time: Optional[int] = None,
         minimum_ttl: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword host: The domain name of the authoritative name server for this SOA record.
         :paramtype host: str
         :keyword email: The email contact for this SOA record.
         :paramtype email: str
         :keyword serial_number: The serial number for this SOA record.
         :paramtype serial_number: int
@@ -674,16 +673,16 @@
     def __init__(
         self,
         *,
         priority: Optional[int] = None,
         weight: Optional[int] = None,
         port: Optional[int] = None,
         target: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword priority: The priority value for this SRV record.
         :paramtype priority: int
         :keyword weight: The weight value for this SRV record.
         :paramtype weight: int
         :keyword port: The port value for this SRV record.
         :paramtype port: int
@@ -704,15 +703,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -724,15 +723,15 @@
     :vartype value: list[str]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[str]"},
     }
 
-    def __init__(self, *, value: Optional[List[str]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, value: Optional[List[str]] = None, **kwargs):
         """
         :keyword value: The text value of this TXT record.
         :paramtype value: list[str]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -796,16 +795,16 @@
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
         etag: Optional[str] = None,
         virtual_network: Optional["_models.SubResource"] = None,
         registration_enabled: Optional[bool] = None,
-        **kwargs: Any
-    ) -> None:
+        **kwargs
+    ):
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The Azure Region where the resource lives.
         :paramtype location: str
         :keyword etag: The ETag of the virtual network link.
         :paramtype etag: str
@@ -839,15 +838,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[VirtualNetworkLink]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.VirtualNetworkLink"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, value: Optional[List["_models.VirtualNetworkLink"]] = None, **kwargs):
         """
         :keyword value: Information about the virtual network links to the Private DNS zones.
         :paramtype value: list[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/models/_patch.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/__init__.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,22 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._private_dns_management_client import PrivateDnsManagementClient
+from ._private_zones_operations import PrivateZonesOperations
+from ._virtual_network_links_operations import VirtualNetworkLinksOperations
+from ._record_sets_operations import RecordSetsOperations
 
-try:
-    from ._patch import __all__ as _patch_all
-    from ._patch import *  # pylint: disable=unused-wildcard-import
-except ImportError:
-    _patch_all = []
+from ._patch import __all__ as _patch_all
+from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
-    "PrivateDnsManagementClient",
+    "PrivateZonesOperations",
+    "VirtualNetworkLinksOperations",
+    "RecordSetsOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
-
 _patch_sdk()
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_private_dns_management_client.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_private_dns_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 
 from copy import deepcopy
 from typing import Any, Awaitable, TYPE_CHECKING
 
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
 
-from .. import models as _models
+from .. import models
 from .._serialization import Deserializer, Serializer
 from ._configuration import PrivateDnsManagementClientConfiguration
 from .operations import PrivateZonesOperations, RecordSetsOperations, VirtualNetworkLinksOperations
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
@@ -52,17 +52,17 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = PrivateDnsManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
-        client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
+        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.private_zones = PrivateZonesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.virtual_network_links = VirtualNetworkLinksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -93,9 +93,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "PrivateDnsManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details: Any) -> None:
+    async def __aexit__(self, *exc_details) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_configuration.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,22 +2,28 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class PrivateDnsManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for PrivateDnsManagementClient.
@@ -33,15 +39,15 @@
     :keyword api_version: Api Version. Default value is "2020-06-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(PrivateDnsManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2020-06-01")
+        api_version = kwargs.pop("api_version", "2020-06-01")  # type: Literal["2020-06-01"]
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/_patch.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/__init__.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 # --------------------------------------------------------------------------
 
 from ._private_zones_operations import PrivateZonesOperations
 from ._virtual_network_links_operations import VirtualNetworkLinksOperations
 from ._record_sets_operations import RecordSetsOperations
 
 from ._patch import __all__ as _patch_all
-from ._patch import *  # pylint: disable=unused-wildcard-import
+from ._patch import *  # type: ignore # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "PrivateZonesOperations",
     "VirtualNetworkLinksOperations",
     "RecordSetsOperations",
 ]
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_record_sets_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,14 +34,18 @@
     build_delete_request,
     build_get_request,
     build_list_by_type_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RecordSetsOperations:
     """
     .. warning::
@@ -174,16 +179,16 @@
         :param record_type: The type of DNS record in this record set. Record sets of type SOA can be
          updated but not created (they are created when the Private DNS zone is created). Known values
          are: "A", "AAAA", "CNAME", "MX", "PTR", "SOA", "SRV", and "TXT". Required.
         :type record_type: str or ~azure.mgmt.privatedns.models.RecordType
         :param relative_record_set_name: The name of the record set, relative to the name of the zone.
          Required.
         :type relative_record_set_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a RecordSet
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.RecordSet or IO
         :param if_match: The ETag of the record set. Omit this value to always overwrite the current
          record set. Specify the last-seen ETag value to prevent accidentally overwriting any concurrent
          changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new record set to be created, but to prevent
          updating an existing record set. Other values will be ignored. Default value is None.
@@ -203,17 +208,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -232,19 +239,18 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -252,21 +258,19 @@
         if response.status_code == 200:
             deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @overload
     async def update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -366,16 +370,16 @@
         :type private_zone_name: str
         :param record_type: The type of DNS record in this record set. Known values are: "A", "AAAA",
          "CNAME", "MX", "PTR", "SOA", "SRV", and "TXT". Required.
         :type record_type: str or ~azure.mgmt.privatedns.models.RecordType
         :param relative_record_set_name: The name of the record set, relative to the name of the zone.
          Required.
         :type relative_record_set_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a RecordSet type or a
-         IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.RecordSet or IO
         :param if_match: The ETag of the record set. Omit this value to always overwrite the current
          record set. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -392,17 +396,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -420,19 +426,18 @@
             json=_json,
             content=_content,
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -440,17 +445,15 @@
         deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -488,49 +491,48 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             record_type=record_type,
             relative_record_set_name=relative_record_set_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace_async
     async def get(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -562,34 +564,35 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             record_type=record_type,
             relative_record_set_name=relative_record_set_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -597,17 +600,15 @@
         deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace
     def list_by_type(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -636,16 +637,18 @@
         :return: An iterator like instance of either RecordSet or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.privatedns.models.RecordSet]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSetListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSetListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -663,15 +666,15 @@
                     recordsetnamesuffix=recordsetnamesuffix,
                     api_version=api_version,
                     template_url=self.list_by_type.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -679,45 +682,42 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RecordSetListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_type.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}"
-    }
+    list_by_type.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}"}  # type: ignore
 
     @distributed_trace
     def list(
         self,
         resource_group_name: str,
         private_zone_name: str,
         top: Optional[int] = None,
@@ -742,16 +742,18 @@
         :return: An iterator like instance of either RecordSet or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.privatedns.models.RecordSet]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSetListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSetListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -768,15 +770,15 @@
                     recordsetnamesuffix=recordsetnamesuffix,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -784,38 +786,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("RecordSetListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/ALL"
-    }
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/ALL"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_private_zones_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,14 +36,18 @@
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PrivateZonesOperations:
     """
     .. warning::
@@ -78,17 +83,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.PrivateZone]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.PrivateZone]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -105,19 +112,18 @@
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -130,17 +136,15 @@
             deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _create_or_update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: _models.PrivateZone,
@@ -244,16 +248,16 @@
         within the zone.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a PrivateZone
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.PrivateZone or IO
         :param if_match: The ETag of the Private DNS zone. Omit this value to always overwrite the
          current zone. Specify the last-seen ETag value to prevent accidentally overwriting any
          concurrent changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new Private DNS zone to be created, but to prevent
          updating an existing zone. Other values will be ignored. Default value is None.
@@ -273,22 +277,24 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = await self._create_or_update_initial(
+            raw_result = await self._create_or_update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 parameters=parameters,
                 if_match=if_match,
                 if_none_match=if_none_match,
                 api_version=api_version,
                 content_type=content_type,
@@ -302,31 +308,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateZone", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     async def _update_initial(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: Union[_models.PrivateZone, IO],
         if_match: Optional[str] = None,
@@ -339,17 +343,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.PrivateZone]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.PrivateZone]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -365,19 +371,18 @@
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -387,17 +392,15 @@
             deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: _models.PrivateZone,
@@ -492,16 +495,16 @@
         zone.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a PrivateZone type or
-         a IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.PrivateZone or IO
         :param if_match: The ETag of the Private DNS zone. Omit this value to always overwrite the
          current zone. Specify the last-seen ETag value to prevent accidentally overwriting any
          concurrent changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -518,22 +521,24 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = await self._update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 parameters=parameters,
                 if_match=if_match,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -546,31 +551,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateZone", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, private_zone_name: str, if_match: Optional[str] = None, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -578,47 +581,46 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _delete_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, private_zone_name: str, if_match: Optional[str] = None, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a Private DNS zone. WARNING: All DNS records in the zone will also be deleted. This
         operation cannot be undone. Private DNS zone cannot be deleted unless all virtual network links
@@ -644,19 +646,21 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 if_match=if_match,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
@@ -667,31 +671,29 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace_async
     async def get(self, resource_group_name: str, private_zone_name: str, **kwargs: Any) -> _models.PrivateZone:
         """Gets a Private DNS zone. Retrieves the zone properties, but not the virtual networks links or
         the record sets within the zone.
 
         :param resource_group_name: The name of the resource group. Required.
@@ -711,32 +713,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -744,17 +747,15 @@
         deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace
     def list(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.PrivateZone"]:
         """Lists the Private DNS zones in all resource groups in a subscription.
 
         :param top: The maximum number of Private DNS zones to return. If not specified, returns up to
          100 zones. Default value is None.
@@ -763,16 +764,18 @@
         :return: An iterator like instance of either PrivateZone or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZoneListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZoneListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -786,15 +789,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -802,43 +805,42 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("PrivateZoneListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateDnsZones"}
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateDnsZones"}  # type: ignore
 
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.PrivateZone"]:
         """Lists the Private DNS zones within a resource group.
 
@@ -851,16 +853,18 @@
         :return: An iterator like instance of either PrivateZone or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZoneListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZoneListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -875,15 +879,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -891,38 +895,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("PrivateZoneListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones"
-    }
+    list_by_resource_group.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_patch.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/aio/operations/_virtual_network_links_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,14 +35,18 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
     build_update_request,
 )
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class VirtualNetworkLinksOperations:
     """
     .. warning::
@@ -78,17 +83,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.VirtualNetworkLink]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.VirtualNetworkLink]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -106,19 +113,18 @@
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -131,17 +137,15 @@
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _create_or_update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -253,16 +257,16 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
         :param virtual_network_link_name: The name of the virtual network link. Required.
         :type virtual_network_link_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a
-         VirtualNetworkLink type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.VirtualNetworkLink or IO
         :param if_match: The ETag of the virtual network link to the Private DNS zone. Omit this value
          to always overwrite the current virtual network link. Specify the last-seen ETag value to
          prevent accidentally overwriting any concurrent changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new virtual network link to the Private DNS zone to
          be created, but to prevent updating an existing link. Other values will be ignored. Default
@@ -283,22 +287,24 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = await self._create_or_update_initial(
+            raw_result = await self._create_or_update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 parameters=parameters,
                 if_match=if_match,
                 if_none_match=if_none_match,
                 api_version=api_version,
@@ -313,31 +319,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     async def _update_initial(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
         parameters: Union[_models.VirtualNetworkLink, IO],
@@ -351,17 +355,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.VirtualNetworkLink]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.VirtualNetworkLink]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -378,19 +384,18 @@
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -400,17 +405,15 @@
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -511,16 +514,16 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
         :param virtual_network_link_name: The name of the virtual network link. Required.
         :type virtual_network_link_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a VirtualNetworkLink
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.VirtualNetworkLink or IO
         :param if_match: The ETag of the virtual network link to the Private DNS zone. Omit this value
          to always overwrite the current virtual network link. Specify the last-seen ETag value to
          prevent accidentally overwriting any concurrent changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -537,22 +540,24 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = await self._update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 parameters=parameters,
                 if_match=if_match,
                 api_version=api_version,
                 content_type=content_type,
@@ -566,31 +571,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
         if_match: Optional[str] = None,
@@ -603,48 +606,47 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             virtual_network_link_name=virtual_network_link_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _delete_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace_async
     async def begin_delete(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -677,19 +679,21 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, AsyncPollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 if_match=if_match,
                 api_version=api_version,
@@ -701,31 +705,29 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))  # type: AsyncPollingMethod
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, private_zone_name: str, virtual_network_link_name: str, **kwargs: Any
     ) -> _models.VirtualNetworkLink:
         """Gets a virtual network link to the specified Private DNS zone.
 
@@ -748,33 +750,34 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             virtual_network_link_name=virtual_network_link_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -782,17 +785,15 @@
         deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace
     def list(
         self, resource_group_name: str, private_zone_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.VirtualNetworkLink"]:
         """Lists the virtual network links to the specified Private DNS zone.
 
@@ -809,16 +810,18 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.VirtualNetworkLinkListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLinkListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -834,15 +837,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -850,38 +853,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLinkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks"
-    }
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_record_sets_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_record_sets_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -25,14 +26,18 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -46,16 +51,16 @@
     if_match: Optional[str] = None,
     if_none_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}",
     )  # pylint: disable=line-too-long
@@ -65,15 +70,15 @@
         "recordType": _SERIALIZER.url("record_type", record_type, "str"),
         "relativeRecordSetName": _SERIALIZER.url(
             "relative_record_set_name", relative_record_set_name, "str", skip_quote=True
         ),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -95,16 +100,16 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}",
     )  # pylint: disable=line-too-long
@@ -114,15 +119,15 @@
         "recordType": _SERIALIZER.url("record_type", record_type, "str"),
         "relativeRecordSetName": _SERIALIZER.url(
             "relative_record_set_name", relative_record_set_name, "str", skip_quote=True
         ),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -142,15 +147,15 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}",
     )  # pylint: disable=line-too-long
@@ -160,15 +165,15 @@
         "recordType": _SERIALIZER.url("record_type", record_type, "str"),
         "relativeRecordSetName": _SERIALIZER.url(
             "relative_record_set_name", relative_record_set_name, "str", skip_quote=True
         ),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -184,15 +189,15 @@
     relative_record_set_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}",
     )  # pylint: disable=line-too-long
@@ -202,15 +207,15 @@
         "recordType": _SERIALIZER.url("record_type", record_type, "str"),
         "relativeRecordSetName": _SERIALIZER.url(
             "relative_record_set_name", relative_record_set_name, "str", skip_quote=True
         ),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -226,30 +231,30 @@
     top: Optional[int] = None,
     recordsetnamesuffix: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "recordType": _SERIALIZER.url("record_type", record_type, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     if top is not None:
         _params["$top"] = _SERIALIZER.query("top", top, "int")
     if recordsetnamesuffix is not None:
         _params["$recordsetnamesuffix"] = _SERIALIZER.query("recordsetnamesuffix", recordsetnamesuffix, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -268,29 +273,29 @@
     top: Optional[int] = None,
     recordsetnamesuffix: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/ALL",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     if top is not None:
         _params["$top"] = _SERIALIZER.query("top", top, "int")
     if recordsetnamesuffix is not None:
         _params["$recordsetnamesuffix"] = _SERIALIZER.query("recordsetnamesuffix", recordsetnamesuffix, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -434,16 +439,16 @@
         :param record_type: The type of DNS record in this record set. Record sets of type SOA can be
          updated but not created (they are created when the Private DNS zone is created). Known values
          are: "A", "AAAA", "CNAME", "MX", "PTR", "SOA", "SRV", and "TXT". Required.
         :type record_type: str or ~azure.mgmt.privatedns.models.RecordType
         :param relative_record_set_name: The name of the record set, relative to the name of the zone.
          Required.
         :type relative_record_set_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a RecordSet
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.RecordSet or IO
         :param if_match: The ETag of the record set. Omit this value to always overwrite the current
          record set. Specify the last-seen ETag value to prevent accidentally overwriting any concurrent
          changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new record set to be created, but to prevent
          updating an existing record set. Other values will be ignored. Default value is None.
@@ -463,17 +468,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -492,19 +499,18 @@
             json=_json,
             content=_content,
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -512,21 +518,19 @@
         if response.status_code == 200:
             deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @overload
     def update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -626,16 +630,16 @@
         :type private_zone_name: str
         :param record_type: The type of DNS record in this record set. Known values are: "A", "AAAA",
          "CNAME", "MX", "PTR", "SOA", "SRV", and "TXT". Required.
         :type record_type: str or ~azure.mgmt.privatedns.models.RecordType
         :param relative_record_set_name: The name of the record set, relative to the name of the zone.
          Required.
         :type relative_record_set_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a RecordSet type or a
-         IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.RecordSet or IO
         :param if_match: The ETag of the record set. Omit this value to always overwrite the current
          record set. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -652,17 +656,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -680,19 +686,18 @@
             json=_json,
             content=_content,
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -700,17 +705,15 @@
         deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -748,49 +751,48 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             record_type=record_type,
             relative_record_set_name=relative_record_set_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace
     def get(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -822,34 +824,35 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSet] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSet]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             record_type=record_type,
             relative_record_set_name=relative_record_set_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -857,17 +860,15 @@
         deserialized = self._deserialize("RecordSet", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}/{relativeRecordSetName}"}  # type: ignore
 
     @distributed_trace
     def list_by_type(
         self,
         resource_group_name: str,
         private_zone_name: str,
         record_type: Union[str, _models.RecordType],
@@ -896,16 +897,18 @@
         :return: An iterator like instance of either RecordSet or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.privatedns.models.RecordSet]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSetListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSetListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -923,15 +926,15 @@
                     recordsetnamesuffix=recordsetnamesuffix,
                     api_version=api_version,
                     template_url=self.list_by_type.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -939,45 +942,42 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RecordSetListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_type.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}"
-    }
+    list_by_type.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/{recordType}"}  # type: ignore
 
     @distributed_trace
     def list(
         self,
         resource_group_name: str,
         private_zone_name: str,
         top: Optional[int] = None,
@@ -1002,16 +1002,18 @@
         :return: An iterator like instance of either RecordSet or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.privatedns.models.RecordSet]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RecordSetListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.RecordSetListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1028,15 +1030,15 @@
                     recordsetnamesuffix=recordsetnamesuffix,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1044,38 +1046,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("RecordSetListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/ALL"
-    }
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/ALL"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_private_zones_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_private_zones_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,14 +28,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -46,30 +51,30 @@
     if_match: Optional[str] = None,
     if_none_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -89,30 +94,30 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -130,29 +135,29 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -163,53 +168,53 @@
 
 def build_get_request(
     resource_group_name: str, private_zone_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, top: Optional[int] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateDnsZones")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     if top is not None:
         _params["$top"] = _SERIALIZER.query("top", top, "int")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -220,28 +225,28 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     if top is not None:
         _params["$top"] = _SERIALIZER.query("top", top, "int")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -285,17 +290,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.PrivateZone]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.PrivateZone]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -312,19 +319,18 @@
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -337,17 +343,15 @@
             deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _create_or_update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: _models.PrivateZone,
@@ -451,16 +455,16 @@
         within the zone.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a PrivateZone
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.PrivateZone or IO
         :param if_match: The ETag of the Private DNS zone. Omit this value to always overwrite the
          current zone. Specify the last-seen ETag value to prevent accidentally overwriting any
          concurrent changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new Private DNS zone to be created, but to prevent
          updating an existing zone. Other values will be ignored. Default value is None.
@@ -480,22 +484,24 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = self._create_or_update_initial(
+            raw_result = self._create_or_update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 parameters=parameters,
                 if_match=if_match,
                 if_none_match=if_none_match,
                 api_version=api_version,
                 content_type=content_type,
@@ -509,31 +515,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateZone", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     def _update_initial(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: Union[_models.PrivateZone, IO],
         if_match: Optional[str] = None,
@@ -546,17 +550,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.PrivateZone]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.PrivateZone]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -572,19 +578,18 @@
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -594,17 +599,15 @@
             deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         parameters: _models.PrivateZone,
@@ -699,16 +702,16 @@
         zone.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a PrivateZone type or
-         a IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.PrivateZone or IO
         :param if_match: The ETag of the Private DNS zone. Omit this value to always overwrite the
          current zone. Specify the last-seen ETag value to prevent accidentally overwriting any
          concurrent changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -725,22 +728,24 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = self._update_initial(
+            raw_result = self._update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 parameters=parameters,
                 if_match=if_match,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -753,31 +758,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateZone", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, private_zone_name: str, if_match: Optional[str] = None, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -785,47 +788,46 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    _delete_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, private_zone_name: str, if_match: Optional[str] = None, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a Private DNS zone. WARNING: All DNS records in the zone will also be deleted. This
         operation cannot be undone. Private DNS zone cannot be deleted unless all virtual network links
@@ -851,19 +853,21 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 if_match=if_match,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
@@ -874,31 +878,29 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    begin_delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace
     def get(self, resource_group_name: str, private_zone_name: str, **kwargs: Any) -> _models.PrivateZone:
         """Gets a Private DNS zone. Retrieves the zone properties, but not the virtual networks links or
         the record sets within the zone.
 
         :param resource_group_name: The name of the resource group. Required.
@@ -918,32 +920,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZone] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZone]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -951,17 +954,15 @@
         deserialized = self._deserialize("PrivateZone", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}"}  # type: ignore
 
     @distributed_trace
     def list(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.PrivateZone"]:
         """Lists the Private DNS zones in all resource groups in a subscription.
 
         :param top: The maximum number of Private DNS zones to return. If not specified, returns up to
          100 zones. Default value is None.
@@ -970,16 +971,18 @@
         :return: An iterator like instance of either PrivateZone or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZoneListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZoneListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -993,15 +996,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1009,43 +1012,42 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("PrivateZoneListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateDnsZones"}
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateDnsZones"}  # type: ignore
 
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.PrivateZone"]:
         """Lists the Private DNS zones within a resource group.
 
@@ -1058,16 +1060,18 @@
         :return: An iterator like instance of either PrivateZone or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.privatedns.models.PrivateZone]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.PrivateZoneListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.PrivateZoneListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1082,15 +1086,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1098,38 +1102,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("PrivateZoneListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones"
-    }
+    list_by_resource_group.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_patch.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py` & `azure-mgmt-privatedns-1.1.0b1/azure/mgmt/privatedns/operations/_virtual_network_links_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
+import sys
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -27,14 +28,18 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
+if sys.version_info >= (3, 8):
+    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
+else:
+    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -47,31 +52,31 @@
     if_match: Optional[str] = None,
     if_none_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "virtualNetworkLinkName": _SERIALIZER.url("virtual_network_link_name", virtual_network_link_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -92,31 +97,31 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
+    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "virtualNetworkLinkName": _SERIALIZER.url("virtual_network_link_name", virtual_network_link_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -135,30 +140,30 @@
     *,
     if_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "virtualNetworkLinkName": _SERIALIZER.url("virtual_network_link_name", virtual_network_link_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     if if_match is not None:
         _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
@@ -173,30 +178,30 @@
     virtual_network_link_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "virtualNetworkLinkName": _SERIALIZER.url("virtual_network_link_name", virtual_network_link_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
@@ -205,29 +210,29 @@
 
 def build_list_request(
     resource_group_name: str, private_zone_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))
+    api_version = kwargs.pop("api_version", _params.pop("api-version", "2020-06-01"))  # type: Literal["2020-06-01"]
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
         "privateZoneName": _SERIALIZER.url("private_zone_name", private_zone_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = _format_url_section(_url, **path_format_arguments)
 
     # Construct parameters
     if top is not None:
         _params["$top"] = _SERIALIZER.query("top", top, "int")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
@@ -272,17 +277,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.VirtualNetworkLink]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.VirtualNetworkLink]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -300,19 +307,18 @@
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -325,17 +331,15 @@
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _create_or_update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -447,16 +451,16 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
         :param virtual_network_link_name: The name of the virtual network link. Required.
         :type virtual_network_link_name: str
-        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a
-         VirtualNetworkLink type or a IO type. Required.
+        :param parameters: Parameters supplied to the CreateOrUpdate operation. Is either a model type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.VirtualNetworkLink or IO
         :param if_match: The ETag of the virtual network link to the Private DNS zone. Omit this value
          to always overwrite the current virtual network link. Specify the last-seen ETag value to
          prevent accidentally overwriting any concurrent changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new virtual network link to the Private DNS zone to
          be created, but to prevent updating an existing link. Other values will be ignored. Default
@@ -477,22 +481,24 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = self._create_or_update_initial(
+            raw_result = self._create_or_update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 parameters=parameters,
                 if_match=if_match,
                 if_none_match=if_none_match,
                 api_version=api_version,
@@ -507,31 +513,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_create_or_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     def _update_initial(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
         parameters: Union[_models.VirtualNetworkLink, IO],
@@ -545,17 +549,19 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.VirtualNetworkLink]] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.VirtualNetworkLink]]
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
@@ -572,19 +578,18 @@
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -594,17 +599,15 @@
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _update_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -705,16 +708,16 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param private_zone_name: The name of the Private DNS zone (without a terminating dot).
          Required.
         :type private_zone_name: str
         :param virtual_network_link_name: The name of the virtual network link. Required.
         :type virtual_network_link_name: str
-        :param parameters: Parameters supplied to the Update operation. Is either a VirtualNetworkLink
-         type or a IO type. Required.
+        :param parameters: Parameters supplied to the Update operation. Is either a model type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.privatedns.models.VirtualNetworkLink or IO
         :param if_match: The ETag of the virtual network link to the Private DNS zone. Omit this value
          to always overwrite the current virtual network link. Specify the last-seen ETag value to
          prevent accidentally overwriting any concurrent changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -731,22 +734,24 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
-            raw_result = self._update_initial(
+            raw_result = self._update_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 parameters=parameters,
                 if_match=if_match,
                 api_version=api_version,
                 content_type=content_type,
@@ -760,31 +765,29 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_update.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
         if_match: Optional[str] = None,
@@ -797,48 +800,47 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             virtual_network_link_name=virtual_network_link_name,
             subscription_id=self._config.subscription_id,
             if_match=if_match,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    _delete_initial.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace
     def begin_delete(
         self,
         resource_group_name: str,
         private_zone_name: str,
         virtual_network_link_name: str,
@@ -871,19 +873,21 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[None]
+        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 private_zone_name=private_zone_name,
                 virtual_network_link_name=virtual_network_link_name,
                 if_match=if_match,
                 api_version=api_version,
@@ -895,31 +899,29 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))  # type: PollingMethod
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
 
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    begin_delete.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace
     def get(
         self, resource_group_name: str, private_zone_name: str, virtual_network_link_name: str, **kwargs: Any
     ) -> _models.VirtualNetworkLink:
         """Gets a virtual network link to the specified Private DNS zone.
 
@@ -942,33 +944,34 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.VirtualNetworkLink] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLink]
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             private_zone_name=private_zone_name,
             virtual_network_link_name=virtual_network_link_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+        request.url = self._client.format_url(request.url)  # type: ignore
 
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
+        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+            request, stream=False, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -976,17 +979,15 @@
         deserialized = self._deserialize("VirtualNetworkLink", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"
-    }
+    get.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks/{virtualNetworkLinkName}"}  # type: ignore
 
     @distributed_trace
     def list(
         self, resource_group_name: str, private_zone_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.VirtualNetworkLink"]:
         """Lists the virtual network links to the specified Private DNS zone.
 
@@ -1002,16 +1003,18 @@
         :return: An iterator like instance of either VirtualNetworkLink or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.privatedns.models.VirtualNetworkLink]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.VirtualNetworkLinkListResult] = kwargs.pop("cls", None)
+        api_version = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )  # type: Literal["2020-06-01"]
+        cls = kwargs.pop("cls", None)  # type: ClsType[_models.VirtualNetworkLinkListResult]
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1027,15 +1030,15 @@
                     top=top,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
@@ -1043,38 +1046,35 @@
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
                 request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+                request.url = self._client.format_url(request.url)  # type: ignore
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("VirtualNetworkLinkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
+                list_of_elem = cls(list_of_elem)
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
+                request, stream=False, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks"
-    }
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateDnsZones/{privateZoneName}/virtualNetworkLinks"}  # type: ignore
```

## Comparing `azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/SOURCES.txt` & `azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-privatedns-1.1.0/azure_mgmt_privatedns.egg-info/PKG-INFO` & `azure-mgmt-privatedns-1.1.0b1/azure_mgmt_privatedns.egg-info/PKG-INFO`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-privatedns
-Version: 1.1.0
+Version: 1.1.0b1
 Summary: Microsoft Azure DNS Private Zones Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: MIT License
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # Microsoft Azure SDK for Python
 
@@ -27,78 +26,36 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-## Getting started
+# Usage
 
-### Prerequisites
 
-- Python 3.7+ is required to use this package.
-- [Azure subscription](https://azure.microsoft.com/free/)
+To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
+ 
+For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
+Code samples for this package can be found at [DNS Private Zones](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
+Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
-### Install the package
 
-```bash
-pip install azure-mgmt-privatedns
-pip install azure-identity
-```
-
-### Authentication
-
-By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
-
-- `AZURE_CLIENT_ID` for Azure client ID.
-- `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` for Azure client secret.
-
-In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
-
-With above configuration, client can be authenticated by following code:
-
-```python
-from azure.identity import DefaultAzureCredential
-from azure.mgmt.privatedns import PrivateDnsManagementClient
-import os
-
-sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = PrivateDnsManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
-```
-
-## Examples
-
-Code samples for this package can be found at:
-- [Search DNS Private Zones](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
-- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
-
-
-## Troubleshooting
-
-## Next steps
-
-## Provide Feedback
+# Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-privatedns%2FREADME.png)
 
 
 # Release History
 
-## 1.1.0 (2023-05-20)
-
-### Features Added
-
-  - Model PrivateZone has a new parameter internal_id
-
 ## 1.1.0b1 (2022-10-28)
 
 ### Features Added
 
   - Model PrivateZone has a new parameter internal_id
 
 ## 1.0.0 (2021-03-25)
```

