# Comparing `tmp/finlab-0.4.2-cp39-cp39-win_amd64.whl.zip` & `tmp/finlab-0.4.3-cp310-cp310-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,48 +1,56 @@
-Zip file size: 393118 bytes, number of entries: 46
--rw-rw-rw-  2.0 fat     2450 b- defN 23-Apr-26 14:01 finlab/__init__.py
--rw-rw-rw-  2.0 fat   206848 b- defN 23-Apr-26 14:06 finlab/aes.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    22767 b- defN 23-Apr-26 14:01 finlab/backtest.py
--rw-rw-rw-  2.0 fat   133120 b- defN 23-Apr-26 14:06 finlab/backtest_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1424 b- defN 23-Apr-26 14:01 finlab/backtest_old.py
--rw-rw-rw-  2.0 fat      915 b- defN 23-Apr-26 14:01 finlab/cells.py
--rw-rw-rw-  2.0 fat    29089 b- defN 23-Apr-26 14:01 finlab/data.py
--rw-rw-rw-  2.0 fat    29113 b- defN 23-Apr-26 14:01 finlab/dataframe.py
--rw-rw-rw-  2.0 fat    80750 b- defN 23-Apr-26 14:01 finlab/ffn_core.py
--rw-rw-rw-  2.0 fat    71680 b- defN 23-Apr-26 14:06 finlab/mae_mfe.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      460 b- defN 23-Apr-26 14:01 finlab/mae_mfe.pxd
--rw-rw-rw-  2.0 fat     5105 b- defN 23-Apr-26 14:01 finlab/market_info.py
--rw-rw-rw-  2.0 fat    36257 b- defN 23-Apr-26 14:01 finlab/plot.py
--rw-rw-rw-  2.0 fat   167424 b- defN 23-Apr-26 14:06 finlab/report.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     5132 b- defN 23-Apr-26 14:01 finlab/utils.py
--rw-rw-rw-  2.0 fat    19968 b- defN 23-Apr-26 14:06 finlab/utils_core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     7287 b- defN 23-Apr-26 14:01 finlab/analysis/__init__.py
--rw-rw-rw-  2.0 fat     1988 b- defN 23-Apr-26 14:01 finlab/analysis/alphaBetaAnalysis.py
--rw-rw-rw-  2.0 fat     1449 b- defN 23-Apr-26 14:01 finlab/analysis/drawdownAnalysis.py
--rw-rw-rw-  2.0 fat     5007 b- defN 23-Apr-26 14:01 finlab/analysis/inequalityAnalysis.py
--rw-rw-rw-  2.0 fat     4626 b- defN 23-Apr-26 14:01 finlab/analysis/liquidityAnalysis.py
--rw-rw-rw-  2.0 fat    12343 b- defN 23-Apr-26 14:01 finlab/analysis/maeMfeAnalysis.py
--rw-rw-rw-  2.0 fat     3618 b- defN 23-Apr-26 14:01 finlab/analysis/periodStatsAnalysis.py
--rw-rw-rw-  2.0 fat      704 b- defN 23-Apr-26 14:01 finlab/ml/__init__.py
--rw-rw-rw-  2.0 fat     3879 b- defN 23-Apr-26 14:01 finlab/ml/alphalens.py
--rw-rw-rw-  2.0 fat    15609 b- defN 23-Apr-26 14:01 finlab/ml/feature.py
--rw-rw-rw-  2.0 fat     2559 b- defN 23-Apr-26 14:01 finlab/ml/label.py
--rw-rw-rw-  2.0 fat    18065 b- defN 23-Apr-26 14:01 finlab/ml/qlib.py
--rw-rw-rw-  2.0 fat     3131 b- defN 23-Apr-26 14:01 finlab/ml/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-26 14:01 finlab/online/__init__.py
--rw-rw-rw-  2.0 fat     8155 b- defN 23-Apr-26 14:01 finlab/online/base_account.py
--rw-rw-rw-  2.0 fat    12766 b- defN 23-Apr-26 14:01 finlab/online/binance_account.py
--rw-rw-rw-  2.0 fat     7264 b- defN 23-Apr-26 14:01 finlab/online/dashboard.py
--rw-rw-rw-  2.0 fat      263 b- defN 23-Apr-26 14:01 finlab/online/enums.py
--rw-rw-rw-  2.0 fat    12844 b- defN 23-Apr-26 14:01 finlab/online/fugle_account.py
--rw-rw-rw-  2.0 fat    17131 b- defN 23-Apr-26 14:01 finlab/online/order_executor.py
--rw-rw-rw-  2.0 fat    13122 b- defN 23-Apr-26 14:01 finlab/online/panel.py
--rw-rw-rw-  2.0 fat     8537 b- defN 23-Apr-26 14:01 finlab/online/sinopac_account.py
--rw-rw-rw-  2.0 fat     5432 b- defN 23-Apr-26 14:01 finlab/online/utils.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-26 14:01 finlab/optimize/__init__.py
--rw-rw-rw-  2.0 fat     8815 b- defN 23-Apr-26 14:01 finlab/optimize/combinations.py
--rw-rw-rw-  2.0 fat    35823 b- defN 23-Apr-26 14:06 finlab-0.4.2.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3879 b- defN 23-Apr-26 14:06 finlab-0.4.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-26 14:06 finlab-0.4.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Apr-26 14:06 finlab-0.4.2.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3777 b- defN 23-Apr-26 14:06 finlab-0.4.2.dist-info/RECORD
-46 files, 1030682 bytes uncompressed, 387196 bytes compressed:  62.4%
+Zip file size: 409710 bytes, number of entries: 54
+-rw-rw-rw-  2.0 fat     2507 b- defN 23-May-22 09:19 finlab/__init__.py
+-rw-rw-rw-  2.0 fat    22853 b- defN 23-May-22 09:19 finlab/backtest.py
+-rw-rw-rw-  2.0 fat     1424 b- defN 23-May-22 09:19 finlab/backtest_old.py
+-rw-rw-rw-  2.0 fat      915 b- defN 23-May-22 09:19 finlab/cells.py
+-rw-rw-rw-  2.0 fat    29964 b- defN 23-May-22 09:19 finlab/data.py
+-rw-rw-rw-  2.0 fat    30989 b- defN 23-May-22 09:19 finlab/dataframe.py
+-rw-rw-rw-  2.0 fat    80750 b- defN 23-May-22 09:19 finlab/ffn_core.py
+-rw-rw-rw-  2.0 fat     6284 b- defN 23-May-22 09:19 finlab/market_info.py
+-rw-rw-rw-  2.0 fat    36257 b- defN 23-May-22 09:19 finlab/plot.py
+-rw-rw-rw-  2.0 fat     5246 b- defN 23-May-22 09:19 finlab/utils.py
+-rw-rw-rw-  2.0 fat     7316 b- defN 23-May-22 09:19 finlab/analysis/__init__.py
+-rw-rw-rw-  2.0 fat     2110 b- defN 23-May-22 09:19 finlab/analysis/alphaBetaAnalysis.py
+-rw-rw-rw-  2.0 fat     1449 b- defN 23-May-22 09:19 finlab/analysis/drawdownAnalysis.py
+-rw-rw-rw-  2.0 fat     5007 b- defN 23-May-22 09:19 finlab/analysis/inequalityAnalysis.py
+-rw-rw-rw-  2.0 fat     4735 b- defN 23-May-22 09:19 finlab/analysis/liquidityAnalysis.py
+-rw-rw-rw-  2.0 fat    12329 b- defN 23-May-22 09:19 finlab/analysis/maeMfeAnalysis.py
+-rw-rw-rw-  2.0 fat     7481 b- defN 23-May-22 09:19 finlab/analysis/periodStatsAnalysis.py
+-rw-rw-rw-  2.0 fat        2 b- defN 23-May-22 09:19 finlab/core/__init__.py
+-rw-rw-rw-  2.0 fat   196608 b- defN 23-May-22 09:25 finlab/core/aes.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    19593 b- defN 23-May-22 09:19 finlab/core/aes.pyx
+-rw-rw-rw-  2.0 fat   131584 b- defN 23-May-22 09:25 finlab/core/backtest_core.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    18552 b- defN 23-May-22 09:19 finlab/core/backtest_core.pyx
+-rw-rw-rw-  2.0 fat    71168 b- defN 23-May-22 09:25 finlab/core/mae_mfe.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      485 b- defN 23-May-22 09:19 finlab/core/mae_mfe.pxd
+-rw-rw-rw-  2.0 fat     6119 b- defN 23-May-22 09:19 finlab/core/mae_mfe.pyx
+-rw-rw-rw-  2.0 fat   166400 b- defN 23-May-22 09:25 finlab/core/report.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    19675 b- defN 23-May-22 09:19 finlab/core/report.pyx
+-rw-rw-rw-  2.0 fat    18944 b- defN 23-May-22 09:25 finlab/core/utils_core.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat       88 b- defN 23-May-22 09:19 finlab/core/utils_core.pyx
+-rw-rw-rw-  2.0 fat      704 b- defN 23-May-22 09:19 finlab/ml/__init__.py
+-rw-rw-rw-  2.0 fat     3912 b- defN 23-May-22 09:19 finlab/ml/alphalens.py
+-rw-rw-rw-  2.0 fat     5160 b- defN 23-May-22 09:19 finlab/ml/cpcv.py
+-rw-rw-rw-  2.0 fat    14448 b- defN 23-May-22 09:19 finlab/ml/feature.py
+-rw-rw-rw-  2.0 fat     5180 b- defN 23-May-22 09:19 finlab/ml/label.py
+-rw-rw-rw-  2.0 fat    18071 b- defN 23-May-22 09:19 finlab/ml/qlib.py
+-rw-rw-rw-  2.0 fat     3131 b- defN 23-May-22 09:19 finlab/ml/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-22 09:19 finlab/online/__init__.py
+-rw-rw-rw-  2.0 fat     8155 b- defN 23-May-22 09:19 finlab/online/base_account.py
+-rw-rw-rw-  2.0 fat    12766 b- defN 23-May-22 09:19 finlab/online/binance_account.py
+-rw-rw-rw-  2.0 fat     7264 b- defN 23-May-22 09:19 finlab/online/dashboard.py
+-rw-rw-rw-  2.0 fat      263 b- defN 23-May-22 09:19 finlab/online/enums.py
+-rw-rw-rw-  2.0 fat    12844 b- defN 23-May-22 09:19 finlab/online/fugle_account.py
+-rw-rw-rw-  2.0 fat    17131 b- defN 23-May-22 09:19 finlab/online/order_executor.py
+-rw-rw-rw-  2.0 fat    13122 b- defN 23-May-22 09:19 finlab/online/panel.py
+-rw-rw-rw-  2.0 fat     8674 b- defN 23-May-22 09:19 finlab/online/sinopac_account.py
+-rw-rw-rw-  2.0 fat     3158 b- defN 23-May-22 09:19 finlab/online/test.py
+-rw-rw-rw-  2.0 fat     5303 b- defN 23-May-22 09:19 finlab/online/utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-22 09:19 finlab/optimize/__init__.py
+-rw-rw-rw-  2.0 fat     9160 b- defN 23-May-22 09:19 finlab/optimize/combinations.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-May-22 09:25 finlab-0.4.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3879 b- defN 23-May-22 09:25 finlab-0.4.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 23-May-22 09:25 finlab-0.4.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-May-22 09:25 finlab-0.4.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     4446 b- defN 23-May-22 09:25 finlab-0.4.3.dist-info/RECORD
+54 files, 1099537 bytes uncompressed, 402750 bytes compressed:  63.4%
```

## zipnote {}

```diff
@@ -1,19 +1,13 @@
 Filename: finlab/__init__.py
 Comment: 
 
-Filename: finlab/aes.cp39-win_amd64.pyd
-Comment: 
-
 Filename: finlab/backtest.py
 Comment: 
 
-Filename: finlab/backtest_core.cp39-win_amd64.pyd
-Comment: 
-
 Filename: finlab/backtest_old.py
 Comment: 
 
 Filename: finlab/cells.py
 Comment: 
 
 Filename: finlab/data.py
@@ -21,35 +15,23 @@
 
 Filename: finlab/dataframe.py
 Comment: 
 
 Filename: finlab/ffn_core.py
 Comment: 
 
-Filename: finlab/mae_mfe.cp39-win_amd64.pyd
-Comment: 
-
-Filename: finlab/mae_mfe.pxd
-Comment: 
-
 Filename: finlab/market_info.py
 Comment: 
 
 Filename: finlab/plot.py
 Comment: 
 
-Filename: finlab/report.cp39-win_amd64.pyd
-Comment: 
-
 Filename: finlab/utils.py
 Comment: 
 
-Filename: finlab/utils_core.cp39-win_amd64.pyd
-Comment: 
-
 Filename: finlab/analysis/__init__.py
 Comment: 
 
 Filename: finlab/analysis/alphaBetaAnalysis.py
 Comment: 
 
 Filename: finlab/analysis/drawdownAnalysis.py
@@ -63,20 +45,59 @@
 
 Filename: finlab/analysis/maeMfeAnalysis.py
 Comment: 
 
 Filename: finlab/analysis/periodStatsAnalysis.py
 Comment: 
 
+Filename: finlab/core/__init__.py
+Comment: 
+
+Filename: finlab/core/aes.cp310-win_amd64.pyd
+Comment: 
+
+Filename: finlab/core/aes.pyx
+Comment: 
+
+Filename: finlab/core/backtest_core.cp310-win_amd64.pyd
+Comment: 
+
+Filename: finlab/core/backtest_core.pyx
+Comment: 
+
+Filename: finlab/core/mae_mfe.cp310-win_amd64.pyd
+Comment: 
+
+Filename: finlab/core/mae_mfe.pxd
+Comment: 
+
+Filename: finlab/core/mae_mfe.pyx
+Comment: 
+
+Filename: finlab/core/report.cp310-win_amd64.pyd
+Comment: 
+
+Filename: finlab/core/report.pyx
+Comment: 
+
+Filename: finlab/core/utils_core.cp310-win_amd64.pyd
+Comment: 
+
+Filename: finlab/core/utils_core.pyx
+Comment: 
+
 Filename: finlab/ml/__init__.py
 Comment: 
 
 Filename: finlab/ml/alphalens.py
 Comment: 
 
+Filename: finlab/ml/cpcv.py
+Comment: 
+
 Filename: finlab/ml/feature.py
 Comment: 
 
 Filename: finlab/ml/label.py
 Comment: 
 
 Filename: finlab/ml/qlib.py
@@ -108,32 +129,35 @@
 
 Filename: finlab/online/panel.py
 Comment: 
 
 Filename: finlab/online/sinopac_account.py
 Comment: 
 
+Filename: finlab/online/test.py
+Comment: 
+
 Filename: finlab/online/utils.py
 Comment: 
 
 Filename: finlab/optimize/__init__.py
 Comment: 
 
 Filename: finlab/optimize/combinations.py
 Comment: 
 
-Filename: finlab-0.4.2.dist-info/LICENSE
+Filename: finlab-0.4.3.dist-info/LICENSE
 Comment: 
 
-Filename: finlab-0.4.2.dist-info/METADATA
+Filename: finlab-0.4.3.dist-info/METADATA
 Comment: 
 
-Filename: finlab-0.4.2.dist-info/WHEEL
+Filename: finlab-0.4.3.dist-info/WHEEL
 Comment: 
 
-Filename: finlab-0.4.2.dist-info/top_level.txt
+Filename: finlab-0.4.3.dist-info/top_level.txt
 Comment: 
 
-Filename: finlab-0.4.2.dist-info/RECORD
+Filename: finlab-0.4.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## finlab/__init__.py

```diff
@@ -7,15 +7,15 @@
 from getpass import getpass
 
 
 # Get an instance of a logger
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
-__version__ = '0.4.2'
+__version__ = '0.4.3'
 
 
 class LoginPanel():
 
     def __init__(self):
         pass
 
@@ -41,21 +41,22 @@
 
     def display_text_input(self):
         print('請從 https://ai.finlab.tw/api_token 複製驗證碼:\n')
         token = getpass('驗證碼：')
         self.login(token)
         print('之後可以使用以下方法自動登入')
         print('import finlab')
-        print('finlab.login("YOUR APITOKEN")')
+        print('finlab.login("YOUR API TOKEN")')
 
     @staticmethod
     def login(token):
         # set token
         token = token[:64]
         os.environ['finlab_id_token'] = token
+        os.environ['FINLAB_API_TOKEN'] = token
         print('輸入成功!')
 
 
 def login(api_token=None):
     """登錄量化平台。
 
     可以至 [api_token查詢頁面](https://ai.finlab.tw/api_token/) 獲取api_token，傳入函數後執行登錄動作。
@@ -79,13 +80,13 @@
 
 def get_token():
     """取得登錄會員的finlab_id。
 
     若未登錄過，會跳出登錄頁面請求登錄。
 
     Returns:
-        (str): finlab_id_token
+        (str): finlab api token
     """
-    if 'finlab_id_token' not in os.environ:
+    if 'FINLAB_API_TOKEN' not in os.environ:
         login()
 
-    return os.environ['finlab_id_token']
+    return os.environ['FINLAB_API_TOKEN'][:64]
```

## finlab/backtest.py

```diff
@@ -3,18 +3,20 @@
 import numpy as np
 import pandas as pd
 from typing import Union
 from pandas.tseries.offsets import DateOffset
 from pandas.tseries.frequencies import to_offset
 
 import finlab
-from finlab import data, market_info, report
-from finlab import mae_mfe as maemfe
+from finlab.market_info import get_market_info
+from finlab import data, market_info
+from finlab.core import mae_mfe as maemfe
+from finlab.core import report
 from finlab.utils import check_version, requests, set_global
-from finlab.backtest_core import backtest_, get_trade_stocks
+from finlab.core.backtest_core import backtest_, get_trade_stocks
 from finlab.dataframe import FinlabDataFrame
 
 def warning_resample(resample):
 
   if '+' not in resample and '-' not in resample:
       return
 
@@ -93,26 +95,26 @@
 
 def sim(position: Union[pd.DataFrame, pd.Series],
         resample:Union[str, None]=None, resample_offset:Union[str, None] = None,
         trade_at_price: Union[str, pd.DataFrame] = 'close',
         position_limit:float=1, fee_ratio:float=1.425/1000,
         tax_ratio: float=3/1000, name:str='未命名', stop_loss: Union[float, None]=None,
         take_profit: Union[float, None]=None, touched_exit: bool=False,
-        retain_cost_when_rebalance: bool=False, live_performance_start:Union[str, None]=None,
-        mae_mfe_window:int=0, mae_mfe_window_step:int=1, market:Union[str, market_info.MarketInfo]='AUTO', upload:bool=True):
+        retain_cost_when_rebalance: bool=False, stop_trading_next_period: bool=True, live_performance_start:Union[str, None]=None,
+        mae_mfe_window:int=0, mae_mfe_window_step:int=1, market:Union[str, market_info.MarketInfo]='AUTO', upload:bool=True) -> report.Report:
 
     """Simulate the equity given the stock position history. 回測模擬股票部位所產生的淨值報酬率。
 
     Args:
 
-        position (pd.DataFrame or pd.Series): Dataframe of the stock market position where index is date and columns are stock_id. Each row represents a stock portfolio, where the values are perentages. Negative values represent short position. If any sum of row is larger than 1, the normalization is perform, i.e., (1, 2) becomes (0.33, 0.66).
+        position (pd.DataFrame or pd.Series):
 
             買賣訊號紀錄。True 為持有， False 為空手。 若選擇做空position，只要將 sim(position) 改成負的 sim(-position.astype(float))即可做空。
 
-        resample (str or None): rebalance position only on specified frequency.
+        resample (str or None):
 
             交易週期。將 position 的訊號以週期性的方式論動股票，預設為每天換股。其他常用數值為 W、 M 、 Q （每週、每月、每季換股一次），也可以使用 W-Fri 在週五的時候產生新的股票清單，並且於下週交易日下單。
             - `D`: Daily
             - `W`: Weekly
             - `W-Wed`: Every Wednesday
             - `M`: Monthly
             - `MS`: Start of every month
@@ -122,40 +124,42 @@
             - `QE`: End of every quarter
             !!!note
                 'D'與'None'的差別？
                 resample='D' 的意義為每天隨股價變化做再平衡，就算當天股票清單沒變，但股票漲跌後，部位大小會變化，而 resample='D' 會強制再平衡，平均分散風險。
 
                 但是當 resample=None 的話，假如清單不變，則不會強制再平衡，只有清單改變時，才做再平衡。適用情境在較常選到大波段標的的趨勢策略，較有機會將強勢股留下，而不會汰強留弱做再平衡。
 
-        resample_offset (str or None): add time offset to resample the position.
+        resample_offset (str or None):
             交易週期的時間位移，例如。
 
             - '1D': 位移一天
             - '1H': 位移一小時
-        trade_at_price (str or pd.DataFrame): rebalance on market 'close' or 'open'.
-
+        trade_at_price (str or pd.DataFrame):
             選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'或'open'。
-        position_limit (float): maximum amount of investing a stock.
 
+        position_limit (float): maximum amount of investing a stock.
             單檔標的持股比例上限，控制倉位風險。預設為None。範例：0.2，代表單檔標的最多持有 20 % 部位。
-        fee_ratio (float): fee ratio of buying or selling a stock.
 
+        fee_ratio (float): fee ratio of buying or selling a stock.
             交易手續費率，預設為台灣無打折手續費 0.001425。可視個人使用的券商優惠調整費率。
-        tax_ratio (float): tax ratio of selling a stock.
 
+        tax_ratio (float): tax ratio of selling a stock.
             交易稅率，預設為台灣普通股一般交易交易稅率 0.003。若交易策略的標的皆為ETF，記得設成 0.001。
-        name (str): name of the strategy.
 
+        name (str): name of the strategy.
             策略名稱，預設為 未指名。策略名稱。相同名稱之策略上傳會覆寫。命名規則:全英文或開頭中文，不接受開頭英文接中文。
-        stop_loss (float): exit when stock return smaller than a specific amount. i.e., 0.2 means -20%
+
+        stop_loss (float):
             停損基準，預設為None，不執行停損。範例：0.1，代表從再平衡開始，虧損 10% 時產生出場訊號。
-        take_profit (float): exit when stock return larger than a specific amount. i.e., 0.3 means +30%
+
+        take_profit (float):
             停利基準，預設為None，不執行停利。範例：0.1，代表從再平衡開始， 10% 時產生出場訊號。
-        touched_exit (bool): `True`: exit immediately whenever stop loss or take profit price is touched. `False`: exit tomorrow if the price touches stop loss or take profit. 是否在回測時，使用觸價停損停利？
-        retain_cost_when_rebalance (bool): 預設回測時，會將進場股票進場成本更新到到新的 rebalance 的當天價格，假如希望保留原本的進場價格當成停損停利的依據，可以設定為 `True`
+
+        touched_exit (bool): 是否在回測時，使用觸價停損停利？預設為 False
+        stop_trading_next_period (bool): 當期已經停損停利，則下一期不買入，預設為 True。
         live_performance_start (bool): 策略建構的日期，例如 `2022-01-01` 此日期之前，策略未撰寫，此日期之後則視為與實單有類似效果，實際不影響回測的結果，單純紀錄而已。
         mae_mfe_window (int): 計算mae_mfe於進場後於不同持有天數下的數據變化，主要應用為edge_ratio (優勢比率)計算。預設為0，則Report.display_mae_mfe_analysis(...)中的edge_ratio不會顯現。
         mae_mfe_window_step (int): 與mae_mfe_window參數做搭配，為時間間隔設定，預設為1。若mae_mfe_window設20，mae_mfe_window_step設定為2，相當於python的range(0,20,2)，以2日為間距計算mae_mfe。
         market (str or MarketInfo): 可選擇`'TW_STOCK', 'CRYPTO'`，分別為台股或加密貨幣，
                                                               或繼承 finlab.market_info.MarketInfo 開發回測市場類別。
         upload (bool): 上傳策略至finlab網站，預設為True，上傳策略。範例： False，不上傳，可用 finlab.backtest.sim(position, upload=False, ...).display() 快速檢視策略績效。
     Returns:
@@ -183,42 +187,37 @@
 
         report = backtest.sim(position)
         ```
 
 
     """
 
-    # todo: dataframe astype
-    
-
     # check version
     check_version()
 
+    if isinstance(position, pd.Series) and position.name is None:
+        raise Exception('Asset name not found. Please asign asset name by "position.name = \'2330\'".')
+
     # auto detect market type
-    if market == 'AUTO':
-        if isinstance(trade_at_price, str):
-            if position.columns[0].isdigit():
-                market = 'TW_STOCK'
-            else:
-                market = 'US_STOCK'
-
-    # get market position according to market type
-    if isinstance(market, str):
-        assert market in ['TW_STOCK','US_STOCK', 'AUTO']
-        market = {
-            'TW_STOCK': market_info.TWMarketInfo,
-            'US_STOCK': market_info.USMarketInfo,
-            'AUTO': market_info.MarketInfo
-        }[market]
+    # todo: use less hacky method to identify the market
+    market = get_market_info(position, user_market_info=market)
+
+    if not isinstance(market, market_info.MarketInfo):
+        raise Exception("It seems like the market has"
+            "not been specified well when using the hold_until"
+            " function. Please provide the market='TW', "
+            "market='US' or market=MarketInfo")
 
     # determine trading price
     price = trade_at_price
     if isinstance(trade_at_price, str):
         price = market.get_price(trade_at_price, adj=True)
 
+    assert isinstance(price, pd.DataFrame)
+
     if isinstance(trade_at_price, pd.DataFrame) and touched_exit:
         print('**WARNING: Using trade_at_price as dataframe without high, and low price. Candle information is not completed.')
         print('           The backtest result can be incorrect when touched_exit=True.')
         print('           If the complete backtest result is required, please implement MarketInfo with get_price function.')
         print('           MarketInfo details: https://doc.finlab.tw/reference/market_info/')
         print('           And use backtest.sim(..., market=MarketInfo) during backtest, so that the correct information is accessable from backtest.sim().')
 
@@ -241,15 +240,16 @@
     if position.abs().sum().sum() == 0 or len(position.index) == 0:
         raise Exception('Position is empty and zero stock is selected.')
 
     # format position index
     if isinstance(position.index[0], str):
         position = FinlabDataFrame(position).index_str_to_date()
 
-    position.iloc[0] = 0
+    position.values[0, :] = 0
+    assert isinstance(position.index, pd.DatetimeIndex)
 
     # if position date is very close to price end date, run all backtesting dates
     assert len(position.shape) >= 2
     delta_time_rebalance = position.index[-1] - position.index[-3]
     backtest_to_end = position.index[-1] + \
         delta_time_rebalance > price.index[-1]
 
@@ -293,15 +293,15 @@
         # calculate the latest trading date
         next_trading_date = min(
            set(alldates) - set(dates))
 
         if dates[-1] != position.index[-1]:
             dates += [next_trading_date]
 
-    elif resample == None:
+    elif resample is None:
         # user set resample to None. Rebalance everyday might cause over transaction.
         # remove rebalance date if portfolio is the same.
         position = position.loc[position.diff().abs().sum(axis=1) != 0]
 
     if stop_loss is None or stop_loss == 0:
         stop_loss = 1
 
@@ -310,23 +310,23 @@
 
     if dates is not None:
         position = position.reindex(dates, method='ffill')
 
     encryption = download_backtest_encryption()
 
     if encryption == '':
-        print('Cannot perform backtest, permission denied.')
-        return
+        raise Exception('Cannot perform backtest, permission denied.')
 
     creturn_value = backtest_(*arguments(price, high, low, open_, position, dates),
                               encryption=encryption,
                               fee_ratio=fee_ratio, tax_ratio=tax_ratio,
                               stop_loss=stop_loss, take_profit=take_profit,
                               touched_exit=touched_exit, position_limit=position_limit,
                               retain_cost_when_rebalance=retain_cost_when_rebalance,
+                              stop_trading_next_period=stop_trading_next_period,
                               mae_mfe_window=mae_mfe_window, mae_mfe_window_step=mae_mfe_window_step)
 
     total_weight = position.abs().sum(axis=1)
 
     position = position.div(total_weight.where(total_weight!=0, np.nan), axis=0).fillna(0)\
                        .clip(-abs(position_limit), abs(position_limit))
 
@@ -335,15 +335,15 @@
                 .pipe(lambda df: df[(df != 1).cumsum().shift(-1, fill_value=1) != 0])
                 # remove the tail of creturn for verification
                 .loc[:backtest_end_date]
                 # replace creturn to 1 if creturn is None
                 .pipe(lambda df: df if len(df) != 0 else pd.Series(1, position.index)))
 
     trades, operation_and_weight = get_trade_stocks(position.columns.astype(str).values, 
-                                                    price.index.view(np.int64))
+                                                    price.index.view(np.int64), touched_exit=touched_exit)
 
     ####################################
     # refine mae mfe dataframe
     ####################################
     def refine_mae_mfe():
         if len(maemfe.mae_mfe) == 0:
             return pd.DataFrame()
@@ -413,63 +413,74 @@
     r.stop_loss = stop_loss
     r.take_profit = take_profit
     r.live_performance_start = live_performance_start
 
     r.mae_mfe = m
 
     r.trades = trades
-    if len(r.trades) != 0:
-        r.add_trade_info('trade_price', market.get_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
 
     r.actions = pd.Series(dtype=object)
     if len(operation_and_weight['actions']) != 0:
 
         # find selling and buying stocks
         actions = pd.Series(operation_and_weight['actions'])
         actions.index = r.position.columns[actions.index]
         r.actions = actions
 
         sell_sids = actions[actions == 'exit'].index
+        sell_instant_sids = actions[(actions == 'sl') | (actions == 'tp')].index
         buy_sids = actions[actions == 'enter'].index
 
         if len(trades):
             # check if the sell stocks are in the current position
             assert len(set(sell_sids) - set(trades.stock_id[trades.exit_sig_date.isnull()])) == 0
 
             # fill exit_sig_date and exit_date
             trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'] = \
                 trades.loc[trades.stock_id.isin(sell_sids), 'exit_sig_date'].fillna(r.position.index[-1])
 
+            trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'] = \
+                trades.loc[trades.stock_id.isin(sell_instant_sids), 'exit_sig_date'].fillna(price.index[-1])
+
             r.trades = pd.concat([r.trades, pd.DataFrame({
               'stock_id': buy_sids,
               'entry_date': pd.NaT,
               'entry_sig_date': r.position.index[-1],
               'exit_date': pd.NaT,
               'exit_sig_date': pd.NaT,
             })], ignore_index=True)
 
             r.trades['exit_sig_date'] = pd.to_datetime(r.trades.exit_sig_date)
 
+    if len(r.trades) != 0:
+        r.add_trade_info('trade_price', market.get_price(trade_at_price, adj=False), ['entry_date', 'exit_date'])
+
     # add mae mfe to report
     if hasattr(r, 'trades') and hasattr(r, 'mae_mfe'):
         trades = r.trades
         mae_mfe = r.mae_mfe
         exit_mae_mfe = mae_mfe['exit'].copy()
         exit_mae_mfe = exit_mae_mfe.drop(columns=['return'])
         r.trades = pd.concat([trades, exit_mae_mfe], axis=1)
         r.trades.index.name = 'trade_index'
 
     # calculate r.current_trades
     # find trade without end or end today
     maxday = max(r.trades.entry_sig_date.max(), r.trades.exit_sig_date.max())
     latest_entry_day = r.trades.entry_sig_date[r.trades.entry_date.notna()].max()
-    r.current_trades = r.trades[(r.trades.entry_sig_date == maxday )
+    r.current_trades = r.trades[
+            (r.trades.entry_sig_date == maxday )
             | (r.trades.exit_sig_date == maxday)
+            | (r.trades.exit_sig_date > latest_entry_day)
             | (r.trades.entry_sig_date == latest_entry_day)
-            | (r.trades.exit_sig_date.isnull())].set_index('stock_id')
+            | (r.trades.exit_sig_date.isnull())
+            ].set_index('stock_id')
+
+    r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@entry_date'] = np.nan
+    r.current_trades.loc[r.current_trades['return'].isna(), 'trade_price@exit_date'] = np.nan
 
     r.next_trading_date = max(r.current_trades.entry_sig_date.max(), r.current_trades.exit_sig_date.max())
 
     r.current_trades['weight'] = 0
     r.weights = pd.Series(dtype='float64')
     if len(operation_and_weight['weights']) != 0:
         r.weights = pd.Series(operation_and_weight['weights'])
```

## finlab/data.py

```diff
@@ -1,24 +1,28 @@
 import os
 import re
-import time
+import sys
 import json
 import pickle
 import logging
 import datetime
 import numpy as np
 import pandas as pd
 from io import BytesIO
+from typing import Union
+
 import finlab
 from finlab.utils import check_version, requests
-from finlab.market_info import TWMarketInfo, MarketInfo
+from finlab.market_info import MarketInfo, get_market_info
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
+has_print_free_user_warning = False
+
 
 class CacheStorage():
 
     def __init__(self):
         """將歷史資料儲存於快取中
           Examples:
 
@@ -383,35 +387,47 @@
         return refine_stock_id(_storage.get_dataframe(dataset))
 
     # request for auth url
     url = 'https://asia-east2-fdata-299302.cloudfunctions.net/auth_generate_data_url'
     params = {
         'api_token': finlab.get_token(),
         'bucket_name': 'finlab_tw_stock_item',
-        'blob_name': dataset.replace(':', '#') + '.feather'
+        'blob_name': dataset.replace(':', '#') \
+                + ('.pickle' if "pyodide" in sys.modules else '.feather'),
+        'pyodide': 'pyodide' in sys.modules
     }
 
     time_saved = _storage.get_time_created(dataset)
     if time_saved and not force_download:
         params['time_saved'] = time_saved.strftime('%Y%m%d%H%M%S')
 
     res = requests.post(url, params)
 
     try:
         url_data = res.json()
     except:
         raise Exception("Cannot get response from data server.")
 
     # use cache
+    global has_print_free_user_warning
+    if has_print_free_user_warning \
+            and 'role' in url_data \
+            and url_data['role'] == 'free':
+        logger.warning('Due to your status as a free user, \
+            the most recent data has been shortened or limited.')
+        has_print_free_user_warning = True
+
     if 'url' in url_data and url_data['url'] == '':
         return refine_stock_id(_storage.get_dataframe(dataset))
 
     if 'quota' in url_data:
         logger.warning(
-            f'{dataset} -- Daily data usage: {url_data["quota"]:.1f} / {url_data["limit_size"]} MB')
+            f'{dataset} -- Daily usage: {url_data["quota"]:.1f} / {url_data["limit_size"]} MB')
+
+
 
     if 'error' in url_data:
 
         if url_data['error'] in [
             'request not valid',
             'User not found',
             'api_token not valid',
@@ -419,16 +435,25 @@
             finlab.login()
             return get(dataset, save_to_storage)
 
         raise Exception(f"**Error: {url_data['error']}")
 
     assert 'url' in url_data
 
-    res = requests.get(url_data['url'])
-    df = pd.read_feather(BytesIO(res.content))
+    if 'pyodide' in sys.modules:
+        res = requests.getBytes(url_data['url'])
+        df = pd.read_pickle(BytesIO(res), compression='gzip')
+    else:
+        res = requests.get(url_data['url'])
+        df = pd.read_feather(BytesIO(res.content))
+
+    # set market type on column name
+
+    if ':' in dataset:
+        df.columns.name = f'symbol'
 
     # set date as index
     if 'date' in df:
         df.set_index('date', inplace=True)
 
         table_name = dataset.split(':')[0]
         if table_name in ['tw_total_pmi', 'tw_total_nmi', 'tw_industry_nmi', 'tw_industry_pmi']:
@@ -449,19 +474,17 @@
                 df = df.transpose().groupby(level=0).mean().transpose()
             else:
                 df = df.fillna(np.nan).transpose().groupby(
                     level=0).last().transpose()
 
         df = finlab.dataframe.FinlabDataFrame(df)
 
-        if table_name in ['monthly_revenue', 'rotc_monthly_revenue',
-                          'monthly_revenue@Deadline', 'rotc_monthly_revenue@Deadline']:
+        if table_name in ['monthly_revenue', 'rotc_monthly_revenue']:
             df = df._index_date_to_str_month()
-        elif table_name in ['financial_statement', 'fundamental_features',
-                            'financial_statement@Deadline', 'fundamental_features@Deadline']:
+        elif table_name in ['financial_statement', 'fundamental_features',]:
             df = df._index_date_to_str_season()
         elif table_name in ['us_fundamental']:
             df = df._index_date_to_str_season('-US')
     # save cache
     if save_to_storage:
         expiry = datetime.datetime.strptime(
                 url_data['time_scheduled'], '%Y%m%d%H%M%S').replace(tzinfo=datetime.timezone.utc)\
@@ -480,15 +503,15 @@
             if isinstance(val, list):
                 refine_input_names += val
             elif isinstance(val, str):
                 refine_input_names.append(val)
 
     return refine_input_names
 
-def indicator(indname, adjust_price=False, resample='D', market:MarketInfo=TWMarketInfo(), **kwargs):
+def indicator(indname, adjust_price=False, resample='D', market:Union[str, MarketInfo]='TW_STOCK', **kwargs):
     """支援 Talib 和 pandas_ta 上百種技術指標，計算 2000 檔股票、10年的所有資訊。
 
     在使用這個函式前，需要安裝計算技術指標的 Packages
 
     * [Ta-Lib](https://github.com/mrjbq7/ta-lib)
     * [Pandas-ta](https://github.com/twopirllc/pandas-ta)
 
@@ -516,14 +539,17 @@
             getattr(pd.DataFrame().ta, indname)
             attr = lambda df, **kwargs: getattr(df.ta, indname)(**kwargs)
             package = 'pandas_ta'
         except:
             raise Exception(
                 "Please install TA-Lib or pandas_ta to get indicators.")
 
+
+    market = get_market_info(user_market_info=market)
+
     close = market.get_price('close', adj=adjust_price)
     open_ = market.get_price('open', adj=adjust_price)
     high = market.get_price('high', adj=adjust_price)
     low = market.get_price('low', adj=adjust_price)
     volume = market.get_price('volume', adj=adjust_price)
 
     if resample.upper() != 'D':
@@ -594,14 +620,16 @@
     ret = [d.apply(lambda s:pd.to_numeric(s, errors='coerce')) for d in ret]
 
     if len(ret) == 1:
         return finlab.dataframe.FinlabDataFrame(ret[0])
 
     return tuple([finlab.dataframe.FinlabDataFrame(df) for df in ret])
 
+indicator.us_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'US_STOCK'}})
+indicator.tw_stock = lambda *args, **kwargs: indicator(*args, **{**kwargs, **{'market': 'TW_STOCK'}})
 
 def get_strategies(api_token=None):
     """取得已上傳量化平台的策略回傳資料。
 
     可取得自己策略儀表板上的數據，例如每個策略的報酬率曲線、報酬率統計、夏普率、近期部位、近期換股日...，
     這些數據可以用來進行多策略彙整的應用喔！
```

## finlab/dataframe.py

```diff
@@ -1,13 +1,14 @@
 from finlab.utils import logger
 import datetime
 import numpy as np
 import pandas as pd
 from finlab import data
 import functools
+from finlab.market_info import MarketInfo, get_market_info
 
 monthly_index = None
 
 
 class FinlabDataFrame(pd.DataFrame):
     """回測語法糖
     除了使用熟悉的 Pandas 語法外，我們也提供很多語法糖，讓大家開發程式時，可以用簡易的語法完成複雜的功能，讓開發策略更簡潔！
@@ -249,44 +250,58 @@
         else:
           q = self.index.strftime('%m').astype(int).map({5:1, 8:2, 9:2, 10:3, 11:3, 3:4, 4:4})
           year -= (q == 4)
         index = year.astype(str) + f'{postfix}-Q' + q.astype(str)
         return FinlabDataFrame(self.values, index=index, columns=self.columns)
 
     def deadline(self):
-        """財務季報索引轉換成公告截止日
+        """財務索引轉換成公告截止日
 
           將財務季報 (ex:2022Q1) 從文字格式轉為公告截止日的datetime格式，
           通常使用情境為對不同週期的dataframe做reindex，常用於以公告截止日作為訊號產生日。
           Returns:
             (pd.DataFrame): data
           Examples:
               ```py
               data.get('financial_statement:現金及約當現金').deadline()
+              data.get('monthly_revenue:當月營收').deadline()
               ```
         """
-        return self._index_str_to_date_season(detail=False)
+        if self.index[0].find('M') != -1:
+            return self._index_str_to_date_month()
+        elif self.index[0].find('Q') != -1:
+            return self._index_str_to_date_season(detail=False)
+
+        raise Exception("Cannot apply deadline to dataframe. "
+                        "Index is not compatable."
+                        "Index should be 2013-Q1 or 2013-M1."
+                        )
+
 
     def _index_str_to_date_season(self, detail=True, us=False):
+
       datekey = data.get('us_fundamental:datekey').copy() if us else calc_disclosure_dates(detail)
       disclosure_dates = (datekey
                           .reindex_like(self)
                           .unstack())
 
-      self.columns.name = 'stock_id'
+      if not hasattr(self.columns, 'name'):
+          self.columns.name = 'symbol'
+
+      col_name = self.columns.name
 
       unstacked = self.unstack()
 
       ret = (pd.DataFrame({
           'value': unstacked.values,
           'disclosures': disclosure_dates.values,
         }, unstacked.index)
-        .reset_index()
-        .drop_duplicates(['disclosures', 'stock_id'])
-        .pivot(index='disclosures', columns='stock_id', values='value').ffill()
+        .reset_index(names=[col_name, 'date'])
+        .drop_duplicates(['disclosures', col_name])
+        .pivot(index='disclosures', columns=col_name, values='value').ffill()
         .pipe(lambda df: df.loc[df.index.notna()])
         .pipe(lambda df: FinlabDataFrame(df))
         .rename_axis('date')
       )
 
       if not detail:
           ret.index = self.to_business_day(ret.index)
@@ -569,15 +584,15 @@
         position[exit_signal] = 0
 
         position.ffill(inplace=True)
         position = position == 1
         position.fillna(False)
         return position
 
-    def hold_until(self, exit, nstocks_limit=None, stop_loss=-np.inf, take_profit=np.inf, trade_at='close', rank=None):
+    def hold_until(self, exit, nstocks_limit=None, stop_loss=-np.inf, take_profit=np.inf, trade_at='close', rank=None, market='AUTO'):
         """訊號進出場
 
         這大概是所有策略撰寫中，最重要的語法糖，上述語法中 `entries` 為進場訊號，而 `exits` 是出場訊號。所以 `entries.hold_until(exits)` ，就是進場訊號為 `True` 時，買入並持有該檔股票，直到出場訊號為 `True ` 則賣出。
         <img src="https://i.ibb.co/PCt4hPd/Screen-Shot-2021-10-26-at-6-35-05-AM.png" alt="Screen-Shot-2021-10-26-at-6-35-05-AM">
         此函式有很多細部設定，可以讓你最多選擇 N 檔股票做輪動。另外，當超過 N 檔進場訊號發生，也可以按照客制化的排序，選擇優先選入的股票。最後，可以設定價格波動當輪動訊號，來增加出場的時機點。
 
         Args:
@@ -601,27 +616,38 @@
 
             sma20 = close.average(20)
             sma60 = close.average(60)
 
             entries = close > sma20
             exits = close < sma60
 
-            ＃pb前10小的標的做輪動
+            #pb前10小的標的做輪動
             position = entries.hold_until(exits, nstocks_limit=10, rank=-pb)
             sim(position)
             ```
         """
         if nstocks_limit is None:
             nstocks_limit = len(self.columns)
 
         union_index = self.index.union(exit.index)
         intersect_col = self.columns.intersection(exit.columns)
 
         if stop_loss != -np.inf or take_profit != np.inf:
-            price = data.get(f'etl:adj_{trade_at}')
+            market = get_market_info(self, user_market_info=market)
+
+            if not isinstance(market, MarketInfo):
+                raise Exception("It seems like the market has"
+                    "not been specified well when using the hold_until"
+                    " function. Please provide the appropriate"
+                    " market parameter to the hold_until function "
+                    "to ensure it can determine the correct market"
+                    " for the transaction.")
+
+            price = market.get_price(trade_at, adj=True)
+
             union_index = union_index.union(
                 price.loc[union_index[0]: union_index[-1]].index)
             intersect_col = intersect_col.intersection(price.columns)
         else:
             price = pd.DataFrame()
             price.index = pd.to_datetime(price.index)
 
@@ -698,91 +724,99 @@
                             take_profit,
                             price=price.values,
                             ranking=rank.values)
 
         return pd.DataFrame(ret, index=entry.index, columns=entry.columns)
 
 
-
 @functools.lru_cache()
 def calc_disclosure_dates(detail=True):
 
-  cinfo = data.get('company_basic_info').copy()
-  cinfo['id'] = cinfo.stock_id.str.split(' ').str[0]
-  cinfo = cinfo.set_index('id')
-  cinfo = cinfo[~cinfo.index.duplicated(keep='last')]
-
-  def calc_default_disclosure_dates(s):
-    sid = s.name
-    cat = cinfo.loc[sid].產業類別 if sid in cinfo.index else 'etf'
-    short_name = cinfo.loc[sid].公司簡稱 if sid in cinfo.index else 'etf'
-
-    if cat == '金融業':
-      calendar = {
-        '1': '-05-15',
-        '2': '-08-31',
-        '3': '-11-14',
-        '4': '-03-31',
-      }
-    elif cat == '金融保險業':
-      calendar = {
-        '1': '-04-30',
-        '2': '-08-31',
-        '3': '-10-31',
-        '4': '-03-31',
-      }
-    elif 'KY' in short_name:
+    upload_dates = data.get('financial_statements_upload_detail:upload_date')
+
+    # upload_dates 以下錯誤資訊做刪除
+    # 1. 季度還沒結束就公布財報
+    # 2. 季度結束半年以上才公布財報（通常為更新，而非第一次的財報，但我們也沒有第一次的，所以只好假裝沒有）
+    # 3. 上季度到這季度的公布日期沒有變（代表一次性更新多個財報，沒有第一次的，只好假裝沒有）
+
+    def season_end(d):
+
         calendar = {
-        'old':{
+        '1': '-3-31',
+        '2': '-6-30',
+        '3': '-9-30',
+        '4': '-12-31',
+        }
+        return d[:4] + calendar[d[-1]]
+
+    upload_dates = pd.DataFrame(upload_dates.apply(pd.to_datetime))
+    season_end = pd.to_datetime(upload_dates.index.to_series().apply(season_end))
+    financial_season_end = pd.DataFrame({s: season_end for s in upload_dates.columns}, index=upload_dates.index)
+
+    upload_dates[(upload_dates < financial_season_end)
+                | (upload_dates > financial_season_end + datetime.timedelta(days=180))
+                | (upload_dates.diff() <= datetime.timedelta(days=0))
+                ] = pd.NaT
+
+    # create date series that contains industry disclosure deadline
+    # date_series = Dict[str:pd.Series()]
+    # str are calendar.keys() and pd.Series is the deadline of each quarter
+
+    calendars = {
+        '金融業': {
             '1': '-05-15',
-            '2': '-08-14',
+            '2': '-08-31',
             '3': '-11-14',
             '4': '-03-31',
-              },
-        'new':{
-            '1': '-05-15',
+        },
+        '金融保險業': {
+            '1': '-04-30',
             '2': '-08-31',
+            '3': '-10-31',
+            '4': '-03-31',
+        },
+        '一般': {
+            '1': '-05-15',
+            '2': '-08-14',
             '3': '-11-14',
             '4': '-03-31',
-              },
         }
-    else:
-      calendar = {
-        '1': '-05-15',
-        '2': '-08-14',
-        '3': '-11-14',
-        '4': '-03-31',
-      }
-    get_year = lambda year, season: str(year) if int(season) != 4 else str(int(year) + 1)
-    ky_policy_check = lambda year: 'new' if year >= '2021' else 'old'
-    return pd.to_datetime(s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[ky_policy_check(d[:4])][d[-1]]) if 'KY' in short_name else s.index.map(lambda d: get_year(d[:4], d[-1]) + calendar[d[-1]]))
-
-  def season_end(s):
-
-    calendar = {
-      '1': '-3-31',
-      '2': '-6-30',
-      '3': '-9-30',
-      '4': '-12-31',
     }
-    return pd.to_datetime(s.index.map(lambda d: d[:4] + calendar[d[-1]]))
-
-
-  disclosure_dates = data.get('financial_statements_upload_detail:upload_date')
-  disclosure_dates = disclosure_dates.apply(pd.to_datetime)
 
-  financial_season_end = disclosure_dates.apply(season_end)
-  default_disclosure_dates = disclosure_dates.apply(calc_default_disclosure_dates)
+    date_series = {}
+    index = upload_dates.index.to_series()
+    for cat, calendar in calendars.items():
+        year = index.str[:4].astype(int)
+        year[index.str[-1] == '4'] += 1
+        month_day = index.str[-1].map(calendar)
+        date_series[cat] = pd.to_datetime(year.astype(str) + month_day)
+
+    # calculate industry mapping and ky mapping for different disclosure deadline
+    cinfo = data.get('company_basic_info')
+    id_to_industry = dict(zip(cinfo['stock_id'].values, cinfo.產業類別.values))
+    ky_stocks = set(cinfo.stock_id[cinfo['公司簡稱'].str.contains('KY')])
+
+    # calculate default disclosure date considering different industry
+    ret = pd.DataFrame({sid:date_series.get(
+        id_to_industry.get(sid, '水泥工業'), date_series['一般']) 
+        for sid in upload_dates.columns})
+
+    # adjust Q2 deadline for KY stocks (XXXX-08-31 where XXXX >= 2021)
+    is_ky_adjusted = (ret.index.str.contains('Q2') & (ret.index.str[:4] >= '2021'),
+                    ret.columns.isin(ky_stocks))
+
+    ret.loc[is_ky_adjusted] = ret.loc[is_ky_adjusted].applymap(lambda d: d.replace(day=31))
+
+    # adjust for ROCT deadline Q1 at 4-30 if the month of upload_date >= April
+    is_q4 = ret.index.str.contains('Q4')
+    q4 = upload_dates[is_q4].fillna(ret)
+    ret[is_q4] = q4.applymap(lambda d: d.replace(day=30) if d.month == 4 
+                            else d.replace(month=3,day=31))
+
+    ret = ret.apply(FinlabDataFrame.to_business_day)
+    
+    if detail:
+        return upload_dates.fillna(ret)
 
-  disclosure_dates[(disclosure_dates > default_disclosure_dates)
-                    | (disclosure_dates < financial_season_end)] = pd.NaT
-  disclosure_dates[(disclosure_dates.diff() <= datetime.timedelta(days=0))] = pd.NaT
-  disclosure_dates.loc['2019-Q1', '3167'] = pd.NaT
-  disclosure_dates.loc['2015-Q1', '5536'] = pd.NaT
-  disclosure_dates.loc['2018-Q1', '5876'] = pd.NaT
 
-  disclosure_dates = disclosure_dates.fillna(default_disclosure_dates)
-  disclosure_dates.columns.name = 'stock_id'
+    return ret
 
-  if detail:
-    return disclosure_dates
-  return default_disclosure_dates
```

## finlab/market_info.py

```diff
@@ -1,25 +1,27 @@
+import logging
 import pandas as pd
-import finlab
+from typing import Dict, Optional, Union
 
+import finlab
 
 class MarketInfo():
     """市場類別
     假如希望開發新的交易市場套用到回測系統，可以繼承 `finlab.market_info.MarketInfo` 來實做新類別。
     """
     @staticmethod
-    def get_freq():
+    def get_freq() -> str:
         return '1d'
 
     @staticmethod
-    def get_timestamp_name():
+    def get_name() -> str:
         return 'auto'
 
     @staticmethod
-    def get_benchmark():
+    def get_benchmark() -> pd.Series:
         """設定對標報酬率的時間序列
         Returns:
           (pd.Series): 時間序列
         Examples:
             | date       |   0050 |
             |:-----------|-------:|
             | 2007-04-23 |   100 |
@@ -27,23 +29,23 @@
             | 2007-04-25 |   99 |
             | 2007-04-26 |   98.3 |
             | 2007-04-27 |   99.55 |
         """
         return pd.Series([], index=pd.Index([], dtype='datetime64[ns]'), dtype='float64')
 
     @staticmethod
-    def get_asset_id_to_name():
+    def get_asset_id_to_name() -> Dict:
         """設定對標報酬率的時間序列
         Returns:
           (dict): 股號與股名對照表，ex:`{'2330':'台積電'}`
         """
         return {}
 
     @staticmethod
-    def get_price(trade_at_price, adj=True):
+    def get_price(trade_at_price:str, adj:bool=True) -> pd.DataFrame:
         """取得回測用價格數據
         Args:
            trade_at_price (str): 選擇回測之還原股價以收盤價或開盤價計算，預設為'close'。可選'close'或'open'。
            adj (str): 是否使用還原股價計算。
         Returns:
           (pd.DataFrame): 價格數據
         Examples:
@@ -53,41 +55,36 @@
             |:-----------|-------:|-------:|-------:|-------:|
             | 2007-04-23 |   9.54 |  57.85 |  32.83 |  38.4  |
             | 2007-04-24 |   9.54 |  58.1  |  32.99 |  38.65 |
             | 2007-04-25 |   9.52 |  57.6  |  32.8  |  38.59 |
             | 2007-04-26 |   9.59 |  57.7  |  32.8  |  38.6  |
             | 2007-04-27 |   9.55 |  57.5  |  32.72 |  38.4  |
             """
-        return trade_at_price
+        return pd.DataFrame()
 
 
 class TWMarketInfo(MarketInfo):
 
     @staticmethod
     def get_freq():
         return '1d'
 
     @staticmethod
-    def get_timestamp_name():
+    def get_name():
         return 'tw_stock'
 
     @staticmethod
-    def get_benchmark():
+    def get_benchmark() -> pd.Series:
         return finlab.data.get('benchmark_return:發行量加權股價報酬指數').squeeze()
 
     @staticmethod
     def get_asset_id_to_name():
-        stock_names = finlab.data._storage.get_stock_names()
-
-        if stock_names == {}:
-            categories = finlab.data.get('security_categories')
-            new_stock_names = dict(
-                zip(categories['stock_id'], categories['name']))
-            finlab.data._storage.set_stock_names(new_stock_names)
-            stock_names = finlab.data._storage.get_stock_names()
+        categories = finlab.data.get('security_categories')
+        stock_names = dict(
+            zip(categories['stock_id'], categories['name']))
 
         return stock_names
 
     @staticmethod
     def get_price(trade_at_price, adj=True):
         if isinstance(trade_at_price, pd.Series):
             return trade_at_price.to_frame()
@@ -114,15 +111,15 @@
 class USMarketInfo(MarketInfo):
 
     @staticmethod
     def get_freq():
         return '1d'
 
     @staticmethod
-    def get_timestamp_name():
+    def get_name():
         return 'us_stock'
 
     @staticmethod
     def get_benchmark():
         return finlab.data.get('world_index:adj_close')['^GSPC']
 
     @staticmethod
@@ -150,8 +147,43 @@
             else:
                 table_name = 'us_price:'
                 price_name = trade_at_price
 
             price = finlab.data.get(f'{table_name}{price_name}')
             return price
 
-        raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
+        raise Exception(f'**ERROR: trade_at_price is not allowed (accepted types: pd.DataFrame, pd.Series, str).')
+
+
+def get_market_info(df:Union[None, pd.DataFrame, pd.Series]=None, 
+                    user_market_info:Union[None, str, MarketInfo]='AUTO') -> Optional[MarketInfo]:
+
+    
+    # return market info base on user_market_info
+    if user_market_info == 'TW_STOCK':
+        return TWMarketInfo()
+
+    if user_market_info == 'US_STOCK':
+        return USMarketInfo()
+
+    if user_market_info != 'AUTO':
+        return user_market_info
+
+    # deal with user_market_info == 'AUTO'
+    if df is not None:
+        ids = set([df.name]) if isinstance(df, pd.Series) else set(df.columns)
+        for market in [TWMarketInfo(), USMarketInfo()]:
+            market_ids = set(market.get_asset_id_to_name().keys())
+            id_not_found = ids - market_ids
+
+            if len(id_not_found) / len(ids) < 0.5:
+                if len(id_not_found):
+                    logging.warn(f"Symbols {id_not_found[:10]} not found in MarketInfo.")
+                return market
+
+    raise Exception("Market cannot be determined automatically. "
+                    "Please set the market argument to either "
+                    "'TW_STOCK' for Taiwan stock market, 'US_STOCK' "
+                    "for US stock market, or use subclass of MarketInfo"
+                    " to specify a different market.")
+
+
```

## finlab/utils.py

```diff
@@ -1,14 +1,14 @@
 import os
 import re
 import sys
 import json
 import logging
 import finlab
-from finlab.utils_core import str_to_bytearray
+from finlab.core.utils_core import str_to_bytearray
 
 # Get an instance of a logger
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 def requests_module_factory():
 
@@ -27,14 +27,15 @@
     if "pyodide" not in sys.modules:
         import requests
         return requests
 
     # raise error if not install requests and not in pyodide env
     from js import XMLHttpRequest, Blob, FormData
     import urllib.parse
+    from pyodide import http
     import pyodide
 
     # in pyodide env, make fake requests
     class Response:
         text = ''
         json_ = ''
         content = ''
@@ -43,15 +44,15 @@
         def json(self):
             return self.json_
 
     class requests:
 
         def getBytes(url):
             req = XMLHttpRequest.new()
-            req.open("GET", auth_url.text, False)
+            req.open("GET", url, False)
             req.overrideMimeType('text/plain; charset=x-user-defined')
             req.send(None)
             return str_to_bytearray(req.response)
 
         def get(url, params=None):
 
             if params == None:
@@ -59,15 +60,15 @@
 
 
             complete_url = url + '?' + '&'.join([
                 urllib.parse.quote_plus(k)
                 + '=' + urllib.parse.quote_plus(v)
                 for k, v in params.items()])
 
-            str_io = pyodide.http.open_url(complete_url)
+            str_io = http.open_url(complete_url)
 
             res = Response()
             res.text = str_io.read()
             res.json_ = requests.parse_json(res.text)
             res.status_code = 200
 
             return res
@@ -120,14 +121,16 @@
 
     if the package version is out of date, info user to update.
 
     Returns
         None
 
     """
+    if "pyodide" in sys.modules:
+        return lambda : None
 
     latest_package_version = None
 
     def ret():
 
         nonlocal latest_package_version
 
@@ -188,15 +191,16 @@
             return None
 
     def set_global(name, obj):
         nonlocal _finlab_global_objects
         _finlab_global_objects[name] = obj
         if "pyodide" in sys.modules:
             import js
-            js.postMessage(pyodide.to_js({'content': name, 'finish': False, 'type': 'py_global_update', 'id': js._pyodide_execution_id}))
+            from pyodide import ffi
+            js.postMessage(ffi.to_js({'content': name, 'finish': False, 'type': 'py_global_update', 'id': js._pyodide_execution_id}))
 
 
     return get_global, set_global
 
 get_global, set_global = global_object_getter_setter_factory()
 
 requests = requests_module_factory()
```

## finlab/analysis/__init__.py

```diff
@@ -1,9 +1,9 @@
-from abc import ABC, abstractmethod
-from finlab.report import Report as ReportPyx
+from abc import ABC
+from finlab.core.report import Report as ReportPyx
 
 
 class Analysis(ABC):
 
     def is_market_info_supported(self, market_info):
         """Check if market info is supported
 
@@ -114,43 +114,43 @@
         Returns:
           (pd.DataFrame): 波動時序資料
         """
         return super().get_mae_mfe()
 
     def get_trades(self):
         """取得回測逐筆交易紀錄
-        ## 重點欄位說明
-        * entry_sig_date:進場訊號產生日。
-        * exit_sig_date:出場訊號產生日。
-        * entry_date:進場日。
-        * exit_date:出場日。
-        * position:持有佔比。
-        * period:持有天數。
-        * return:報酬率。
-        * trade_price@entry_date:進場價。
-        * trade_price@exit_date:出場價。
-        * mae:持有期間最大不利報酬率幅度。
-        * gmfe:持有期間最大有利報酬率幅度。
-        * bmfe:mae發生前的最大有利報酬率幅度。
-        * mdd:持有期間最大回撤。
-        * pdays:處於獲利時的天數。
 
         Returns:
           (pd.DataFrame): 交易紀錄
         """
         return super().get_trades()
 
     def get_stats(self, resample='1d', riskfree_rate=0.02):
         """取得策略統計數據
         取得數據如夏普率、索提諾比率、最大回檔、近期報酬率統計...
         Args:
-           resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
-           riskfree_rate (float): 無風險利率。
+            resample (str): 報酬率檢測週期，其他常用數值為 W、 M 、Q（每週、每月、每季換股）。
+            riskfree_rate (float): 無風險利率。
         Returns:
-          (dict): 策略指標數據。
+            (dict): 策略指標數據，包含：
+
+            * entry_sig_date:進場訊號產生日。
+            * exit_sig_date:出場訊號產生日。
+            * entry_date:進場日。
+            * exit_date:出場日。
+            * position:持有佔比。
+            * period:持有天數。
+            * return:報酬率。
+            * trade_price@entry_date:進場價。
+            * trade_price@exit_date:出場價。
+            * mae:持有期間最大不利報酬率幅度。
+            * gmfe:持有期間最大有利報酬率幅度。
+            * bmfe:mae發生前的最大有利報酬率幅度。
+            * mdd:持有期間最大回撤。
+            * pdays:處於獲利時的天數。
         """
         return super().get_stats(resample, riskfree_rate)
 
     def run_analysis(self, analysis, display=True, **kwargs):
         """執行策略分析外掛模組
         Args:
           analysis (str or object): `finlab.analysis`內的分析模組名稱，ex:`'liquidityAnalysis'`。
```

## finlab/analysis/alphaBetaAnalysis.py

```diff
@@ -1,9 +1,10 @@
 import math
 import pandas as pd
+import numpy as np
 from finlab import data
 from finlab.analysis import Analysis
 
 
 class AlphaBetaAnalysis(Analysis):
 
     def __init__(self):
@@ -15,28 +16,32 @@
     @staticmethod
     def calculate_alpha_beta(creturn, benchmark):
 
         a = creturn
         b = benchmark
 
         beta = pd.DataFrame({'a': a.values, 'b': b.values}).cov().iloc[0,1] / b.var()
-        alpha = ((a - b * beta).mean()+1) ** 252 - 1
+        alpha = a.mean() - beta * b.mean()
 
         return alpha, beta
 
     def analyze(self, report):
 
-        benchmark_pct = report.daily_benchmark.pct_change()
         creturn_pct = report.daily_creturn.pct_change()
+        benchmark_pct = report.daily_benchmark\
+                .pct_change()\
+                .fillna(0)\
+                .reindex(creturn_pct.index, method='ffill')
 
         # recent metrics
         recent = {'alpha': [], 'beta': [], 'ndays': [], 'info': []}
         for n in [0, 20, 60, 120, 252]:
             a = creturn_pct.iloc[-n:]
             b = benchmark_pct.loc[a.index[0]:].reindex(a.index)
+
             alpha, beta = self.calculate_alpha_beta(a, b)
             recent['alpha'].append(0 if math.isnan(alpha) else alpha)
             recent['beta'].append(1 if math.isnan(beta) else beta)
             recent['ndays'].append(n)
 
         # yearly metrics
         yearly = {'alpha': [], 'beta': [], 'year': []}
```

## finlab/analysis/liquidityAnalysis.py

```diff
@@ -1,15 +1,16 @@
 import pandas as pd
 from finlab import data
 from finlab.analysis import Analysis
+from finlab.market_info import TWMarketInfo
 
 
 class LiquidityAnalysis(Analysis):
 
-  def __init__(self, required_volume=200000, required_turnover=1000000, detail=True):
+  def __init__(self, required_volume=200000, required_turnover=1000000):
     """分析台股策略流動性風險項目的機率
 
     !!! note
         參考[VIP限定文章](https://www.finlab.tw/customized_liquidityanalysis/)更了解流動性檢測內容細節。
     Args:
         required_volume (int): 要求進出場時的單日成交股數至少要多少？
         required_turnover (int): 要求進出場時的單日成交金額至少要多少元？避免成交股數夠，但因低價股因素，造成胃納量仍無法符合資金需求。
@@ -25,15 +26,14 @@
         report.run_analysis(LiquidityAnalysis(required_volume=100000))
         ```
     """
 
     self._required_volume = required_volume
     self._required_turnover = required_turnover
     self._result = None
-    self._detail = detail
 
   def is_market_info_supported(self, market_info):
     return 'TWMarketInfo' in str(market_info)
 
   def calculate_trade_info(self, report):
 
     # calculate trade bar return
@@ -48,15 +48,17 @@
 
     ret = [
       ["交易當下漲跌", adj_trade_price / adj_previous_close - 1, signal_dates],
       ["交易金額", trade_price * volume, signal_dates],
       ["成交股數", volume, signal_dates]
     ]
 
-    if self._detail:
+    is_tw = isinstance(report.market_info, TWMarketInfo)
+
+    if is_tw:
         ret += [
           ["處置股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
           ["警示股", ~data.get('etl:disposal_stock_filter').shift(fill_value=False), signal_dates],
           ["全額交割股", ~data.get('etl:full_cash_delivery_stock_filter').shift(fill_value=False), signal_dates]
         ]
 
     return ret
@@ -82,15 +84,16 @@
       '賣遇跌停': [entry_sell_at_bottom.mean(), exit_sell_at_bottom.mean()],
       '成交股數少': [(trades['成交股數@entry_date'] < self._required_volume).mean(),
                      (trades['成交股數@exit_date'] < self._required_volume).mean()],
       '交易金額少': [(trades['交易金額@entry_date'] < self._required_turnover).mean(),
                      (trades['交易金額@exit_date'] < self._required_turnover).mean()],
     }
 
-    if self._detail:
+    is_tw = isinstance(report.market_info, TWMarketInfo)
+    if is_tw:
         ret_dict = {**ret_dict, **{
             '處置股': [trades['處置股@entry_date'].mean(), trades['處置股@exit_date'].mean()],
             '警示股': [trades['警示股@entry_date'].mean(), trades['警示股@exit_date'].mean()],
             '全額交割股':[trades['全額交割股@entry_date'].mean(), trades['全額交割股@exit_date'].mean()]
         }}
 
     self._result = pd.DataFrame(ret_dict)
```

## finlab/analysis/maeMfeAnalysis.py

```diff
@@ -62,25 +62,25 @@
         from plotly.subplots import make_subplots
         import plotly.figure_factory as ff
 
         violinmode = self.violinmode
         mfe_scatter_x = self.mfe_scatter_x
         kwargs = self.kwargs
         report = self.report
-
+        stats = report.get_stats()
         trade_record = report.get_trades().copy().dropna(
                 subset=['mae', 'mdd', 'bmfe', 'gmfe', 'pdays', 'return'])
         trade_record['entry_date'] = trade_record['entry_date'].dt.strftime('%Y-%m-%d')
         trade_record.loc[:, ['return']] = round(trade_record[['return']] * 100, 2)
         trade_record.loc[:, ['pdays_ratio']] = trade_record['pdays'] / trade_record['period']
         trade_record.loc[:, ['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio'], ] = round(
             abs(trade_record[['mae', 'mdd', 'bmfe', 'gmfe', 'pdays_ratio']] * 100), 2)
         trade_record.loc[:, ['profit_loss']] = trade_record['return'].apply(lambda s: 'profit' if s > 0 else 'loss')
         trade_record.loc[:, ['size']] = abs(trade_record['return'])
-        win_ratio = round(sum(trade_record['profit_loss'] == 'profit') / len(trade_record) * 100, 2)
+        win_ratio = round(stats['win_ratio']*100, 1)
         stats = {g[0]: g[1].describe().to_dict() for g in trade_record.groupby('profit_loss')}
 
         # calculate edge_ratio
         mae_mfe = report.mae_mfe
         mae_mfe_window_col = [i for i in list(set(mae_mfe.columns.get_level_values(0))) if
                               ('exit' not in str(i)) and (i != 0)]
         if len(mae_mfe_window_col) == 0:
```

## finlab/analysis/periodStatsAnalysis.py

```diff
@@ -1,43 +1,74 @@
 import numpy as np
 from finlab.analysis import Analysis
 
 class PeriodStatsAnalysis(Analysis):
 
     def __init__(self):
+        """分析台股策略的不同時期與大盤指標作比較
+
+        Examples:
+            ``` py
+            report.run_analysis('PeriodStatsAnalysis')
+            ```
+            |                                      |   benchmark |   strategy |
+            |:-------------------------------------|------------:|-----------:|
+            | ('overall_daily', 'calmar_ratio')    |   0.149192  |  0.0655645 |
+            | ('overall_daily', 'sortino_ratio')   |   0.677986  |  0.447837  |
+            | ('overall_daily', 'sharpe_ratio')    |   0.532014  |  0.306351  |
+            | ('overall_daily', 'profit_factor')   |   1.20022   |  1.07741   |
+            | ('overall_daily', 'tail_ratio')      |   0.914881  |  0.987751  |
+            | ('overall_daily', 'return')          |   0.0835801 |  0.0478957 |
+            | ('overall_daily', 'volatility')      |   0.182167  |  0.312543  |
+            | ('overall_monthly', 'calmar_ratio')  |   0.155321  |  0.0731378 |
+            | ('overall_monthly', 'sortino_ratio') |   0.697382  |  0.439003  |
+            | ('overall_monthly', 'sharpe_ratio')  |   0.524943  |  0.307292  |
+            | ('overall_monthly', 'profit_factor') |   1.75714   |  1.27059   |
+            | ('overall_monthly', 'tail_ratio')    |   1.03322   |  0.903335  |
+            | ('overall_monthly', 'return')        |   0.0836545 |  0.0479377 |
+            | ('overall_monthly', 'volatility')    |   0.186989  |  0.316178  |
+            | ('overall_yearly', 'calmar_ratio')   |   0.436075  |  0.127784  |
+            | ('overall_yearly', 'sortino_ratio')  |   0.738327  |  0.694786  |
+            | ('overall_yearly', 'sharpe_ratio')   |   0.407324  |  0.350986  |
+            | ('overall_yearly', 'profit_factor')  |   2.2       |  1.66667   |
+            | ('overall_yearly', 'tail_ratio')     |   1.71647   |  1.359     |
+            | ('overall_yearly', 'return')         |   0.0814469 |  0.0663674 |
+            | ('overall_yearly', 'volatility')     |   0.284742  |  0.419087  |
+        """
+        self.results = None
 
         def safe_division(n, d):
             return n / d if d else 0
 
         calc_cagr = (
-            lambda s: (s.iloc[-1] / s.iloc[0]) ** safe_division(365, (s.index[-1] - s.index[0]).days) - 1 
+            lambda s: (s.add(1).prod()) ** safe_division(365, (s.index[-1] - s.index[0]).days) - 1 
             if len(s) > 1 else 0)
 
         def calc_calmar_ratio(pct):
             s = pct.add(1).cumprod().iloc[1:]
-            return safe_division(calc_cagr(s), abs(s.calc_max_drawdown()))
+            return safe_division(calc_cagr(pct), abs(s.calc_max_drawdown()))
 
         self.metrics = [
                 ("calmar_ratio", calc_calmar_ratio),
                 ('sortino_ratio', lambda s: safe_division(s.mean(), s[s < 0].std())
                     * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
                 ('sharpe_ratio', lambda s: safe_division(s.mean(), s.std())
                     * (safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365) ** 0.5),
                 ('profit_factor', lambda s: safe_division((s > 0).sum(), (s < 0).sum())),
                 ('tail_ratio', lambda s: -safe_division(s.quantile(0.95), (s.quantile(0.05)))),
-                ('return', lambda s: calc_cagr(s.add(1).cumprod())),
+                ('return', lambda s: calc_cagr(s)),
                 ('volatility', lambda s: s.std() * np.sqrt(safe_division(len(s), (s.index[-1] - s.index[0]).days) * 365)),
                 ]
 
     def calc_stats(self, series):
 
         ########################################
         # calculate yearly metric performance
         ########################################
-        pct = series.pct_change()
+        pct = series.pct_change().fillna(0)
 
         def eval_f(m, s):
             if isinstance(m, str):
                 return getattr(s, m)()
             else:
                 return m[1](s)
 
@@ -89,9 +120,54 @@
 
     def analyze(self, report):
 
         ret = {}
         ret['strategy'] = self.calc_stats(report.daily_creturn)
         ret['benchmark'] = self.calc_stats(report.daily_benchmark)
 
+        self.results = ret
+
         return ret
 
+    def display(self):
+
+        if self.results is None:
+            return
+
+        from IPython.display import HTML
+
+        t = ''
+        result = self.results
+        result['benchmark']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
+        result['strategy']['recent']['days'] = ['M', 'Q', 'HY', 'Y', '3Y']
+
+        df = pd.DataFrame({'benchmark': pd.DataFrame({cat: result['benchmark'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack(),
+        'strategy': pd.DataFrame({cat: result['strategy'][cat] for cat in ['overall_daily', 'overall_monthly', 'overall_yearly']}).unstack()})
+
+        def highlight_max(s, props=''):
+            return np.where(s == np.nanmax(s.values), props, '')
+
+        t += df.style.apply(highlight_max, props='color:white;color:blue', axis=1).to_html()
+
+        for cat in ['yearly', 'recent']:
+
+            metric_names = result['strategy'][cat].keys()
+
+            index_name = {
+                'yearly': 'year',
+                'recent': 'days',
+            }[cat]
+
+            for mname in metric_names:
+
+                if mname == index_name:
+                    continue
+
+                df = pd.DataFrame([result['strategy'][cat][mname], result['benchmark'][cat][mname]], columns=result['strategy'][cat][index_name], index=['strategy', 'benchmark'])
+
+                def make_pretty(styler, df, title):
+                    styler.set_caption(title)
+                    styler.background_gradient(axis=None, vmin=df.min().min(), vmax=df.max().max(), cmap="YlGnBu")
+                    return styler
+
+                t += df.style.format(precision=2).pipe(lambda v: make_pretty(v, df, mname)).to_html() + '<br />'
+        return HTML(t)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## finlab/ml/alphalens.py

```diff
@@ -78,15 +78,15 @@
         factor (pd.DataFrame): factor data where index is datetime and columns is asset id
         adj_close (pd.DataFrame): adj close where index is datetime and columns is asset id
         days (List[int]): future return considered
     Return:
         Analytic plots and tables
 
     Examples:
-        ```
+        ``` py title="股價淨值比分析"
         import alphalens
         from finlab import data
         from finlab.ml.alphalens import create_factor_data
 
         factor = data.get('price_earning_ratio:股價淨值比')
         adj_close = data.get('etl:adj_close')
```

## finlab/ml/feature.py

```diff
@@ -200,17 +200,16 @@
         n (int): The number of random samples for each technical indicator.
         factory (IndicatorFactory): A factory object to generate technical indicators.
             Defaults to TalibIndicatorFactory.
 
     Returns:
         List[str]: A list of technical indicator feature names.
 
-    Example:
-
-        ```
+    Examples:
+        ```py
         import finlab.ml.feature as f
 
 
         # method 1: generate each indicator with random parameters
         features = f.ta()
 
         # method 2: generate specific indicator
@@ -251,94 +250,93 @@
 
     if factories is None:
         factories = {'talib':TalibIndicatorFactory()}
 
     if feature_names is None:
         feature_names = ta_names()
 
-    test_f = resampler(TalibIndicatorFactory().calculate_indicator("RSI", 'real', {}).loc[start_time:end_time], resample, **kwargs).unstack()
+    test_f = resampler(TalibIndicatorFactory().calculate_indicator("RSI", 'real', {}).loc[start_time:end_time], resample, **kwargs).T.unstack()
     final_columns = []
 
     def create_features() -> Generator[np.ndarray, None, None]:
 
         nonlocal final_columns
 
         for name in feature_names:
             func, output, params = IndicatorName.decode(name)
 
             factory = factories[name.split('.')[0]]
             try:
-                f = resampler(factory.calculate_indicator(func, output, params).loc[start_time:end_time], resample, **kwargs).unstack()
+                f = resampler(factory.calculate_indicator(func, output, params).loc[start_time:end_time], resample, **kwargs).T.unstack()
                 yield np.array(f.values)
                 final_columns.append(name)
 
             except Exception as e:
                 # traceback.print_exc(file=sys.stdout)
                 logging.warn(f"Cannot calculate indicator {(func, output, params)}. Skipped")
                 logging.warn(f"Exception occurred: {traceback.format_exc()}")
 
     values = np.fromiter(
             create_features(), 
             dtype=np.dtype((np.float64, len(test_f))))
     ret = pd.DataFrame(values.T, index=test_f.index, 
-                       columns=final_columns, copy=False).swaplevel(0,1)
+                       columns=final_columns, copy=False)
     ret.index.names = ['datetime', 'instrument']
+    # ret.sort_index(inplace=True)
     return ret
 
 
 
 def combine(features:Dict[str, pd.DataFrame], resample=None, sample_filter=None, **kwargs):
 
     """The combine function takes a dictionary of features as input and combines them into a single pandas DataFrame. combine 函數接受一個特徵字典作為輸入，並將它們合併成一個 pandas DataFrame。
     Args:
 
         features (Dict[str, pd.DataFrame]): a dictionary of features where index is datetime and column is instrument. 一個特徵字典，其中索引為日期時間，欄位為證券代碼。
         resample (str): Optional argument to resample the data in the features. Default is None. 選擇性的參數，用於重新取樣特徵中的資料。預設為 None。
+        sample_filter (pd.DataFrame): a boolean dictionary where index is date and columns are instrument representing the filter of features.
         **kwargs: Additional keyword arguments to pass to the resampler function. 傳遞給重新取樣函數 resampler 的其他關鍵字引數。
 
     Returns:
         A pandas DataFrame containing all the input features combined. 一個包含所有輸入特徵合併後的 pandas DataFrame。
 
     Examples:
-        The example code shows how to use the finlab.ml.feature module to combine two sets of features, RSI and price_earning_ratio, from the finlab.data module. The f.combine function is used to combine the features, with the feature names specified as keys in a dictionary and the corresponding feature data specified as values. In this example, the 'rsi' feature is obtained by calling data.indicator('RSI'), which calculates the Relative Strength Index, and the 'pb' feature is obtained by calling data.get('price_earning_ratio:股價淨值比'), which retrieves the price-to-book ratio. The resulting features variable is a DataFrame containing both sets of features combined together.
-        這個範例程式碼展示如何使用 finlab.ml.feature 模組，從 finlab.data 模組中結合兩個特徵集，RSI 和 price_earning_ratio。使用 f.combine 函數結合這些特徵，其中特徵名稱以字典的鍵形式給出，對應的特徵資料以值的形式給出。在這個範例中，'rsi' 特徵使用 data.indicator('RSI') 取得，該函數會計算相對強弱指數。'pb' 特徵使用 data.get('price_earning_ratio:股價淨值比') 取得，該函數會取得股價淨值比。最終的 features 變數是一個 DataFrame，包含這兩個特徵集的資料結合在一起。
+        這段程式碼教我們如何使用finlab.ml.feature和finlab.data模組，來合併兩個特徵：RSI和股價淨值比。我們使用f.combine函數來進行合併，其中特徵的名稱是字典的鍵，對應的資料是值。
+        我們從data.indicator('RSI')取得'rsi'特徵，這個函數計算相對強弱指數。我們從data.get('price_earning_ratio:股價淨值比')取得'pb'特徵，這個函數獲取股價淨值比。最後，我們得到一個包含這兩個特徵的DataFrame。
 
         ``` py
         from finlab import data
         import finlab.ml.feature as f
+        import finlab.ml.qlib as q
 
         features = f.combine({
-            'rsi': data.indicator('RSI'),
+            
+            # 用 data.get 簡單產生出技術指標
             'pb': data.get('price_earning_ratio:股價淨值比')
+
+            # 用 data.indicator 產生技術指標的特徵
+            'rsi': data.indicator('RSI'),
+
+            # 用 f.ta 枚舉超多種 talib 指標
+            'talib': f.ta(f.ta_names()),
+
+            # 利用 qlib alph158 產生技術指標的特徵
+            'qlib158': q.alpha('Alpha158')
+
             })
 
         features.head()
         ```
 
-        |    datetime   |            |     rsi    |     pb     |
+        |    datetime   | instrument |     rsi    |     pb     |
         |---------------|------------|------------|------------|
         |   2020-01-01  |    1101    |     0      |     2      |
         |   2020-01-02  |    1102    |     100    |     3      |
         |   2020-01-03  |    1108    |     100    |     4      |
 
-        結合其他功能產生特徵，首先，使用 data.indicator('RSI') 函數從 finlab.data 模組中計算相對強弱指數特徵，並將其以 'rsi' 為鍵值存入特徵字典。接著，使用 q.alpha('Alpha158') 函數從 finlab.ml.qlib 模組中計算 Alpha158 信號特徵，並將其以 'qlib_alpha158' 為鍵值存入特徵字典。然後，使用 f.ta(f.ta_names()) 函數結合一個包含所有 ta 名稱的特徵集，並將其以默認名稱為鍵值存入特徵字典。最後，使用 f.combine 函數將這些特徵合併成一個 pandas DataFrame。
-
-        ``` py
-        from finlab import data
-        import finlab.ml.feature as f
-        import finlab.ml.qlib as q
-
-        features = f.combine({
-            'rsi': data.indicator('RSI'),
-            'qlib158': q.alpha('Alpha158')
-            'talib': f.ta(f.ta_names()),
-            })
-
-        features.head()
-        ```
     """
 
     if len(features) == 0:
         return pd.DataFrame()
 
     def resampling(df) -> pd.DataFrame:
         return resampler(df, resample, **kwargs)
@@ -370,28 +368,29 @@
                 union_columns = udf.columns
             
     final_index = None
     for name, udf in unstacked.items():
         udf = udf\
             .reindex(index=union_index, columns=union_columns)\
             .ffill()\
+            .T\
             .unstack()
         unstacked[name] = udf.values
 
         if final_index is None:
             final_index = udf.index
 
     for i, c in enumerate(concats):
         c.index = c.index.set_names(['datetime', 'instrument'])
         if union_index is not None:
             concats[i] = c[c.index.get_level_values('datetime').isin(union_index)]
 
     if unstacked:
         unstack_df = pd.DataFrame(unstacked, index=final_index)
-        unstack_df = unstack_df.swaplevel(0, 1)
+        # unstack_df = unstack_df.swaplevel(0, 1)
         unstack_df.index = unstack_df.index.set_names(['datetime', 'instrument'])
         concats.append(unstack_df)
 
     ret = pd.concat(concats, axis=1)
     ret.sort_index(inplace=True)
 
     if sample_filter is not None:
@@ -399,14 +398,14 @@
             sample_filter = sample_filter.index_str_to_date()
         usf = resampling(sample_filter)
 
         if union_index and union_columns:
             usf = usf.reindex(index=union_index, columns=union_columns)
 
         usf = usf.ffill()\
+           .T\
            .unstack()\
-           .swaplevel(0, 1)\
            .reindex(ret.index).fillna(False)
         ret = ret[usf.values]
 
     return ret
```

## finlab/ml/label.py

```diff
@@ -12,14 +12,15 @@
 
     """Calculate the percentage change of market prices over a given period.
 
     Args:
         index (pd.Index): A multi-level index of datetime and instrument.
         resample (Optional[str]): The resample frequency for the output data. Defaults to None.
         period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
         **kwargs: Additional arguments to be passed to the resampler function.
 
     Returns:
         pd.Series: A pd.Series containing the percentage change of stock prices.
 
     """
 
@@ -30,41 +31,96 @@
     uadj = resampler(adj, resample, **kwargs)
     ret = (uadj.shift(-period) / uadj) - 1
     return align_to_feature(index, ret)
 
 
 def maximum_adverse_excursion(index: pd.Index, period=1, trade_at_price='close'):
 
+    """Calculate the maximum adverse excursion of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
     market = ml.get_market()
     assert market is not None
     adj = market.get_price(trade_at_price, adj=True).shift(-1)
     ret = adj.shift(-period).rolling(period).min() / adj - 1
     return align_to_feature(index, ret)
 
 
 def maximum_favorable_excursion(index: pd.Index, period=1, trade_at_price='close'):
 
+    """Calculate the maximum favorable excursion of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
     market = ml.get_market()
     assert market is not None
     adj = market.get_price(trade_at_price, adj=True).shift(-1)
     ret = adj.shift(-period).rolling(period).max() / adj - 1
     return align_to_feature(index, ret)
 
 
 def excess_over_median(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
 
+    """Calculate the excess over median of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
+
     market = ml.get_market()
     adj = market.get_price(trade_at_price, adj=True).shift(-1)
     uadj = resampler(adj, resample, **kwargs)
     ret = (uadj.shift(-period) / uadj) - 1
     ret -= ret.median(axis=1)
     return align_to_feature(index, ret)
 
 
 def excess_over_mean(index: pd.Index, resample=None, period=1, trade_at_price='close', **kwargs):
 
+    """Calculate the excess over mean of market prices over a given period.
+
+    Args:
+        index (pd.Index): A multi-level index of datetime and instrument.
+        resample (Optional[str]): The resample frequency for the output data. Defaults to None.
+        period (int): The number of periods to calculate the percentage change over. Defaults to 1.
+        trade_at_price (str): The price for execution. Defaults to `close`.
+        **kwargs: Additional arguments to be passed to the resampler function.
+
+    Returns:
+        pd.Series: A pd.Series containing the percentage change of stock prices.
+
+    """
     market = ml.get_market()
     adj = market.get_price(trade_at_price, adj=True).shift(-1)
     uadj = resampler(adj, resample, **kwargs)
     ret = (uadj.shift(-period) / uadj) - 1
     ret -= ret.mean(axis=1)
     return align_to_feature(index, ret)
```

## finlab/ml/qlib.py

```diff
@@ -154,15 +154,15 @@
             instruments_data.to_csv(instruments_path, header=False, sep=self.INSTRUMENTS_SEP, index=False)
         else:
             np.savetxt(instruments_path, instruments_data, fmt="%s", encoding="utf-8")
 
     def data_merge_calendar(self, df: pd.DataFrame, calendars_list: List[pd.Timestamp]) -> pd.DataFrame:
         # calendars
         calendars_df = pd.DataFrame(data=calendars_list, columns=[self.date_field_name])
-        calendars_df[self.date_field_name] = calendars_df[self.date_field_name].astype(np.datetime64)
+        calendars_df[self.date_field_name] = calendars_df[self.date_field_name].astype('datetime64[ns]')
         cal_df = calendars_df[
             (calendars_df[self.date_field_name] >= df[self.date_field_name].min())
             & (calendars_df[self.date_field_name] <= df[self.date_field_name].max())
         ]
         # align index
         cal_df.set_index(self.date_field_name, inplace=True)
         df.set_index(self.date_field_name, inplace=True)
@@ -283,15 +283,15 @@
         self._dump_features()
 
 def get_region(market):
     return ml.get_market().__class__.__name__.replace('MarketInfo', '').lower()
 
 def dump(freq='day'):
     """產生Qlib 於台股的資料庫
-    Example:
+    Examples:
         ```py
         import qlib
         import finlab.ml.qlib as q
 
         q.dump() # generate tw stock database
         q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
 
@@ -342,15 +342,15 @@
     dumper()
 
 
 qlib_initialized = False
 
 def init():
     """Qlib 初始化 (類似於台股版 qlib.init() 但更簡單易用)
-    Example:
+    Examples:
         ```py
         import qlib
         import finlab.ml.qlib as q
 
         q.dump() # generate tw stock database
         q.init() # initiate tw stock to perform machine leraning tasks (similar to qlib.init)
 
@@ -373,15 +373,15 @@
                   region=region)
 
 def alpha(handler='Alpha158', **kwargs):
 
     """產生 Qlib 的特徵
     Args:
         handler (str): 預設為 'alpha158' 也可以設定成 'Alpha360'
-    Example:
+    Examples:
         ```py
         import finlab.ml.qlib as q
         features = q.alpha('Alpha158')
         ```
     """
     init()
```

## finlab/online/sinopac_account.py

```diff
@@ -48,14 +48,19 @@
         assert quantity > 0
         assert contract is not None
 
         if price == None:
             price = self.api.snapshots([contract])[0].close
 
         if market_order:
+            price_type = sj.constant.StockPriceType.MKT
+        else:
+            price_type = sj.constant.StockPriceType.LMT
+
+        if market_order:
             if action == Action.BUY:
                 price = contract.limit_up
             elif action == Action.SELL:
                 price = contract.limit_down
         elif best_price_limit:
             if action == Action.BUY:
                 price = contract.limit_down
@@ -85,15 +90,15 @@
             order_lot = sj.constant.StockOrderLot.Odd
         if datetime.time(14,00) < datetime.time(now.hour,now.minute) and datetime.time(now.hour,now.minute) < datetime.time(14,30) and not odd_lot:
             order_lot = sj.constant.StockOrderLot.Fixing
 
         order = self.api.Order(price=price,
                                quantity=quantity,
                                action=action,
-                               price_type=sj.constant.StockPriceType.LMT,
+                               price_type=price_type,
                                order_type=sj.constant.OrderType.ROD,
                                order_cond=order_cond,
                                daytrade_short=daytrade_short,
                                account=self.api.stock_account,
                                order_lot=order_lot,
                                )
         trade = self.api.place_order(contract, order)
```

## finlab/online/utils.py

```diff
@@ -1,23 +1,23 @@
 import numpy as np
+import pandas as pd
 
-def greedy_allocation(weights, latest_prices, total_portfolio_value=10000, short_ratio=None):
+def greedy_allocation(weights, latest_prices, total_portfolio_value=10000):
 
     """
     original source code: PyPortfolioOpt
     https://pypi.org/project/pyportfolioopt/
     """
 
-    weights.index = weights.index.str.split(' ').str[0]
+    weights = pd.Series(weights)
+
+    weights.index = weights.index.to_series().astype(str)\
+            .str.split(' ').str[0]
     weights = list(weights.items())
     latest_prices = latest_prices
-    if short_ratio is None:
-        short_ratio = sum((-x[1] for x in weights if x[1] < 0))
-    else:
-        short_ratio = short_ratio
 
     if len(weights) == 0:
         return {}, total_portfolio_value
 
     """
     Convert continuous weights into a discrete portfolio allocation
     using a greedy iterative approach.
@@ -43,18 +43,16 @@
         # Make them sum to one
         long_total_weight = sum(longs.values())
         short_total_weight = sum(shorts.values())
         longs = {t: w / long_total_weight for t, w in longs.items()}
         shorts = {t: w / short_total_weight for t, w in shorts.items()}
 
         # Construct long-only discrete allocations for each
-        short_val = total_portfolio_value * short_ratio
-        long_val = total_portfolio_value
-        if reinvest:
-            long_val += short_val
+        short_val = total_portfolio_value * short_total_weight
+        long_val = total_portfolio_value * long_total_weight
 
         if verbose:
             print("\nAllocating long sub-portfolio...")
         # da1 = DiscreteAllocation(
         #     longs, latest_prices[longs.keys()], total_portfolio_value=long_val
         # )
         long_alloc, long_leftover = greedy_allocation(longs, latest_prices, long_val)
@@ -135,9 +133,10 @@
         shares_bought[idx] += 1
         available_funds -= price
 
     allocation = dict(zip([i[0] for i in weights], shares_bought))
 
     if verbose:
         print("Funds remaining: {:.2f}".format(available_funds))
-        _allocation_rmse_error(verbose)
     return allocation, available_funds
+
+
```

## finlab/optimize/combinations.py

```diff
@@ -1,11 +1,11 @@
 from itertools import combinations
 import pandas as pd
 from finlab.backtest import sim
-from finlab.report import Report
+from finlab.core.report import Report
 from finlab.utils import logger
 
 
 def sim_conditions(conditions, hold_until={}, *args, **kwargs):
     """取得回測報告集合
 
     將選股條件排出所有的組合並進行回測，方便找出最好條件的交集結果。
@@ -107,53 +107,54 @@
     def get_stats(self):
         """取得策略指標比較表
 
         指標欄位說明：
 
         * `'daily_mean'`: 策略年化報酬
         * `'daily_sharpe'`: 策略年化夏普率
-        * `'daily_sortino'`: 策略年化索提諾比率 - 下檔波動度
-        * `'max_drawdown'`: 策略報酬率最大回撤率
-        * `'avg_drawdown'`: 策略平均回撤
-        * `'ytd'`: 今年度策略報酬
+        * `'daily_sortino'`: 策略年化索提諾比率
+        * `'max_drawdown'`: 策略報酬率最大回撤率(負向)
+        * `'avg_drawdown'`: 策略平均回撤(負向)
+        * `'ytd'`: 今年度策略報酬率
         * `'win_ratio'`: 每筆交易勝率
         * `'avg_return'`: 每筆交易平均獲利率
-        * `'avg_mae'`: 每筆交易平均最大不利方向幅度
+        * `'avg_mae'`: 每筆交易平均最大不利方向幅度(負向)
         * `'avg_bmfe'`: 最大不利方向發生前的"每筆交易平均最大有利方向幅度"，若數值越高，越有機會在停損之前操作停利。
         * `'avg_gmfe'`: 每筆交易平均最大有利方向幅度
-        * `'avg_mdd'`: 每筆交易平均的最大回撤率
+        * `'avg_mdd'`: 每筆交易平均的最大回撤率(負向)
 
         Returns:
           (pd.DataFrame): 策略指標比較報表
         """
 
-        def get_strategy_indexes(report):
+        def get_strategy_indicators(report):
             if isinstance(report, Report):
                 stats = report.get_stats()
                 trades = report.trades
                 strategy_indexes = {n: stats[n] for n in
                                     ['daily_mean', 'daily_sharpe',
                                      'daily_sortino', 'max_drawdown',
                                      'avg_drawdown']}
                 trade_indexes = {'win_ratio': stats['win_ratio']}
                 trade_indexes.update(
                     {f'avg_{n}': trades[n].mean() for n in ['return', 'mae', 'bmfe', 'gmfe', 'mdd']})
                 strategy_indexes.update(trade_indexes)
                 return strategy_indexes
 
-        df = pd.DataFrame({k: get_strategy_indexes(v) for k, v in self.reports.items()})
+        df = pd.DataFrame({k: get_strategy_indicators(v) for k, v in self.reports.items()})
         self.stats = df
         return df
 
-    def plot_stats(self, mode='bar', heatmap_sort_by='avg_score'):
+    def plot_stats(self, mode='bar', heatmap_sort_by='avg_score', indicators=[]):
         """策略指標比較報表視覺化
 
         Args:
           mode (str): 繪圖模式。`'bar'` - 指標分群棒狀圖。`'heatmap'` - 指標分級熱力圖。
-          heatmap_sort_by (str or list of str): heatmap 冪排序的決定欄位
+          heatmap_sort_by (str or list of str): heatmap 降冪排序的決定欄位
+          indicators (list): 要顯示的特定指標欄位，預設為將指標全部顯示
 
         Returns:
           (plotly.graph_objects.Figure): 長條圖
           (pd.DataFrame): 熱力圖
 
         Examples:
             ex1:
@@ -171,14 +172,19 @@
             預設以avg_score為排序，數值越大為排名越前面，分數越高為整體評價較優的策略。
 
             ![heatmap](img/optimize/report_collection_stats_heatmap.png)
         """
         if self.stats is None:
             self.get_stats()
         df = self.stats
+        if len(indicators) > 0:
+            try:
+                df = df.loc[indicators]
+            except KeyError:
+                logger.error(f"Indicators selection must be in {list(df.index)}")
         if mode == 'bar':
             import plotly.graph_objects as go
             items = df.columns
             fig = go.Figure(data=[go.Bar(x=df.index, y=df[item], name=item, meta=[item],
                                          hovertemplate="%{meta}<br>%{label}<br>%{y}<extra></extra>") for item in items])
             # Change the bar mode
             fig.update_layout(title={'text': 'Backtest combinations stats', 'x': 0.49, 'y': 0.9, 'xanchor': 'center',
```

## Comparing `finlab-0.4.2.dist-info/LICENSE` & `finlab-0.4.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `finlab-0.4.2.dist-info/METADATA` & `finlab-0.4.3.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: finlab
-Version: 0.4.2
+Version: 0.4.3
 Summary: Analyzing stock has never been easier.
 Author: FinLab
 Author-email: finlab.company@finlab.tw
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
```

## Comparing `finlab-0.4.2.dist-info/RECORD` & `finlab-0.4.3.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,46 +1,54 @@
-finlab/__init__.py,sha256=8nL_VXyUEDS1gSqeN0R19KV4DwKssZ8FftUjKHYA3Ls,2450
-finlab/aes.cp39-win_amd64.pyd,sha256=I8RcBI7Oq9jXKTnhmb49vXj2RIaDzpARQO6l4kab-P0,206848
-finlab/backtest.py,sha256=39JEASSKOwUBJsKO1pXP6y-0IsyXSwelSDZYwzCgbwI,22767
-finlab/backtest_core.cp39-win_amd64.pyd,sha256=uHMALNmV6oaz6PwC6NwN6bDZgZ8BZsEwOyi0baLuVBk,133120
+finlab/__init__.py,sha256=UuNbdjDsc_2JE4qS47jXKDnyWZMneVZn77tzZACWC58,2507
+finlab/backtest.py,sha256=PGfO-SoplIsyTNcYFHBTrRb0tCiWn8V9atxxXg4bRzE,22853
 finlab/backtest_old.py,sha256=7K66Z0BkT1zsLc4F6POlLrVF7khPVhLXL69wRgE3ay8,1424
 finlab/cells.py,sha256=nRlhr8mvdViA7P8d9rHtCYe8tqbY8gVHzHsvzhY9TCo,915
-finlab/data.py,sha256=26ZM5fMR7IUNvQLcR2QwxuDRhbgvrqUBauvfFZXdIJ8,29089
-finlab/dataframe.py,sha256=_fZCpdEcoeZ1BtI-42FMFd20QsGqpVBKRFayvU5isnQ,29113
+finlab/data.py,sha256=uSv0ISG-Sdq5OqNCekmakSbi4Gt725m2bDC4JKq0bCs,29964
+finlab/dataframe.py,sha256=pBdH5zm22U7dvzyRvCzs3f6EqEwYe8FfcsK2tp2Dwx0,30989
 finlab/ffn_core.py,sha256=LTHkl6HVzkhUlMPqNGqEkN92ux7Q7VOXlljWIM41N0o,80750
-finlab/mae_mfe.cp39-win_amd64.pyd,sha256=ZABM6ssJqq7rlOIQpqzadplsmg0GPtT0SY-Tfv5-oxc,71680
-finlab/mae_mfe.pxd,sha256=Lmf_StbLnzvQhIxqae_V47MOFgp_IsylFmgmVdnwIFg,460
-finlab/market_info.py,sha256=2IXny2DfSm8A8iLemZxZuKyv8nlNXiy-OG7wX-J9hWs,5105
+finlab/market_info.py,sha256=zjEEZyDlhy1IgcQxiLW-eonKRtKq_biiJeCoqooLQ2I,6284
 finlab/plot.py,sha256=HJtYLY0dhjxQnSTlP4CCsnvvbzb64VyTKMsK-Mr8je8,36257
-finlab/report.cp39-win_amd64.pyd,sha256=LGF_1XlCFz-p95N0SsCDroK1y7c_ac0xoIn0dGTje2Y,167424
-finlab/utils.py,sha256=QVttpM6h85PggRsRIMXs44kMz9ktsyoKgbnKkRPm1Jg,5132
-finlab/utils_core.cp39-win_amd64.pyd,sha256=9KAhisMJ3b34M-knJs-wmR4ube5ooxdr8dWBU4VmdH0,19968
-finlab/analysis/__init__.py,sha256=YboGTgUSD6RRHD4p58FT3hB_DerT6T_vNlWXlNCJbsg,7287
-finlab/analysis/alphaBetaAnalysis.py,sha256=6ixBH9JT4ERx_i5qTuumr3-WgJhp4upsJEZgbzGe2Nc,1988
+finlab/utils.py,sha256=QBax4udoR1QCRAJsMNSLPx8naekatZYLwFIgyUZn2Yk,5246
+finlab/analysis/__init__.py,sha256=Hhfp2KNKcxwDWehLKgqP51cZnnrYH5n6juZnylRT0Og,7316
+finlab/analysis/alphaBetaAnalysis.py,sha256=ZNv3LwMlnb8JT1--AnMCUPcDPvMVHeKN0A_2oWN8k6E,2110
 finlab/analysis/drawdownAnalysis.py,sha256=B9lhGVwBkwbJCfg8ac0xVk9EoaErB1x0prmz9q7_A7s,1449
 finlab/analysis/inequalityAnalysis.py,sha256=PuE11Eloz22SSBlLURmzO9CBAx5fnEX1_qa5IKUp70Q,5007
-finlab/analysis/liquidityAnalysis.py,sha256=YlpYg52TWZ6d_gmCTAGjcaaHtZ3iwsoKdUpptrs_QBw,4626
-finlab/analysis/maeMfeAnalysis.py,sha256=sWPvaRRLmZN1FU7qWjedpI0PhXdZVhhC7UUJyg-71Is,12343
-finlab/analysis/periodStatsAnalysis.py,sha256=ECB91mTNvM3sjB_WfwGU_8W3iadQYGcfL-vVE2a0Pss,3618
+finlab/analysis/liquidityAnalysis.py,sha256=jWHGZPuN4Kym-1ZixQB7i4FfCsGhnMKOmnlpOno_hCc,4735
+finlab/analysis/maeMfeAnalysis.py,sha256=6XMmwqUmyzH4hm_GDzGLUVzaNonntGQAJDmo9mfXn5A,12329
+finlab/analysis/periodStatsAnalysis.py,sha256=-rlw6O4cde4OnazMCAFzsi-WDyrSGU_TYvvQRh_opCI,7481
+finlab/core/__init__.py,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
+finlab/core/aes.cp310-win_amd64.pyd,sha256=q6Apo7Js5O1DRpk1QoIPT-e8FkXM3bAob0Nn6hqhiMc,196608
+finlab/core/aes.pyx,sha256=pM0HmpHkhwrrHCO3Ttu8u30awg3afwl85FHWxEZSXNs,19593
+finlab/core/backtest_core.cp310-win_amd64.pyd,sha256=79eUPjs28bnR923xMWdIOHTeOppKp80cRv1Fq0TTh-Y,131584
+finlab/core/backtest_core.pyx,sha256=ZowiXOff9zya4vbk7zJz2_xBg-0xX-9nISjCip8spsk,18552
+finlab/core/mae_mfe.cp310-win_amd64.pyd,sha256=_G7n3cjigriQVT7ikcbrS40ixfPPecQmaNDMP35MzUg,71168
+finlab/core/mae_mfe.pxd,sha256=QhQ5XrKji18sjmw6JX2ivD-I4amt0lhGIPgQch0MFjY,485
+finlab/core/mae_mfe.pyx,sha256=cJ8vHLggaRABKL3gYtyooCbusXjySPU3ukt76LB_Cbc,6119
+finlab/core/report.cp310-win_amd64.pyd,sha256=FNi6bpBTOCyIkHkJ1ybZdJZDNaLM6w0ARZUmIXbF408,166400
+finlab/core/report.pyx,sha256=eG2oRzLTqBexZoaXmISRqvcRjTkBqDFbX3uiIsxfEno,19675
+finlab/core/utils_core.cp310-win_amd64.pyd,sha256=rqSlocDOpJA4F8SXXP-x7wxe-igiqlVd53-TWkFcoMc,18944
+finlab/core/utils_core.pyx,sha256=o51-Oucjoip7tIsMle-lRryUhSHpX1afY2m-AovIQAM,88
 finlab/ml/__init__.py,sha256=oV4GCvyk_mXbfhR0cH5CzDn970EVlYhS8sSUh0KIkpY,704
-finlab/ml/alphalens.py,sha256=omMSqjVwSgY8_izLM8umrf_t2cwGwBr8Nxwntnj-ZVY,3879
-finlab/ml/feature.py,sha256=moHX-OJFzY5FHCSPXm4CXIXIaM7tgEcHaymXWHYvU0o,15609
-finlab/ml/label.py,sha256=Ayn8xf-0zbyQYndnUv0cLNxE3B3Vs_8TbAmplSgrp1I,2559
-finlab/ml/qlib.py,sha256=c-yFL6VR6GL7rpLhuTp9XyJoZxcQRlFNB7Ew0UzFbns,18065
+finlab/ml/alphalens.py,sha256=XUpG9So0W8q8cqfjT9FKO6AOQeX9qXMAjUGxe6fKGww,3912
+finlab/ml/cpcv.py,sha256=Uua_tfkLTuHltAsCUsTeSKH8Jw-gnU1PJV1ddgQip6s,5160
+finlab/ml/feature.py,sha256=NGNQBW_laSGWANP0Z-_Vh-gFOfYyqyTfZkaitMog2-w,14448
+finlab/ml/label.py,sha256=8SGADra4aIl3kF7duhjDLaqpTAJasxLq5_CK4jVCvks,5180
+finlab/ml/qlib.py,sha256=34sL56TFs9rCP6SHvVB0LGNVklrDKV3L8TNr25aFi3I,18071
 finlab/ml/utils.py,sha256=UiKIfL69zREH9GrOP_MRQxUA162D9PzHRqXSEj64odI,3131
 finlab/online/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 finlab/online/base_account.py,sha256=PiIQjIgjTf6fcYtlbWevwZ_T40qvwpBjesdecvWd1ok,8155
 finlab/online/binance_account.py,sha256=bxTsx1sI1BDnx1OKWAxTvWm96-BGsWCrxQNOHszJ1Xg,12766
 finlab/online/dashboard.py,sha256=hhLoQDgytda4xW_wOLb3rlOO_j_W5aILlwjNrKwX2QI,7264
 finlab/online/enums.py,sha256=7X5VmoaffdVDFNiRF-EIeRBtroGmLGEryVlxLmurWro,263
 finlab/online/fugle_account.py,sha256=Dvk6TA6FLWFXDWnY3034kG1n8BLu0dcepo-jUw0RJNA,12844
 finlab/online/order_executor.py,sha256=D4n_4SqtzySZEaC21OC0T4FBK0oQRYpncUxYsA8aCIM,17131
 finlab/online/panel.py,sha256=pL7vHsZfmNYI0LqZN-2amZgPXyViznUqNCzQTZVz170,13122
-finlab/online/sinopac_account.py,sha256=fp4DaWFaHof93yqhDuZXwBeFP2KRFVjQOdk0VtriH-M,8537
-finlab/online/utils.py,sha256=CiLEnPvB5e94eNKaOISe0b1-YG_JHhJF5LYpRyWoN_o,5432
+finlab/online/sinopac_account.py,sha256=BxXO8UmjQvReBMGMXZQHsaD8fHurWOunicaY4juceQw,8674
+finlab/online/test.py,sha256=aJpQ_j8RAhPrbC4JkuuXoHaOWrkzxKZOcIkbPaO0uRM,3158
+finlab/online/utils.py,sha256=Yv_wf_icMkmKTOOSNqjK7jIbue53ZhfR--xOyFhftns,5303
 finlab/optimize/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-finlab/optimize/combinations.py,sha256=3KSMgffs6QJUcLBg_0gMbdrjxBKoix9gU9xlsmLmud4,8815
-finlab-0.4.2.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-finlab-0.4.2.dist-info/METADATA,sha256=pNCjmTyGpJvBM-M2K4QZecXvoh_zJsxZXgY0xZuLJkE,3879
-finlab-0.4.2.dist-info/WHEEL,sha256=eep6QWEFiQfg2wcclssb_WY-D33AnLYLnEKGA9Rn-VU,100
-finlab-0.4.2.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
-finlab-0.4.2.dist-info/RECORD,,
+finlab/optimize/combinations.py,sha256=8tONNTmeXAoay4xPNhKSjJuvec6ikSIjUrqkuBd8KU4,9160
+finlab-0.4.3.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+finlab-0.4.3.dist-info/METADATA,sha256=ZFg6UZGmwdWyLad-RpZbFYlkPMPiVTL5lwGT2DjGS94,3879
+finlab-0.4.3.dist-info/WHEEL,sha256=jrOhEbqKwvzRFSJcbYXlJCyVkgVdHg4_7__YHrdTUfw,102
+finlab-0.4.3.dist-info/top_level.txt,sha256=m5gMT8MS1RxoL-WPzxP83LozK_ubRB3AN7d9shpXNIQ,7
+finlab-0.4.3.dist-info/RECORD,,
```

