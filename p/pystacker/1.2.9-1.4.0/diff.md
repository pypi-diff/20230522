# Comparing `tmp/pystacker-1.2.9-py3.10.egg` & `tmp/pystacker-1.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,29 @@
-Zip file size: 54871 bytes, number of entries: 37
--rw-rw-r--  2.0 unx    30874 b- defN 23-May-07 16:06 EGG-INFO/PKG-INFO
--rw-rw-r--  2.0 unx      601 b- defN 23-May-07 16:06 EGG-INFO/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-07 16:06 EGG-INFO/dependency_links.txt
--rw-rw-r--  2.0 unx       49 b- defN 23-May-07 16:06 EGG-INFO/entry_points.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-07 16:06 EGG-INFO/not-zip-safe
--rw-rw-r--  2.0 unx       21 b- defN 23-May-07 16:06 EGG-INFO/requires.txt
--rw-rw-r--  2.0 unx       13 b- defN 23-May-07 16:06 EGG-INFO/top_level.txt
--rw-rw-r--  2.0 unx      352 b- defN 23-May-04 23:19 stacker/__init__.py
--rw-rw-r--  2.0 unx       72 b- defN 23-Apr-23 11:23 stacker/__main__.py
--rw-rw-r--  2.0 unx    35909 b- defN 23-May-06 23:48 stacker/stacker.py
--rw-rw-r--  2.0 unx      372 b- defN 23-May-07 16:06 stacker/__pycache__/__init__.cpython-310.pyc
--rw-rw-r--  2.0 unx      229 b- defN 23-May-07 16:06 stacker/__pycache__/__main__.cpython-310.pyc
--rw-rw-r--  2.0 unx    30863 b- defN 23-May-07 16:06 stacker/__pycache__/stacker.cpython-310.pyc
--rw-rw-r--  2.0 unx      652 b- defN 23-Apr-20 23:02 stacker/data/about.txt
--rw-rw-r--  2.0 unx     2835 b- defN 23-Apr-21 20:53 stacker/data/help-jp.txt
--rw-rw-r--  2.0 unx     2589 b- defN 23-Apr-21 20:45 stacker/data/help.txt
--rw-rw-r--  2.0 unx      232 b- defN 23-Apr-19 23:25 stacker/data/top.txt
--rw-rw-r--  2.0 unx        0 b- defN 23-May-04 23:17 stacker/plugins/__init__.py
--rw-rw-r--  2.0 unx      385 b- defN 23-May-06 23:25 stacker/plugins/branch.py
--rw-rw-r--  2.0 unx     3998 b- defN 23-May-05 23:12 stacker/plugins/matrix.py
--rw-rw-r--  2.0 unx      891 b- defN 23-May-05 01:27 stacker/plugins/range.py
--rw-rw-r--  2.0 unx     3034 b- defN 23-May-04 23:47 stacker/plugins/sh.py
--rw-rw-r--  2.0 unx      377 b- defN 23-May-06 17:23 stacker/plugins/strcon.py
--rw-rw-r--  2.0 unx     1360 b- defN 23-May-06 00:50 stacker/plugins/tolist.py
--rw-rw-r--  2.0 unx      149 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/__init__.cpython-310.pyc
--rw-rw-r--  2.0 unx      607 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/branch.cpython-310.pyc
--rw-rw-r--  2.0 unx     3698 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/matrix.cpython-310.pyc
--rw-rw-r--  2.0 unx      836 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/range.cpython-310.pyc
--rw-rw-r--  2.0 unx     2569 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/sh.cpython-310.pyc
--rw-rw-r--  2.0 unx      651 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/strcon.cpython-310.pyc
--rw-rw-r--  2.0 unx     1374 b- defN 23-May-07 16:06 stacker/plugins/__pycache__/tolist.cpython-310.pyc
--rw-rw-r--  2.0 unx        0 b- defN 23-May-04 23:11 test/__init__.py
--rw-rw-r--  2.0 unx    10243 b- defN 23-May-06 21:16 test/test.py
--rw-rw-r--  2.0 unx     5143 b- defN 23-May-04 23:21 test/test_matrix_operations_plugin.py
--rw-rw-r--  2.0 unx      138 b- defN 23-May-07 16:06 test/__pycache__/__init__.cpython-310.pyc
--rw-rw-r--  2.0 unx     7154 b- defN 23-May-07 16:06 test/__pycache__/test.cpython-310.pyc
--rw-rw-r--  2.0 unx     4586 b- defN 23-May-07 16:06 test/__pycache__/test_matrix_operations_plugin.cpython-310.pyc
-37 files, 152858 bytes uncompressed, 49731 bytes compressed:  67.5%
+Zip file size: 35120 bytes, number of entries: 27
+-rw-rw-r--  2.0 unx      352 b- defN 23-May-18 19:34 stacker/__init__.py
+-rw-rw-r--  2.0 unx       72 b- defN 23-Apr-23 02:23 stacker/__main__.py
+-rw-rw-r--  2.0 unx    39946 b- defN 23-May-22 14:04 stacker/stacker.py
+-rw-rw-r--  2.0 unx     2722 b- defN 23-May-22 14:04 stacker/valiable.py
+-rw-rw-r--  2.0 unx     2722 b- defN 23-May-18 19:35 stacker/variable.py
+-rw-rw-r--  2.0 unx      652 b- defN 23-Apr-20 14:02 stacker/data/about.txt
+-rw-rw-r--  2.0 unx     2835 b- defN 23-Apr-21 11:53 stacker/data/help-jp.txt
+-rw-rw-r--  2.0 unx     2589 b- defN 23-Apr-21 11:45 stacker/data/help.txt
+-rw-rw-r--  2.0 unx      232 b- defN 23-Apr-19 14:25 stacker/data/top.txt
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-08 11:02 stacker/plugins/__init__.py
+-rw-rw-r--  2.0 unx      381 b- defN 23-May-22 14:04 stacker/plugins/branch.py
+-rw-rw-r--  2.0 unx     3915 b- defN 23-May-22 14:04 stacker/plugins/matrix.py
+-rw-rw-r--  2.0 unx      891 b- defN 23-May-08 11:02 stacker/plugins/range.py
+-rw-rw-r--  2.0 unx     3034 b- defN 23-May-04 14:47 stacker/plugins/sh.py
+-rw-rw-r--  2.0 unx      374 b- defN 23-May-22 14:04 stacker/plugins/show_all_variables.py
+-rw-rw-r--  2.0 unx      377 b- defN 23-May-08 11:02 stacker/plugins/strcon.py
+-rw-rw-r--  2.0 unx     1626 b- defN 23-May-22 14:04 stacker/plugins/tolist.py
+-rw-rw-r--  2.0 unx      806 b- defN 23-May-22 14:04 stacker/plugins/whos.py
+-rw-rw-r--  2.0 unx        0 b- defN 23-May-08 11:02 test/__init__.py
+-rw-rw-r--  2.0 unx    10542 b- defN 23-May-22 14:04 test/test.py
+-rw-rw-r--  2.0 unx     5143 b- defN 23-May-18 10:32 test/test_matrix_operations_plugin.py
+-rw-rw-r--  2.0 unx     1065 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    35357 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       49 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       13 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2155 b- defN 23-May-22 14:07 pystacker-1.4.0.dist-info/RECORD
+27 files, 117942 bytes uncompressed, 31668 bytes compressed:  73.1%
```

## zipnote «TEMP»/diffoscope_sllui19i_/tmpfou7pvp2_.zip

```diff
@@ -1,44 +1,20 @@
-Filename: EGG-INFO/PKG-INFO
-Comment: 
-
-Filename: EGG-INFO/SOURCES.txt
-Comment: 
-
-Filename: EGG-INFO/dependency_links.txt
-Comment: 
-
-Filename: EGG-INFO/entry_points.txt
-Comment: 
-
-Filename: EGG-INFO/not-zip-safe
-Comment: 
-
-Filename: EGG-INFO/requires.txt
-Comment: 
-
-Filename: EGG-INFO/top_level.txt
-Comment: 
-
 Filename: stacker/__init__.py
 Comment: 
 
 Filename: stacker/__main__.py
 Comment: 
 
 Filename: stacker/stacker.py
 Comment: 
 
-Filename: stacker/__pycache__/__init__.cpython-310.pyc
-Comment: 
-
-Filename: stacker/__pycache__/__main__.cpython-310.pyc
+Filename: stacker/valiable.py
 Comment: 
 
-Filename: stacker/__pycache__/stacker.cpython-310.pyc
+Filename: stacker/variable.py
 Comment: 
 
 Filename: stacker/data/about.txt
 Comment: 
 
 Filename: stacker/data/help-jp.txt
 Comment: 
@@ -60,53 +36,47 @@
 
 Filename: stacker/plugins/range.py
 Comment: 
 
 Filename: stacker/plugins/sh.py
 Comment: 
 
-Filename: stacker/plugins/strcon.py
-Comment: 
-
-Filename: stacker/plugins/tolist.py
-Comment: 
-
-Filename: stacker/plugins/__pycache__/__init__.cpython-310.pyc
+Filename: stacker/plugins/show_all_variables.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/branch.cpython-310.pyc
+Filename: stacker/plugins/strcon.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/matrix.cpython-310.pyc
+Filename: stacker/plugins/tolist.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/range.cpython-310.pyc
+Filename: stacker/plugins/whos.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/sh.cpython-310.pyc
+Filename: test/__init__.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/strcon.cpython-310.pyc
+Filename: test/test.py
 Comment: 
 
-Filename: stacker/plugins/__pycache__/tolist.cpython-310.pyc
+Filename: test/test_matrix_operations_plugin.py
 Comment: 
 
-Filename: test/__init__.py
+Filename: pystacker-1.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: test/test.py
+Filename: pystacker-1.4.0.dist-info/METADATA
 Comment: 
 
-Filename: test/test_matrix_operations_plugin.py
+Filename: pystacker-1.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: test/__pycache__/__init__.cpython-310.pyc
+Filename: pystacker-1.4.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: test/__pycache__/test.cpython-310.pyc
+Filename: pystacker-1.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: test/__pycache__/test_matrix_operations_plugin.cpython-310.pyc
+Filename: pystacker-1.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## stacker/stacker.py

```diff
@@ -1,18 +1,22 @@
 from __future__ import annotations
 
+import argparse
 import ast
 import cmath
 import copy
 import importlib
+import logging
 import math
 import os
 import random
 import re
+import shutil
 import sys
+import traceback
 from pathlib import Path
 from typing import Any, Optional
 
 from pkg_resources import get_distribution, resource_stream
 from prompt_toolkit import prompt
 from prompt_toolkit.completion import WordCompleter
 from prompt_toolkit.history import FileHistory
@@ -39,14 +43,43 @@
     "lightmagenta": "\033[95m",
     "lightcyan": "\033[96m",
     "white": "\033[97m",
     "reset": "\033[0m",
 }
 
 
+def parse_string(s):
+    result = []
+    current_token = ""
+    brackets = {"[": "]", "(": ")", "{": "}", "'": "'", '"': '"'}
+    bracket_stack = []
+    for char in s:
+        if char in brackets:
+            bracket_stack.append(char)
+            current_token += char
+        elif bracket_stack:
+            current_token += char
+            if char == brackets[bracket_stack[-1]]:
+                bracket_stack.pop()
+                if not bracket_stack:
+                    result.append(current_token)
+                    current_token = ""
+        elif char.isspace():
+            if current_token:
+                result.append(current_token)
+                current_token = ""
+        else:
+            current_token += char
+    if current_token:  # add the last token if any
+        result.append(current_token)
+    logging.debug(f"parse string: {s}")
+    logging.debug(f"parsed: {result}")
+    return result
+
+
 def colored(text: str, color: Optional[str] = "default", end: str = "\n") -> None:
     """A context manager for setting and resetting the terminal color.
     Args:
         color (str, optional): The desired text color. Defaults to "default".
     Returns:
         None
     """
@@ -83,56 +116,185 @@
 
 def delete_history() -> None:
     if history_file_path.exists():
         history_file_path.unlink()
 
 
 def evaluate_token_or_return_str(token: str) -> Any:
+    logging.debug(f"evaluate_token_or_return_str: {token}")
     try:
         return ast.literal_eval(token)
-    except (ValueError, SyntaxError):
+    except (ValueError, SyntaxError) as e:
+        logging.debug(f"token ({token}) is str")
+        logging.debug(f"{e}")
         return token
 
 
-def is_array(expression: str) -> bool:
+def starts_with_char(expression: str, char: str) -> bool:
     try:
-        return expression.strip().startswith("[")
+        return expression.strip().startswith(char)
     except Exception:
         return False
 
 
+def is_balanced(expression: str, open_char: str, close_char: str) -> bool:
+    open_count = expression.count(open_char)
+    close_count = expression.count(close_char)
+    return open_count == close_count
+
+
+def is_single(expression: str, open_char: str, close_char: str) -> bool:
+    if is_balanced(expression, open_char, close_char):
+        return expression.count(open_char) == 1 and expression.count(close_char) == 1
+    return False
+
+
+def is_array(expression: str) -> bool:
+    return starts_with_char(expression, "[")
+
+
 def is_tuple(expression: str) -> bool:
-    try:
-        return expression.strip().startswith("(")
-    except Exception:
-        return False
+    return starts_with_char(expression, "(")
+
+
+def is_brace(expression: str) -> bool:
+    return starts_with_char(expression, "{")
 
 
 def is_array_balanced(expression: str) -> bool:
-    open_brackets = expression.count('[')
-    close_brackets = expression.count(']')
-    return open_brackets == close_brackets
+    return is_balanced(expression, "[", "]")
 
 
 def is_tuple_balanced(expression: str) -> bool:
-    open_brackets = expression.count('(')
-    close_brackets = expression.count(')')
-    return open_brackets == close_brackets
+    return is_balanced(expression, "(", ")")
+
+
+def is_brace_balanced(expression: str) -> bool:
+    return is_balanced(expression, "{", "}")
 
 
 def is_single_array(expression: str) -> bool:
-    if is_array_balanced(expression):
-        return expression.count('[') == 1 and expression.count(']') == 1
-    return False
+    return is_single(expression, "[", "]")
 
 
 def is_single_tuple(expression: str) -> bool:
-    if is_tuple_balanced(expression):
-        return expression.count('(') == 1 and expression.count(')') == 1
-    return False
+    return is_single(expression, "(", ")")
+
+
+def is_single_brace(expression: str) -> bool:
+    return is_single(expression, "{", "}")
+
+
+def convert_custom_array_to_proper_list(token: str) -> str:
+    """
+    Converts a custom list token into a proper Python list.
+
+    :param token: The custom list token to be converted.
+    :return: The converted token as a proper Python list.
+
+    Example:
+    Input:  "[1 2 3; 4 5 6]"
+    Output: "[[1, 2, 3], [4, 5, 6]]"
+    """
+    token = re.sub(r"(\d+(\.\d+)?)\s+", r"\1, ", token)
+    token = re.sub(r";\s+", r"], [", token)
+
+    open_brackets = token.count('[')
+    close_brackets = token.count(']')
+    if open_brackets > close_brackets:
+        token += ']' * (open_brackets - close_brackets)
+    if is_array(token) and not is_single_array(token):
+        token = f"[{token}]"
+    return token
+
+
+def convert_custom_tuple_to_proper_tuple(token: str) -> str:
+    """
+    Converts a custom tuple token into a proper Python tuple.
+
+    :param token: The custom tuple token to be converted.
+    :return: The converted token as a proper Python tuple.
+
+    Example:
+    Input:  "(1 2 3; 4 5 6)"
+    Output: "((1, 2, 3), (4, 5, 6))"
+    """
+    token = re.sub(r"(\d+(\.\d+)?)\s+", r"\1, ", token)
+    token = re.sub(r";\s+", r"), (", token)
+
+    open_parenthesis = token.count('(')
+    close_parenthesis = token.count(')')
+    if open_parenthesis > close_parenthesis:
+        token += ')' * (open_parenthesis - close_parenthesis)
+    if is_tuple(token) and not is_single_tuple(token):
+        token = f"({token})"
+    return token
+
+
+def convert_custom_numeric_tuple_to_proper_tuple(token: str) -> str:
+    """
+    Converts a custom tuple token into a proper Python tuple.
+
+    :param token: The custom tuple token to be converted.
+    :return: The converted token as a proper Python tuple.
+
+    Example:
+    Input:  "(1 2 3; 4 5 6)"
+    Output: "((1, 2, 3), (4, 5, 6))"
+    """
+    token = re.sub(r"(\d+(\.\d+)?)\s+", r"\1, ", token)
+    token = re.sub(r";\s+", r"), (", token)
+
+    open_parenthesis = token.count('(')
+    close_parenthesis = token.count(')')
+    if open_parenthesis > close_parenthesis:
+        token += ')' * (open_parenthesis - close_parenthesis)
+    if is_tuple(token) and not is_single_tuple(token):
+        token = f"({token})"
+    return token
+
+
+def convert_custom_string_tuple_to_proper_tuple(token: str) -> str:
+    """
+    Converts a custom tuple token with string elements into a proper Python tuple.
+
+    :param token: The custom tuple token to be converted.
+    :return: The converted token as a proper Python tuple.
+
+    Example:
+    Input:  "(a b)"
+    Output: "("a", "b")"
+    """
+    # Convert sequences of non-number, non-punctuation characters to
+    #    use commas and surround with quotes
+    token = re.sub(r"([a-zA-Z_]\w*)\s*", r'"\1", ', token)
+    # Change semicolons to tuple separators
+    token = re.sub(r";\s*", r"), (", token)
+
+    open_parenthesis = token.count('(')
+    close_parenthesis = token.count(')')
+    if open_parenthesis > close_parenthesis:
+        token += ')' * (open_parenthesis - close_parenthesis)
+    if is_tuple(token) and not is_single_tuple(token):
+        token = f"({token})"
+
+    # Clean up any trailing commas and quotes
+    token = re.sub(r", \)", r")", token)
+    token = re.sub(r'", ', r'",', token)
+    return token
+
+
+def is_block(expression: str) -> bool:
+    if not isinstance(expression, str):
+        return False
+    opener = expression.count('{')
+    closer = expression.count('}')
+    if opener == 0 and closer == 0:
+        return False
+    return opener == closer
 
 
 def is_assignment(expression: str) -> bool:
     return re.search(r"\b\w+\s*=(?!=)", expression)
 
 
 def convert_to_base(value: str | int, base: int) -> str | int:
@@ -203,15 +365,15 @@
 math_asinh = wrap(math.asinh, cmath.asinh)
 math_acosh = wrap(math.acosh, cmath.acosh)
 math_atanh = wrap(math.atanh, cmath.atanh)
 math_sqrt = wrap(math.sqrt, cmath.sqrt)
 
 
 class StackerCore:
-    def __init__(self, plugin_dir: str = plugins_dir_path):
+    def __init__(self):
         self.stack = []  # スタックを追加
         self.last_pop = None  # pop コマンド(ユーザー入力)で取り出した値を一時的に格納。演算でpopする場合は対象外
         self.operator = {
             "==": (lambda x1, x2: x1 == x2),    # Equal
             "!=": (lambda x1, x2: x1 != x2),    # Not equal
             "<=": (lambda x1, x2: x1 <= x2),    # Less than or equal to
             "<": (lambda x1, x2: x1 < x2),      # Less than
@@ -270,156 +432,103 @@
             "round": (lambda x: round(x)),  # Round
             "randint": (lambda x1, x2: random.randint(int(x1), int(x2))),  # Generate a random integer within a specified range
             "uniform": (lambda x1, x2: random.uniform(x1, x2)),  # Generate a random floating-point number within a specified range
             "dice": (lambda num_dice, num_faces: sum(random.randint(1, int(num_faces)) for _ in range(int(num_dice)))),  # Roll dice (e.g., 3d6) 
             "delete": (lambda index: self.stack.pop(index)),  # Remove the element at the specified index
             "pluck": (lambda index: self.stack.pop(index)),  # Remove the element at the specified index and move it to the top of the stack
             "pick": (lambda index: self.stack.append((self.stack[index]))),  # Copy the element at the specified index to the top of the stack
-            "pop": (lambda: self.stack.pop()),  # pop
-            "dup": (lambda: self._dup()),  # Duplicate the top element of the stack
-            "swap": (lambda: self._swap()),  # # Swap the top two elements of the stack
+            # "pop": (lambda: self.stack.pop()),  # pop
+            "pop": (lambda: self.pop()),  # pop
+            "dup": (lambda: self.dup()),  # Duplicate the top element of the stack
+            "swap": (lambda: self.swap()),  # # Swap the top two elements of the stack
+            "peek": (lambda: self.peek()),  # Refer to the topmost element (the "top" of the stack) without deleting it
             "insert": (lambda index, value: self.stack.insert(index, value)),  # insert
             "rev": (lambda: self.stack.reverse()),  # reverse
             "exec": (lambda command: exec(command, globals())),  # Execute the specified Python code
-            "eval": (lambda command: eval(command)),  # Evaluate the specified Python expression
+            "eval": (lambda command: self._eval(command)),  # Evaluate the specified Python expression
             "echo": (lambda value: print(value)),
             "ans": (lambda: self.get_last_ans()),
+            "set": (lambda name, value: self._set(value, name)),
+            "fn": (lambda func_name, fargs, body: self.fn_operator(func_name, fargs, body))
+        }
+        self.variables = {
+            "pi": math.pi,
+            "tau": math.tau,
+            "e": math.e,
+            "true": True,
+            "false": False,
+            "inf": float("inf"),
+            "nan": math.nan,
         }
-        self.non_destructive_operator = {"exec", "delete", "pick", "rev", "echo", "insert", "dup", "swap"} # このコマンド実行時は戻り値をStackしない
+        self.functions = {}
+        self.reserved_word = [
+            "help", "help-jp", "about", "exit",
+            "delete_history", "last_pop", "end", "clear"
+        ]
+        # このコマンド実行時は戻り値をStackしない
+        self.non_destructive_operator = {
+            "exec", "delete", "pick", "rev", "echo",
+            "insert", "dup", "swap", "set", "show_all_valiables", "whos", "fn"}
         self.plugins = {}
         self.plugin_descriptions = {}
-        self.plugin_dir = plugin_dir
 
-    def _dup(self):
+    def dup(self):
         self.stack.append(self.stack[-1])
 
-    def _swap(self):
+    def swap(self):
         self.stack[-1], self.stack[-2] = self.stack[-2], self.stack[-1]
 
-    def get_last_ans(self):
+    def peek(self):
         return self.stack[-1]
 
-    def split_expression(self, expression: str) -> list:
-        operator_pattern = "|".join(re.escape(op) for op in self.operator.keys())
-        token_pattern = re.compile(
-            r"(?P<curly_bracket_string>\{(?:[^\{\}\\]|\\.|(?:\{[^\{\}\\]*\}))*\})|"
-            r"(?P<triple_quoted_string>(\"\"\"(?:[^\"\\]|\\.|[\n\r])*\"\"\")|(\'\'\'(?:[^\'\\]|\\.|[\n\r])*\'\'\'))|"
-            fr"(?P<operator>({operator_pattern}))|"
-            r"(?P<multidim_array>\[\[.*?\]\])|"
-            r"(?P<array>\[.*?\])|"
-            r"(?P<multidim_tuple>\(\(.*?\)\))|"
-            r"(?P<tuple>\(.*?\))|"
-            r"(?P<complex>-?\d+(?:\.\d*)?(?:[eE][-+]?\d+)?[jJ])|"
-            r"(?P<binary>-?0b[01]+)|"
-            r"(?P<octal>-?0o[0-7]+)|"
-            r"(?P<hex>-?0x[\da-fA-F]+)|"
-            r"(?P<float>-?\d+(?:\.\d*)?(?:[eE][-+]?\d+)?(?:[jJ])?)|"
-            r"(?P<operator_or_identifier>[^\s,]+)|"
-            r"(?P<string>(?:'[^']*')|(?:\"[^\"]*\"))"
-            r"(?P<brace_string>{(?:[^{}]|\{.*\})*})"  # Brace string
-        )
-        ignore_tokens = ['"""', "'''"]
-        tokens = []
-        for match in token_pattern.finditer(expression):
-            for group, value in match.groupdict().items():
-                if value is not None:
-                    if value in ignore_tokens:
-                        continue
-                    if value.startswith("{") and value.endswith("}"):
-                        value = f"'{str(value[1:-1])}'"
-                        tokens.append(value)
-                        break
-                    tokens.append(value)
-                    break
-            else:
-                raise ValueError(f"Invalid token found in expression: {expression}")
-        return tokens
+    def _eval(self, expression: str):
+        logging.debug(f"eval: {expression}")
+        if isinstance(expression, str):
+            return eval(expression)
+
+    def _set(self, value, name):
+        logging.debug(f"{name} {value} set")
+        self.variables[name] = value
+
+    def clear_stack(self):
+        self.stack = []
+
+    def pop(self, stack: list = None):
+        if stack is None:
+            return self.stack.pop()
+        else:
+            return stack.pop()
+
+    def fn_operator(self, func_name, fargs, blockstack: Stacker):
+        logging.debug(f"fn_operator: func_name:{func_name}, args: {fargs}, expression: {blockstack.blocklabel}")
+        # self.operator[func_name] = (lambda *args: self._debug(*args))
+        function = StackerFunction(fargs, blockstack)
+        if func_name in self.operator.keys():
+            del self.operator[func_name]
+        self.register_operator(func_name, function, push_result_to_stack=True)
+
+    def get_stack(self):
+        return copy.deepcopy(self.stack)
+
+    def get_stack_length(self):
+        return len(self.stack)
+
+    def get_last_ans(self):
+        return self.stack[-1]
 
     def get_n_args_for_operator(self, token: str) -> int:
         # token(演算子)に必要な引数の数
         if token in self.operator:
             op = self.operator[token]
             arg_count = op.arg_count if hasattr(op, 'arg_count') else op.__code__.co_argcount
             return arg_count
             # return self.operator[token].__code__.co_argcount
         else:
             raise KeyError(f"Invalid token {token}")
 
-    def apply_operator(self, token: str, stack: list):
-        """
-        Applies an operator to the top elements on the stack.
-        Modifies the stack in-place.
-        """
-        n_args = self.get_n_args_for_operator(token)
-        if n_args is None:
-            raise ValueError(f"Unknown operator '{token}'")
-        if len(stack) < n_args:
-            raise ValueError(f"Not enough operands for operator '{token}'")
-        args = [stack.pop() for _ in range(n_args)]
-        args.reverse()  # 引数の順序を逆にする
-        ans = self.operator[token](*args)
-        if token in self.non_destructive_operator:
-            return
-        elif token == "pop":  # popの場合は戻り値を保存
-            self.last_pop = ans
-        else:
-            stack.append(ans)  # stackは参照渡し
-
-    def evaluate(self, expression: str, stack=None) -> list:
-        """
-        Evaluates a given RPN expression.
-        Returns the result of the evaluation.
-        """
-        if stack is None:
-            stack = []
-        tokens = self.split_expression(expression)
-
-        for token in tokens:
-            # token: (str)
-            if token in self.operator:
-                self.apply_operator(token, stack)
-            elif token == "=>":
-                continue
-            elif token == "last_pop":  # popコマンドでpopした値
-                stack.append(self.last_pop)
-            elif token in self.variables:
-                stack.append(self.variables[token])  # 定数をスタックにプッシュ
-            elif token in self.functions:
-                if len(stack) < len(self.functions[token][0]):
-                    raise ValueError(f"Not enough arguments for function '{token}'")
-                args = [stack.pop() for _ in range(len(self.functions[token][0]))][::-1]
-                stack.append(self.evaluate_function(token, *args))
-            elif (
-                (token.startswith("'") and token.endswith("'")) or
-                (token.startswith('"') and token.endswith('"'))
-            ):
-                stack.append(token[1:-1])
-            else:
-                try:
-                    stack.append(evaluate_token_or_return_str(token))
-                except ValueError:
-                    raise ValueError(f"Invalid token '{token}'")
-        return stack
-
-    # def register_operator(self, operator_name: str, operator_func: callable, push_result_to_stack: bool) -> None:
-    #     if not push_result_to_stack:
-    #         self.non_destructive_operator.add(operator_name)
-    #     self.operator[operator_name] = operator_func
-
-    # def register_plugin(
-    #         self,
-    #         operator_name: str,
-    #         operator_func: callable,
-    #         push_result_to_stack: True = True,
-    #         description_en: str | None = None,
-    #         description_jp: str | None = None
-    # ):
-    #     self.register_operator(operator_name, operator_func, push_result_to_stack)
-    #     self.plugin_descriptions[operator_name] = {"en": description_en, "jp": description_jp}
-
     def register_operator(
         self,
         operator_name: str,
         operator_func: callable,
         push_result_to_stack: bool
     ) -> None:
         if not push_result_to_stack:
@@ -431,225 +540,227 @@
             operator_name: str,
             operator_func: callable,
             push_result_to_stack: bool = True,
             pass_core: bool = False,
             description_en: str | None = None,
             description_jp: str | None = None
     ):
-
         if pass_core:
             original_operator_func = operator_func
-
             def wrapped_operator_func(*args, **kwargs):
                 wraped = original_operator_func(self, *args, **kwargs)
                 return wraped
             wrapped_operator_func.arg_count = original_operator_func.__code__.co_argcount - 1
             operator_func = wrapped_operator_func
 
         self.register_operator(operator_name, operator_func, push_result_to_stack)
         self.plugin_descriptions[operator_name] = {"en": description_en, "jp": description_jp}
 
-
-class Stacker(StackerCore):
-    def __init__(self):
-        super().__init__()
-        self.variables = {
-            "pi": math.pi,
-            "tau": math.tau,
-            "e": math.e,
-            "true": True,
-            "false": False,
-            "inf": float("inf"),
-            "nan": math.nan,
-        }
-        self.functions = {}
-        self.reserved_word = [
-            "help", "help-jp", "about", "exit",
-            "delete_history", "last_pop", "end", "clear"
-        ]
-
     def highlight_syntax(self, expression):
         """
         Highlights the syntax of the given RPN expression.
         Returns a colored string of the input expression.
         """
         tokens = expression.split()
         highlighted_tokens = []
-
         for token in tokens:
             if token in self.operator:
                 color = "cyan"
                 if token in {"==", "!=", "<", "<=", ">", ">="}:
                     color = "yellow"
                 elif token in {"and", "or"}:
                     color = "green"
                 highlighted_tokens.append(colored(token, color))
             else:
                 try:
                     float(token)
                     highlighted_tokens.append(colored(token, "white"))
                 except ValueError:
                     highlighted_tokens.append(colored(token, "red"))
-
         return " ".join(highlighted_tokens)
 
-    def clear_stack(self):
-        self.stack = []
 
-    def define_function(self, name, arg_labels, expression):
-        self.validate_name(name)
-        self.functions[name] = (arg_labels, expression)
-
-    def validate_name(self, name):
-        """
-        Validates if a given name is not a reserved word or an operator.
-        Raises a ValueError if the name is invalid.
-        """
-        if name in self.operator or name.lower() in self.reserved_word:
-            raise ValueError(f"Invalid name '{name}', it is a reserved word.")
-        return name
+class Stacker(StackerCore):
+    depth_counter = 0
 
-    def assign_variable(self, name, value):
-        """
-        Assigns a value to a variable with the given name.
-        """
-        if is_array(value):
-            value = self.convert_custom_array_to_proper_list(value)
-            value = evaluate_token_or_return_str(value)
-        elif is_tuple(value):
-            value = self.convert_custom_tuple_to_proper_tuple(value)
-            value = evaluate_token_or_return_str(value)
-        self.variables[name] = value
+    def __init__(self, blocklabel: str | None = None):
+        super().__init__()
+        self.depth = Stacker.depth_counter
+        Stacker.depth_counter += 1
+        self.blocklabel = blocklabel
+        self.child = None
 
-    def evaluate_function(self, name, *args):
+    def parse_expression(self, expression: str) -> list:
         """
-        Evaluates a function with the given name and arguments.
-        Returns the result of the evaluation.
+            input(str)  : [1 2 3] 4 5 a
+            output(list): [[1, 2, 3], 4, 5, 'a']
         """
-        arg_labels, expression = self.functions[name]  # 引数のラベルと式を取得
-        if len(arg_labels) != len(args):
-            raise ValueError(f"Function '{name}' requires {len(arg_labels)} arguments, {len(args)} provided")
-        for label, arg in zip(arg_labels, args):  # 引数の値を割り当てる
-            self.assign_variable(label, arg)
-        result = self.evaluate(expression)
-        return result[-1]  # 評価された関数の結果だけを返す
+        ignore_tokens = ['"""', "'''"]
 
-    def process_function_definition(self, expression):
-        tokens = expression.split()
-        name = tokens[tokens.index("=>") - 1]
-        self.validate_name(name)
-        arg_labels = tokens[:tokens.index("=>") - 1]  # 引数のラベルを取得
-        function_expression = " ".join(tokens[tokens.index("=>") + 1:])
-        if name in self.operator:
-            raise ValueError(f"Invalid function name '{name}'")
-        self.define_function(name, arg_labels, function_expression)  # 引数を追加
-        highlighted_function = self.highlight_syntax(function_expression)
-        print(colored(f"Function '{name}' defined: ", "magenta") + highlighted_function)
-
-    def process_variable_assignment(self, expression):
-        name, value_expression = [s.strip() for s in expression.split("=", 1)]
-        if name in self.operator:
-            raise ValueError(f"Invalid variable name '{name}'")
-        self.validate_name(name)
-        value = self.evaluate(value_expression)[0]
-        self.assign_variable(name, value)
-
-    def process_expression(self, expression):
-        expression = self.parse_expression(expression)
-        if "=>" in expression:  # 関数定義 (it is not RPN su)
-            self.process_function_definition(expression)
-        elif is_assignment(expression): # 代入処理
-            self.process_variable_assignment(expression)
-        else:  # RPN式の評価と結果の表示
-            self.evaluate(expression, stack=self.stack)
+        # pattern = r'\[.*?\]|\(.*?\)|\{.*?\}|\'[^\']*\'|\S+'
+        # parsed_expressions = re.findall(pattern, expression)
+        parsed_expressions = parse_string(expression)
+        logging.debug(f"parsed_expressions: {parsed_expressions}")
+        tokens = []
+        for token in parsed_expressions:
+            if token in ignore_tokens:
+                continue
+            elif is_array(token):
+                token = convert_custom_array_to_proper_list(token)
+                tokens.append(evaluate_token_or_return_str(token))
+            elif is_tuple(token):
+                token = convert_custom_tuple_to_proper_tuple(token)
+                tokens.append(evaluate_token_or_return_str(token))
+            else:
+                tokens.append(evaluate_token_or_return_str(token))
+        return tokens
 
-    # List
-    def convert_custom_array_to_proper_list(self, token: str) -> str:
-        """
-        Converts a custom list token into a proper Python list.
+    def process_expression(self, expression) -> None:
+        tokens = self.parse_expression(expression)
+        logging.debug(f"process_expression expression: {expression}")
+        logging.debug(f"process_expression tokens: {tokens}")
+        self.evaluate(tokens, stack=self.stack)
+
+    def substack(self, token: str) -> None:
+        logging.debug(f"sub block: {token}")
+        self.child = Stacker()
+        self.child.blocklabel = token
+        expression = token[1:-1]
+        if expression == {}:
+            self.stack.append(None)
+        else:
+            self.stack.append(self.child)
 
-        :param token: The custom list token to be converted.
-        :return: The converted token as a proper Python list.
+    def pop(self, stack: list = None):
+        if stack is None:
+            stack = self.stack
+        value = stack.pop()
+        logging.debug(f"pop: {value}")
+        if not isinstance(value, Stacker):
+            if isinstance(value, list) or isinstance(value, tuple):
+                return value
+            if value in self.variables.keys():
+                logging.debug(f"variables {self.variables}")
+                logging.debug(f"valiable {value}: {self.variables[value]}")
+                return self.variables[value]
+            return value
+        # block
+        token = value.blocklabel  # {...}
+        expression = token[1:-1]
+        if expression == {}:
+            stack.append(None)
+        else:
+            value.process_expression(expression)
+            substack = value.get_stack()
+            if len(substack) > 0:
+                for i in range(len(substack)):
+                    stack.append(substack[i])
+            return stack.pop()
 
-        Example:
-        Input:  "[1 2 3; 4 5 6]"
-        Output: "[[1, 2, 3], [4, 5, 6]]"
+    def evaluate(self, tokens: list, stack=None) -> list:
         """
-        token = re.sub(r"(\d+(\.\d+)?)\s+", r"\1, ", token)
-        token = re.sub(r";\s+", r"], [", token)
-
-        open_brackets = token.count('[')
-        close_brackets = token.count(']')
-        if open_brackets > close_brackets:
-            token += ']' * (open_brackets - close_brackets)
-        if is_array(token) and not is_single_array(token):
-            token = f"[{token}]"
-        return token
-
-    # Tuple
-    def convert_custom_tuple_to_proper_tuple(self, token: str) -> str:
+        Evaluates a given RPN expression.
+        Returns the result of the evaluation.
         """
-        Converts a custom tuple token into a proper Python tuple.
+        if stack is None:
+            stack = []
 
-        :param token: The custom tuple token to be converted.
-        :return: The converted token as a proper Python tuple.
+        # Ensure tokens is a list
+        assert isinstance(tokens, list) is True
+        logging.debug(f"evaluate tokens: {tokens}")
 
-        Example:
-        Input:  "(1 2 3; 4 5 6)"
-        Output: "((1, 2, 3), (4, 5, 6))"
-        """
-        token = re.sub(r"(\d+(\.\d+)?)\s+", r"\1, ", token)
-        token = re.sub(r";\s+", r"), (", token)
+        # Iterate over each token in the token list
+        for token in tokens:
+            logging.debug(f"tokens: {token}, type: {type(token)}")
+            # If the token is not a string (e.g. it's a number), add it to the stack
+            if not isinstance(token, str):
+                stack.append(token)
+            # If the token is an operator and we're not in a function definition ("fn" is not in the tokens)
+            # apply the operator to the current stack
+            elif token in self.operator and not "fn" in tokens:
+                self.apply_operator(token, stack)
+            # If we're defining a function (token is "fn"), also apply the operator
+            elif token == "fn":
+                self.apply_operator(token, stack)
+            # If the token is "last_pop", append the last popped value from the stack.
+            # This is a special command to retrieve the last popped value.
+            elif token == "last_pop":
+                stack.append(self.last_pop)
+            # If the token is a block (substack), evaluate the substack
+            elif is_block(token):
+                self.substack(token)
+            # If none of the above conditions are met, just add the token to the stack
+            else:
+                stack.append(token)
+            logging.debug(f"stack: {stack}")
+        return stack
 
-        open_parenthesis = token.count('(')
-        close_parenthesis = token.count(')')
-        if open_parenthesis > close_parenthesis:
-            token += ')' * (open_parenthesis - close_parenthesis)
-        if is_tuple(token) and not is_single_tuple(token):
-            token = f"({token})"
-        return token
+    def apply_operator(self, token: str, stack: list):
+        """
+        Applies an operator to the top elements on the stack.
+        Modifies the stack in-place.
+        """
+        n_args = self.get_n_args_for_operator(token)
+        if n_args is None:
+            raise ValueError(f"Unknown operator '{token}'")
+        if len(stack) < n_args:
+            raise ValueError(f"Not enough operands for operator '{token}'")
+        # args = [stack.pop() for _ in range(n_args)]
+        if token == "set":
+            # 代入操作の場合、self.pop()ではなく、stack.pop()する
+            # self.pop()は, popと同時に評価するため、定義済み変数に再割当て時に
+            # 変数値に対し代入してしまうため
+            args = []
+            name = self.stack.pop()  # not evaluate
+            value = self.pop(stack)
+            args.append(value)
+            args.append(name)
+        elif token == "fn":
+            args = []
+            name = self.stack.pop()  # not evaluate
+            body = self.stack.pop()  # not evaluate  blockstack
+            fargs = self.pop(stack)
+            fargs = convert_custom_string_tuple_to_proper_tuple(fargs)  # TODO Refacotring
+            fargs = ast.literal_eval(fargs)  # TODO Refacotring
+            logging.debug(f"define function")
+            logging.debug(f"name: {name}, args: {fargs}, body: {body}")
+            args.append(body)
+            args.append(fargs)
+            args.append(name)
+        else:
+            args = [self.pop(stack) for _ in range(n_args)]
+        args.reverse()  # 引数の順序を逆にする
+        ans = self.operator[token](*args)
+        if token in self.non_destructive_operator:
+            return
+        elif token == "pop":  # popの場合は戻り値を保存
+            self.last_pop = ans
+        else:
+            stack.append(ans)  # stackは参照渡し
 
-    def parse_expression(self, expression):
-        new_expression = ""
-        if is_array(expression):  # custom list notation
-            if "," in expression:
-                raise ValueError(
-                    f"Invalid expression: {expression}. Please use Stacker's list notation instead of Python-style lists."
-                    f"For example, use '[1 2 3]' for a one-dimensional array, "
-                    f"or '[1 2 3; 4 5 6]' for a two-dimensional array."
-                )
-            tokens = expression.split("]")
-            tokens = [t.strip() for t in tokens]
-            new_tokens = []
-            for token in tokens:
-                token = self.convert_custom_array_to_proper_list(token)
-                new_tokens.append(token)
-            new_expression = ", ".join(new_tokens)
-            if new_expression[len(new_expression)-2:-1] == ",":
-                new_expression = new_expression[:-2]
-
-        elif is_tuple(expression):  # custom tuple notation
-            if "," in expression:
-                raise ValueError(
-                    f"Invalid expression: {expression}. Please use Stacker's tuple notation instead of Python-style tuples."
-                    f"For example, use '(1 2 3)' for a one-dimensional tuple."
-                )
-            tokens = expression.split(")")
-            tokens = [t.strip() for t in tokens]
-            new_tokens = []
-            for token in tokens:
-                token = self.convert_custom_tuple_to_proper_tuple(token)
-                new_tokens.append(token)
-            new_expression = ", ".join(new_tokens)
-            if new_expression[len(new_expression)-2:-1] == ",":
-                new_expression = new_expression[:-2]
 
-        else:
-            new_expression = expression
-        return new_expression
+class StackerFunction:
+    def __init__(self, args: list[str], blockstack: Stacker):
+        self.args = args
+        self.blockstack = blockstack
+        self.arg_count = len(args)
+
+    def __call__(self, *values):
+        values = list(values)
+        if len(values) != len(self.args):
+            raise ValueError(f"Expected {len(self.args)} arguments, got {len(values)}")
+        # Create a new stack for the function call
+        # Bind the arguments to the values
+        for arg, value in zip(self.args, values):
+            # stacker.variables[arg] = value
+            self.blockstack._set(value, arg)
+            self.blockstack.stack.append(arg)
+        self.blockstack.stack.append(self.blockstack)
+        result = self.blockstack.pop()
+        return result
 
 
 def load_plugins(stacker_core: StackerCore):
     script_dir = os.path.dirname(os.path.abspath(__file__))
     plugins_dir = os.path.join(script_dir, plugins_dir_path)
     # プラグインディレクトリにパスを追加
     sys.path.insert(0, plugins_dir)
@@ -698,37 +809,57 @@
                 lines.append(line)
                 break
         return "\n".join(lines)
 
     def run(self):
         raise NotImplementedError("Subclasses must implement the 'run' method")
 
-
-class InteractiveMode(ExecutionMode):
-
     def print_colored_output(self, stack_list):
         stack_str = colored("[", 'yellow')
         for item in stack_list:
             item_str = str(item)
+            # print(item_str)
             if item_str.startswith('[') or item_str.endswith(']'):
                 stack_str += colored(item_str, 'red')
                 stack_str += ", "
             elif item_str.startswith('(') or item_str.endswith(')'):
                 stack_str += colored(item_str, 'green')
                 stack_str += ", "
             elif item_str.replace('.', '', 1).isdigit() or (item_str.startswith('-') and item_str[1:].replace('.', '', 1).isdigit()):
                 stack_str += colored(item_str, 'default')
                 stack_str += ", "
+            elif item_str in list(self.rpn_calculator.variables.keys()):
+                stack_str += colored(item_str, 'lightblue')
+                stack_str += ", "
             else:
-                stack_str += colored(item_str, 'blue')
+                stack_str += colored(item_str, 'default')
                 stack_str += ", "
         stack_str = stack_str[0:-2]
         stack_str += colored("]", 'yellow')
         print(stack_str)
 
+    def show_stack(self) -> None:
+        tokens = self.rpn_calculator.get_stack()
+        if len(tokens) == 0:
+            return
+        stack = []
+        for token in tokens:
+            if isinstance(token, Stacker):
+                stack.append(token.blocklabel)
+            else:
+                stack.append(token)
+
+        if self.color_print is True:
+            self.print_colored_output(stack)
+        else:
+            print(stack)
+
+
+class InteractiveMode(ExecutionMode):
+
     def run(self):
         show_top()
         stacker_version = get_distribution('pystacker').version
         print(f"Stacker {stacker_version} on {sys.platform}")
         print('Type "help" or "help-jp" to get more information.')
 
         line_count = 0
@@ -745,20 +876,20 @@
                     expression = expression[:-2] + closer
 
                 if is_array(expression) or is_tuple(expression):
                     """
                         # List
                         stacker:0> [1 2 3
                                     3 4 5]
-                        [[1, 2, 3], [3, 4, 5]]
+                        [1 2 3; 3 4 5]
 
                         # Tuple
                         stacker:0> (1 2 3
                                     3 4 5)
-                        [(1, 2, 3), (3, 4, 5)]
+                        (1 2 3; 3 4 5)
                     """
                     while not is_array_balanced(expression) or not is_tuple_balanced(expression):
                         next_line = prompt(
                             " " * (len(f"stacker:{line_count}> ") - len("> ")) + "> ",
                             history=FileHistory(history_file_path),
                         )
                         if next_line.lower() == ('end'):
@@ -793,14 +924,16 @@
                     next_line = prompt(
                         " " * (len(f"stacker:{line_count}> ") - len("> ")) + "> ",
                         history=FileHistory(history_file_path),
                         completer=self.completer,
                     )
                     expression += "\n" + next_line
 
+                logging.debug(f"input expression: {expression}")
+
                 if expression.lower() == "exit":
                     break
                 if expression.lower() == "help":
                     show_help()
                     print("")
                     print("Plugin commands:")
                     for plugin_name, plugin_descriptions in self.rpn_calculator.plugin_descriptions.items():
@@ -826,25 +959,19 @@
                     delete_history()
                     continue
                 if expression.lower() == "clear":
                     self.rpn_calculator.clear_stack()
                     continue
 
                 self.rpn_calculator.process_expression(expression)
-                stack = self.rpn_calculator.stack
-                if stack is not None:
-                    if not is_assignment(expression):
-                        # stackを全表示
-                        if self.color_print is True:
-                            self.print_colored_output(stack)
-                        else:
-                            print(stack)
+                self.show_stack()
 
             except Exception as e:
                 print(colored(f"[ERROR]: {e}", "red"))
+                traceback.print_exc()
 
             line_count += 1
 
 
 class ScriptMode(ExecutionMode):
     def __init__(self, rpn_calculator: Stacker):
         super().__init__(rpn_calculator)
@@ -858,23 +985,59 @@
             for line in script_file:
                 line = line.strip()
 
                 if not line.startswith('#') and line:
                     self.rpn_calculator.process_expression(line)
 
 
+def copy_plugin_to_install_dir(plugin_path: str) -> None:
+    try:
+        # Get the installation directory of Stacker
+        stacker_dist = get_distribution("pystacker")
+        plugin_dir = stacker_dist.location + "/stacker/plugins"
+
+        # Check if the plugin file exists
+        if not os.path.isfile(plugin_path):
+            print(f"Error: The file '{plugin_path}' does not exist.")
+            return
+
+        # Copy the plugin file to the Stacker's installation directory
+        assert Path(plugin_dir).exists
+        shutil.copy(plugin_path, plugin_dir)
+        print(f"Successfully added the plugin '{plugin_path}' to Stacker.")
+        print(plugin_dir)
+    except Exception as e:
+        print(f"An error occurred while adding the plugin: {str(e)}")
+        traceback.print_exc()
+
+
 def main():
+    # add plugin
+    parser = argparse.ArgumentParser(description='Stacker command line interface.')
+    parser.add_argument('--addplugin', metavar='path', type=str, help='Path to the plugin to add.')
+    parser.add_argument('--dmode', action='store_true', help='Enable debug mode')
+    parser.add_argument('script', nargs='?', default=None, help='Script file to run.')
+    args = parser.parse_args()
+
+    if args.addplugin:
+        copy_plugin_to_install_dir(args.addplugin)
+        return
+
+    if args.dmode:
+        logging.basicConfig(level=logging.DEBUG)
+    else:
+        logging.basicConfig(level=logging.INFO)
+
     rpn_calculator = Stacker()
     load_plugins(rpn_calculator)
 
-    if len(sys.argv) > 1:
-        script_filename = sys.argv[1]
+    if args.script:
         # Script Mode
         script_mode = ScriptMode(rpn_calculator)
-        script_mode.run(script_filename)
+        script_mode.run(args.script)
     else:
         # Interactive mode
         interactive_mode = InteractiveMode(rpn_calculator)
         interactive_mode.run()
 
 
 if __name__ == "__main__":
```

## stacker/plugins/branch.py

```diff
@@ -1,16 +1,16 @@
 from stacker.stacker import Stacker
 
 
-def branch_command(condition, true_block, false_block):
+def branch_command(true_block, false_block, condition: bool):
     if condition:
         return true_block
     else:
         return false_block
 
 
-def setup(stacker_core: Stacker):
-    stacker_core.register_plugin(
+def setup(stacker: Stacker):
+    stacker.register_plugin(
         "branch",
         branch_command,
         description_en="Execute true_block if condition is True, else execute false_block."
     )
```

## stacker/plugins/matrix.py

```diff
@@ -1,10 +1,10 @@
 import numpy as np
 
-from stacker.stacker import StackerCore
+from stacker.stacker import Stacker
 
 description_en = "Matrix operations plugin for Stacker, similar to MATLAB."
 
 
 def is_matrix(value):
     return isinstance(value, list) and len(value) > 0 and isinstance(value[0], list)
 
@@ -101,25 +101,25 @@
 #     print(np.ndim(a))
 
 
 # def shape(a) -> tuple:
 #     print(np.shape(a))
 
 
-def setup(stacker_core: StackerCore):
-    stacker_core.register_plugin("+", matrix_add, description_en=description_en)
-    stacker_core.register_plugin("-", matrix_sub, description_en=description_en)
-    stacker_core.register_plugin("*", matrix_mul, description_en=description_en)
-    stacker_core.register_plugin(".*", elementwise_mul, description_en=description_en)
-    stacker_core.register_plugin("./", elementwise_div, description_en=description_en)
-    stacker_core.register_plugin(".\\", elementwise_div_inv, description_en=description_en)
-    stacker_core.register_plugin("'", matrix_transpose, description_en=description_en)
-    stacker_core.register_plugin("inv", matrix_inverse, description_en=description_en)
-    stacker_core.register_plugin("det", matrix_determinant, description_en=description_en)
-    stacker_core.register_plugin("rank", matrix_rank, description_en=description_en)
-    stacker_core.register_plugin("trace", matrix_trace, description_en=description_en)
-    stacker_core.register_plugin("ones", ones, description_en=description_en)
-    stacker_core.register_plugin("zeros", zeros, description_en=description_en)
-    stacker_core.register_plugin("diag", diag, description_en=description_en)
+def setup(stacker: Stacker):
+    stacker.register_plugin("+", matrix_add, description_en=description_en)
+    stacker.register_plugin("-", matrix_sub, description_en=description_en)
+    stacker.register_plugin("*", matrix_mul, description_en=description_en)
+    stacker.register_plugin(".*", elementwise_mul, description_en=description_en)
+    stacker.register_plugin("./", elementwise_div, description_en=description_en)
+    stacker.register_plugin(".\\", elementwise_div_inv, description_en=description_en)
+    stacker.register_plugin("'", matrix_transpose, description_en=description_en)
+    stacker.register_plugin("inv", matrix_inverse, description_en=description_en)
+    stacker.register_plugin("det", matrix_determinant, description_en=description_en)
+    stacker.register_plugin("rank", matrix_rank, description_en=description_en)
+    stacker.register_plugin("trace", matrix_trace, description_en=description_en)
+    stacker.register_plugin("ones", ones, description_en=description_en)
+    stacker.register_plugin("zeros", zeros, description_en=description_en)
+    stacker.register_plugin("diag", diag, description_en=description_en)
     # stacker_core.register_plugin("ndim", ndim, push_result_to_stack=False, description_en=description_en)
     # stacker_core.register_plugin("size", size, push_result_to_stack=False, description_en=description_en)
     # stacker_core.register_plugin("shape", shape, push_result_to_stack=False, description_en=description_en)
```

## stacker/plugins/tolist.py

```diff
@@ -1,15 +1,26 @@
 
 def tolist(stacker_core, start, end):
+    """
+    stacker:0> 1 2 3 4 5 6 7 8 9 10
+    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+    stacker:1> 4 8 tolist
+    [1, 2, 3, 4, [5, 6, 7, 8], 9, 10]
+    """
     sublist = stacker_core.stack[start:end]
     new_stack = (stacker_core.stack[:start] + [sublist] + stacker_core.stack[end:])
     stacker_core.stack = new_stack
 
 
 def unlist(stacker_core, index: int) -> None:
+    """
+    [1, 2, 3, 4, [5, 6, 7, 8], 9, 10]
+    stacker:3> 4 unlist
+    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
+    """
     if not stacker_core.stack:
         raise ValueError("Stack is empty")
     if index < 0 or index >= len(stacker_core.stack):
         raise IndexError("Invalid index")
 
     target = stacker_core.stack[index]
     if not isinstance(target, list):
```

## test/test.py

```diff
@@ -138,20 +138,20 @@
         self.stacker.process_expression("1 2 3 4 5")
         self.assertEqual(self.stacker.stack, [1, 2, 3, 4, 5])
         self.stacker.process_expression("rev")
         self.assertEqual(self.stacker.stack, [5, 4, 3, 2, 1])
 
     def test_variable_assignment(self):
         self.stacker.stack.clear()
-        self.stacker.process_expression("a = 5")
+        self.stacker.process_expression("5 a set")
         self.assertEqual(self.stacker.variables["a"], 5)
 
     def test_function_definition_and_call(self):
         self.stacker.stack.clear()
-        self.stacker.process_expression("x f => x x *")
+        self.stacker.process_expression("(x) {x x *} f fn")
         self.stacker.process_expression("4 f")
         self.assertEqual(self.stacker.stack[-1], 16)
 
     def test_input(self):
         # int
         self.stacker.process_expression("5")
         self.assertEqual(self.stacker.stack[-1], 5)
@@ -251,23 +251,28 @@
         self.assertEqual(self.stacker.stack[-1], 6)
         self.assertEqual(self.stacker.stack[-2], 5)
         self.assertEqual(self.stacker.stack[-3], ((1, 2, 3), (4, 5, 6), (7, 8, 9)))
 
     # valiable
     def test_variable_assign_1(self):
         self.stacker.stack.clear()
-        self.stacker.process_expression("a = 123")
+        self.stacker.process_expression("123 a set")
         self.stacker.process_expression("a")
-        self.assertEqual(self.stacker.stack[-1], 123)
+        self.stacker.process_expression("pop")
+        self.assertEqual(self.stacker.last_pop, 123)
 
     def test_variable_assign_2(self):
         self.stacker.stack.clear()
-        self.stacker.process_expression("b = 30 50 +")
+        self.stacker.process_expression("{30 50 +} b set")
         self.stacker.process_expression("b")
-        self.assertEqual(self.stacker.stack[-1], 80)
-
-
+        self.stacker.process_expression("pop")
+        self.assertEqual(self.stacker.last_pop, 80)
 
+    # blockstack
+    def test_blockstack(self):
+        self.stacker.stack.clear()
+        self.stacker.process_expression("1 {3 {4 5 +} *} +")
+        self.assertEqual(self.stacker.stack[-1], 28)
 
 
 if __name__ == "__main__":
     unittest.main()
```

## Comparing `EGG-INFO/PKG-INFO` & `pystacker-1.4.0.dist-info/METADATA`

 * *Files 12% similar despite different names*

```diff
@@ -1,38 +1,35 @@
 Metadata-Version: 2.1
 Name: pystacker
-Version: 1.2.9
+Version: 1.4.0
 Summary: Stacker: RPN Calculator in Python
 Home-page: https://github.com/remokasu/stacker
 Author: remokasu
-License: MIT License
-        
-        Copyright (c) 2023 Remokasu
-        
+License: MIT License        
+        Copyright (c) 2023 Remokasu        
         Permission is hereby granted, free of charge, to any person obtaining a copy
         of this software and associated documentation files (the "Software"), to deal
         in the Software without restriction, including without limitation the rights
         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         copies of the Software, and to permit persons to whom the Software is
-        furnished to do so, subject to the following conditions:
-        
+        furnished to do so, subject to the following conditions:        
         The above copyright notice and this permission notice shall be included in all
-        copies or substantial portions of the Software.
-        
+        copies or substantial portions of the Software.        
         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-        SOFTWARE.
-        
+        SOFTWARE.        
 Keywords: reverse-polish-calculator rpn terminal-app
 Description-Content-Type: text/markdown
 License-File: LICENSE
+Requires-Dist: prompt-toolkit
+Requires-Dist: numpy
 
 # Stacker: RPN Calculator in Python
 ~~~
   _____  _                 _
  / ____|| |               | |
 | (___  | |_   __ _   ___ | | __  ___  _ __
  \___ \ | __| / _` | / __|| |/ / / _ \| '__|
@@ -129,14 +126,16 @@
 | randint  | Generate a random integer within a specified range    | `1 6 randint`              | random.randint(1, 6)     |
 | uniform  | Generate a random floating-point number within a specified range | `1 2 uniform` | random.uniform(1, 2) |
 | dice     | Roll dice (e.g., 3d6)                                 | `3 6 dice`                 | sum(random.randint(1, 6) for _ in range(3)) |
 | delete   | Remove the element at the specified index             | `2 delete`                 | Remove the element at index 2 from the stack  |
 | pluck    | Remove the element at the specified index and move it to the top of the stack | `2 pluck`              | Remove the element at index 2 and move it to the top of the stack  |
 | pick     | Copy the element at the specified index to the top of the stack | `2 pick`                   | Copy the element at index 2 to the top of the stack  |
 | pop      | Remove the top element from the stack. The value popped can be referred to as `last_pop`.   | `pop`  | Remove the top element from the stack  |
+| dup      | Duplicate the top element of the stack                | `dup`                   | Duplicate the top element of the stack |
+| swap     | Swap the top two elements of the stack                | `swap`                  | Swap the top two elements of the stack |
 | exec     | Execute the specified Python code                    | `{print(1+1)} exec`        | Execute 1+1 and print 2 |
 | eval     | Evaluate the specified Python expression             | `{1+1} eval`               | Add 2 to the stack       |
 | echo     | Print the specified value to stdout without adding it to the stack | `3 4 + echo` | Print the result of 3+4 (7) to stdout without adding it to the stack |
 
 <br>
 <hr>
 
@@ -189,26 +188,84 @@
 The input will be considered complete when the array is closed with a matching bracket. However, if you want to forcibly go back while in multi-line input mode, type `end`.
 
 
 
 <br>
 <hr>
 
+## Variables in Stacker
 
-## Custom Functions::
+In Stacker, you can define your own variables. This is done by using the `def` operator. The general syntax for variable definition is as follows:
 
-### Example 1: Function to calculate the average of two numbers (average)
+~~~
+value variableName set
+~~~
+
+
+Here's how each part of the variable definition works:
+
+1. `value`: This is the value that you want to assign to the variable.
+
+2. `variableName`: This is the name you're giving to your variable. It can be any valid identifier.
+
+3. `set`: This is the operator that tells Stacker you're defining a variable.
+
+Here's an example of a variable definition:
 
 ~~~ bash
-stacker:0> x y average => x y + 2 /
-stacker:1> 2 6 average
-[4.0]
+stacker 0:> 10 myVariable set
 ~~~
 
-(Note that the function definition syntax is a custom RPN-like syntax）
+This defines a variable named `myVariable` that holds the value `10`. 
+
+You can use this variable just like you'd use any other value:
+
+~~~ bash
+stacker 1:> myVariable 20 +
+~~~
+
+This will push `30` (the result of `10 + 20`) onto the stack.
+
+<br>
+<hr>
+
+
+## Function Definitions in Stacker
+
+In Stacker, you can define your own functions using the `fn` operator. The general syntax for function definition is as follows:
+
+~~~ bash
+(arg1 arg2 ... argN) {body} functionName fn
+~~~
+
+Here's how each part of the function definition works:
+
+1. `(arg1 arg2 ... argN)`: This is a list of arguments that your function will accept. You can define as many arguments as needed. The arguments should be space-separated and enclosed in parentheses.
+
+2. `{body}`: This is the body of your function, which is written in Stacker's Reverse Polish Notation (RPN) syntax. The body should be enclosed in curly braces `{}`.
+
+3. `functionName`: This is the name you're giving to your function. It can be any valid identifier.
+
+4. `fn`: This is the operator that tells Stacker you're defining a function.
+
+Here's an example of a function definition:
+
+~~~ bash
+stacker 0:> (x y) {x y *} multiply fn
+~~~
+
+This defines a function named `multiply` that takes two arguments `x` and `y` and multiplies them together. 
+
+You can call this function just like you'd call any other operator:
+
+~~~ bash
+stacker 1:> 10 20 multiply
+~~~
+
+This will push `200` (the result of `10 * 20`) onto the stack.
 
 <br>
 <hr>
 
 
 ## Plugin Usage
 
@@ -479,14 +536,16 @@
 | randint| 指定した範囲内の整数乱数を生成                        | `1 6 randint`              | random.randint(1, 6)     |
 | uniform| 指定した範囲内の浮動小数点数乱数を生成                | `1 2 uniform`              | random.uniform(1, 2)     |
 | dice   | サイコロを振る (例：3d6)                              | `3 6 dice`                 | sum(random.randint(1, 6) for _ in range(3)) |
 | delete   | 指定のindexを削除                                     | `2 delete`               | スタックからindex 2の要素を削除  |
 | pluck    | 指定のindexを削除し、スタックのトップに移動           | `2 pluck`                | index 2の要素を削除し、スタックのトップに移動  |
 | pick     | 指定されたインデックスの要素をスタックのトップにコピー | `2 pick`                | index 2の要素をスタックのトップにコピー  |
 | pop      | スタックのトップを削除。popした値は`last_pop`で参照できます。 | `pop`            | スタックのトップを削除  |
+| dup      | スタックのトップの要素を複製する                       | `dup`                   | スタックのトップの要素を複製 |
+| swap     | スタックのトップの２つの要素を入れ替える               | `swap`                  | スタックのトップの２つの要素を入れ替え |
 | exec     | 指定のPythonコードを実行                             | `{print(1+1)} exec`       | 1+1を出力し、2をプリント |
 | eval     | 指定のPython式を評価                                 | `{1+1} eval`              | スタックに2を追加       |
 | echo | 指定された値をstdoutに出力し、スタックには追加しない	| `3 4 + echo`	| 3+4の結果（7）をstdoutに出力し、スタックには追加しない |
 
 <br>
 <hr>
 
@@ -537,24 +596,85 @@
 
 複数行入力中に配列が閉じられたとき、入力が終了します。ただし、複数行入力中に強制的に戻るには、`end`と入力してください。
 
 
 <br>
 <hr>
 
-## 自作関数:
+## Stackerにおける変数
+
+Stackerでは、ユーザー自身が変数を定義することができます。これは`set`オペレータを用いて行います。変数定義の一般的な構文は以下の通りです：
+
+~~~ bash
+値 変数名 set
+~~~
+
+
+変数定義の各部分がどのように機能するかを以下に説明します：
+
+1. `値`: これは変数に割り当てたい値です。
+
+2. `変数名`: これは変数につける名前です。任意の有効な識別子を使用できます。
+
+3. `set`: これはStackerに変数を定義していることを伝えるオペレータです。
+
+変数定義の例を以下に示します：
+
+~~~ bash
+stacker 0:> 10 myVariable set
+~~~
+
+これにより、`10`という値を持つ`myVariable`という名前の変数が定義されます。 
+
+この変数は他の任意の値と同様に使用することができます：
+
+~~~ bash
+stacker 1:> myVariable 20 +
+~~~
+
+これにより`30` ( `10 + 20`の結果)がスタックにプッシュされます。
+
+
+<br>
+<hr>
+
+## Stackerにおける関数定義
+
+
+Stackerでは、`fn`オペレータを使って自分自身の関数を定義することができます。関数定義の一般的な構文は次のようになります：
+
+~~~ bash
+(arg1 arg2 ... argN) {本体} 関数名 fn
+~~~
+
+以下に関数定義の各部分の働きを説明します：
+
+1. `(arg1 arg2 ... argN)`: これは関数が受け入れる引数のリストです。必要なだけ引数を定義することができます。引数はスペースで区切られ、括弧で囲まれるべきです。
+
+2. `{本体}`: これは関数の本体で、Stackerの逆ポーランド記法（RPN）構文で書かれます。本体は中括弧`{}`で囲むべきです。
+
+3. `関数名`: これは関数に付ける名前です。有効な識別子であれば何でも良いです。
+
+4. `fn`: これは関数を定義しているとStackerに指示するオペレータです。
+
+関数定義の例を以下に示します：
 
-### 例 1: 二つの数の平均を計算する関数 (average)
 ~~~ bash
-stacker:0> x y average => x y + 2 /
-stacker:1> 2 6 average
-[4.0]
+stacker 0:> (x y) {x y *} 掛け算 fn
 ~~~
 
-(関数定義の構文はRPN構文っぽい独自定義の構文)
+これは`掛け算`という名前の関数を定義し、引数`x`と`y`を取り、それらを掛け合わせるというものです。
+
+この関数は他のオペレータを呼び出すのと同じように呼び出すことができます：
+
+~~~ bash
+stacker 1:> 10 20 掛け算
+~~~
+
+これは`200`（`10 * 20`の結果）をスタックにプッシュします。
 
 <br>
 <hr>
 
 ## プラグインの使い方
 
 Stackerのプラグインを作成するには、以下の手順に従ってください。
@@ -608,22 +728,14 @@
     ~~~
 
 6. Stackerが起動すると、自動的にプラグインが読み込まれ、カスタムコマンドが利用可能になります。
 
 英語（description_en）と日本語（description_jp）の説明の提供は任意です。必要がない場合は、それらの行をコメントアウトまたは削除してください。
 
 <br>
-
-### 開発中プラグイン
-
-* [シェルモード](https://github.com/remokasu/stacker-plugins/blob/main/sh.py)
-* [行列演算](https://github.com/remokasu/stacker-plugins/blob/main/matrix.py)
-
-
-<br>
 <hr>
 
 
 ## clear
 * `clear` でスタックを初期化
     ~~~ bash
     stacker:0> clear
```

